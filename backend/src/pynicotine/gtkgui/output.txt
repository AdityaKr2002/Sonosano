===== application.py =====
# SPDX-FileCopyrightText: 2020-2025 Nicotine+ Contributors
# SPDX-License-Identifier: GPL-3.0-or-later

import os
import sys
import threading
import time

import gi
from gi.repository import Gdk
from gi.repository import Gio
from gi.repository import GLib
from gi.repository import Gtk

import pynicotine
from pynicotine.config import config
from pynicotine.core import core
from pynicotine.events import events
from pynicotine.logfacility import log
from pynicotine.shares import PermissionLevel
from pynicotine.slskmessages import UserStatus
from pynicotine.utils import open_uri

GTK_API_VERSION = Gtk.get_major_version()
GTK_MINOR_VERSION = Gtk.get_minor_version()
GTK_MICRO_VERSION = Gtk.get_micro_version()
GTK_GUI_FOLDER_PATH = os.path.normpath(os.path.dirname(os.path.realpath(__file__)))
LIBADWAITA_API_VERSION = 0

if GTK_API_VERSION >= 4:
    try:
        if "NICOTINE_LIBADWAITA" not in os.environ:
            # Only attempt to use libadwaita in a standard GNOME session or Ubuntu's
            # GNOME session (identified as 'GNOME' and 'ubuntu:GNOME'). Filter out
            # other desktop environments that specify GNOME as a fallback, such as
            # Budgie (identified as 'Budgie:GNOME').
            current_desktop = os.environ.get("XDG_CURRENT_DESKTOP", "").lower()

            os.environ["NICOTINE_LIBADWAITA"] = str(int(
                sys.platform in {"win32", "darwin"}
                or current_desktop == "gnome"
                or ("ubuntu" in current_desktop and "gnome" in current_desktop)
            ))

        if os.environ.get("NICOTINE_LIBADWAITA") == "1":
            gi.require_version("Adw", "1")

            from gi.repository import Adw  # pylint: disable=ungrouped-imports
            LIBADWAITA_API_VERSION = Adw.MAJOR_VERSION

    except (ImportError, ValueError):
        pass


class Application:

    def __init__(self, start_hidden, ci_mode, isolated_mode, multi_instance):

        self._instance = Gtk.Application(application_id=pynicotine.__application_id__)
        GLib.set_application_name(pynicotine.__application_name__)
        GLib.set_prgname(pynicotine.__application_id__)

        if multi_instance:
            self._instance.set_flags(Gio.ApplicationFlags.NON_UNIQUE)

        self.start_hidden = start_hidden
        self.ci_mode = ci_mode
        self.isolated_mode = isolated_mode

        self.window = None
        self.about = None
        self.fast_configure = None
        self.preferences = None
        self.chat_history = None
        self.room_list = None
        self.file_properties = None
        self.shortcuts = None
        self.statistics = None
        self.wishlist = None
        self.tray_icon = None
        self.spell_checker = None

        # Show errors in the GUI from here on
        sys.excepthook = self.on_critical_error

        # Always use LTR text direction for now. Once we add complete translations for a RTL
        # language, we need to revise this.
        Gtk.Widget.set_default_direction(Gtk.TextDirection.LTR)

        self._instance.connect("activate", self.on_activate)
        self._instance.connect("shutdown", self.on_shutdown)

        for event_name, callback in (
            ("confirm-quit", self.on_confirm_quit),
            ("invalid-password", self.on_invalid_password),
            ("invalid-username", self.on_invalid_password),
            ("quit", self._instance.quit),
            ("server-login", self._update_user_status),
            ("server-disconnect", self._update_user_status),
            ("setup", self.on_fast_configure),
            ("shares-unavailable", self.on_shares_unavailable),
            ("show-notification", self._show_notification),
            ("show-chatroom-notification", self._show_chatroom_notification),
            ("show-download-notification", self._show_download_notification),
            ("show-private-chat-notification", self._show_private_chat_notification),
            ("show-search-notification", self._show_search_notification),
            ("show-upload-notification", self._show_upload_notification),
            ("user-status", self.on_user_status)
        ):
            events.connect(event_name, callback)

    def run(self):
        return self._instance.run()

    def add_action(self, action):
        self._instance.add_action(action)

    def lookup_action(self, action_name):
        return self._instance.lookup_action(action_name)

    def remove_action(self, action):
        self._instance.remove_action(action)

    def add_window(self, window):
        self._instance.add_window(window)

    def _set_up_actions(self):

        # Regular actions

        for action_name, callback, parameter_type, is_enabled in (
            # General
            ("disabled", None, None, False),
            ("connect", self.on_connect, None, True),
            ("disconnect", self.on_disconnect, None, False),
            ("soulseek-privileges", self.on_soulseek_privileges, None, False),
            ("away", self.on_away, None, True),
            ("away-accel", self.on_away_accelerator, None, False),
            ("chat-history", self.on_chat_history, None, True),
            ("room-list", self.on_room_list, None, True),
            ("message-downloading-users", self.on_message_downloading_users, None, False),
            ("message-buddies", self.on_message_buddies, None, False),
            ("wishlist", self.on_wishlist, None, True),
            ("confirm-quit", self.on_confirm_quit_request, None, True),
            ("force-quit", self.on_force_quit_request, None, True),
            ("quit", self.on_quit_request, None, True),

            # Shares
            ("rescan-shares", self.on_rescan_shares, None, True),
            ("browse-public-shares", self.on_browse_public_shares, None, True),
            ("browse-buddy-shares", self.on_browse_buddy_shares, None, True),
            ("browse-trusted-shares", self.on_browse_trusted_shares, None, True),
            ("load-shares-from-disk", self.on_load_shares_from_disk, None, True),

            # Configuration
            ("preferences", self.on_preferences, None, True),
            ("configure-shares", self.on_configure_shares, None, True),
            ("configure-downloads", self.on_configure_downloads, None, True),
            ("configure-uploads", self.on_configure_uploads, None, True),
            ("configure-chats", self.on_configure_chats, None, True),
            ("configure-searches", self.on_configure_searches, None, True),
            ("configure-ignored-users", self.on_configure_ignored_users, None, True),
            ("configure-account", self.on_configure_account, None, True),
            ("configure-user-profile", self.on_configure_user_profile, None, True),
            ("personal-profile", self.on_personal_profile, None, True),

            # Notifications
            ("chatroom-notification-activated", self.on_chatroom_notification_activated, "s", True),
            ("download-notification-activated", self.on_downloads, None, True),
            ("private-chat-notification-activated", self.on_private_chat_notification_activated, "s", True),
            ("search-notification-activated", self.on_search_notification_activated, "s", True),
            ("upload-notification-activated", self.on_uploads, None, True),

            # Help
            ("keyboard-shortcuts", self.on_keyboard_shortcuts, None, True),
            ("setup-assistant", self.on_fast_configure, None, True),
            ("transfer-statistics", self.on_transfer_statistics, None, True),
            ("report-bug", self.on_report_bug, None, True),
            ("improve-translations", self.on_improve_translations, None, True),
            ("about", self.on_about, None, True)
        ):
            if parameter_type:
                parameter_type = GLib.VariantType(parameter_type)

            action = Gio.SimpleAction(name=action_name, parameter_type=parameter_type, enabled=is_enabled)

            if callback:
                action.connect("activate", callback)

            self.add_action(action)

        self.lookup_action("away-accel").cooldown_time = 0  # needed to prevent server ban

        # Stateful actions

        enabled_logs = config.sections["logging"]["debugmodes"]

        for action_name, callback, state in (
            # Logging
            ("log-downloads", self.on_debug_downloads, ("download" in enabled_logs)),
            ("log-uploads", self.on_debug_uploads, ("upload" in enabled_logs)),
            ("log-searches", self.on_debug_searches, ("search" in enabled_logs)),
            ("log-chat", self.on_debug_chat, ("chat" in enabled_logs)),
            ("log-connections", self.on_debug_connections, ("connection" in enabled_logs)),
            ("log-messages", self.on_debug_messages, ("message" in enabled_logs)),
            ("log-transfers", self.on_debug_transfers, ("transfer" in enabled_logs)),
            ("log-miscellaneous", self.on_debug_miscellaneous, ("miscellaneous" in enabled_logs))
        ):
            action = Gio.SimpleAction(name=action_name, state=GLib.Variant.new_boolean(state))
            action.connect("change-state", callback)
            self.add_action(action)

    def _set_accels_for_action(self, action, accels):

        if GTK_API_VERSION >= 4 and sys.platform == "darwin":
            # Use Command key instead of Ctrl in accelerators on macOS
            for i, accelerator in enumerate(accels):
                accels[i] = accelerator.replace("<Primary>", "<Meta>")

        self._instance.set_accels_for_action(action, accels)

    def _set_up_action_accels(self):

        for action_name, accelerators in (
            # Global accelerators
            ("app.connect", ["<Shift><Primary>c"]),
            ("app.disconnect", ["<Shift><Primary>d"]),
            ("app.away-accel", ["<Shift><Primary>a"]),
            ("app.wishlist", ["<Shift><Primary>w"]),
            ("app.confirm-quit", ["<Primary>q"]),
            ("app.force-quit", ["<Primary><Alt>q"]),
            ("app.quit", ["<Primary>q"]),  # Only used to show accelerator in menus
            ("app.rescan-shares", ["<Shift><Primary>r"]),
            ("app.keyboard-shortcuts", ["<Primary>question", "F1"]),
            ("app.preferences", ["<Primary>comma", "<Primary>p"]),

            # Window accelerators
            ("win.main-menu", ["F10"]),
            ("win.context-menu", ["<Shift>F10"]),
            ("win.change-focus-view", ["F6"]),
            ("win.show-log-pane", ["<Primary>l"]),
            ("win.reopen-closed-tab", ["<Primary><Shift>t"]),
            ("win.close-tab", ["<Primary>F4", "<Primary>w"]),
            ("win.cycle-tabs", ["<Control>Tab", "<Control>Page_Down"]),
            ("win.cycle-tabs-reverse", ["<Control><Shift>Tab", "<Control>Page_Up"]),

            # Other accelerators (logic defined elsewhere, actions only used for shortcuts dialog)
            ("accel.cut-clipboard", ["<Primary>x"]),
            ("accel.copy-clipboard", ["<Primary>c"]),
            ("accel.paste-clipboard", ["<Primary>v"]),
            ("accel.insert-emoji", ["<Control>period"]),
            ("accel.select-all", ["<Primary>a"]),
            ("accel.find", ["<Primary>f"]),
            ("accel.find-next-match", ["<Primary>g"]),
            ("accel.find-previous-match", ["<Shift><Primary>g"]),
            ("accel.refresh", ["<Primary>r", "F5"]),
            ("accel.remove", ["Delete"]),
            ("accel.toggle-row-expand", ["<Primary>backslash"]),
            ("accel.save", ["<Primary>s"]),
            ("accel.download-to", ["<Primary>Return"]),
            ("accel.file-properties", ["<Alt>Return"]),
            ("accel.back", ["BackSpace"]),
            ("accel.retry-transfer", ["r"]),
            ("accel.abort-transfer", ["t"])
        ):
            self._set_accels_for_action(action_name, accelerators)

        numpad_accels = []

        for num in range(1, 10):
            numpad_accels.append(f"<Alt>KP_{num}")
            self._set_accels_for_action(f"win.primary-tab-{num}", [f"<Primary>{num}", f"<Alt>{num}"])

        # Disable Alt+1-9 accelerators for numpad keys to avoid conflict with Alt codes
        self._set_accels_for_action("app.disabled", numpad_accels)

    def _update_user_status(self, *_args):

        status = core.users.login_status
        is_online = (status != UserStatus.OFFLINE)

        self.lookup_action("connect").set_enabled(not is_online)

        for action_name in ("disconnect", "soulseek-privileges", "away-accel",
                            "message-downloading-users", "message-buddies"):
            self.lookup_action(action_name).set_enabled(is_online)

        self.tray_icon.update()

    # Primary Menus #

    @staticmethod
    def _add_connection_section(menu):

        menu.add_items(
            ("=" + _("_Connect"), "app.connect"),
            ("=" + _("_Disconnect"), "app.disconnect"),
            ("#" + _("Soulseek _Privileges"), "app.soulseek-privileges"),
            ("", None)
        )

    @staticmethod
    def _add_preferences_item(menu):
        menu.add_items(("^" + _("_Preferences"), "app.preferences"))

    def _add_quit_item(self, menu):

        menu.add_items(
            ("", None),
            ("^" + _("_Quit"), "app.quit")
        )

    def _create_file_menu(self):

        from pynicotine.gtkgui.widgets.popupmenu import PopupMenu

        menu = PopupMenu(self)
        self._add_connection_section(menu)
        self._add_preferences_item(menu)
        self._add_quit_item(menu)

        return menu

    def _add_browse_shares_section(self, menu):

        menu.add_items(
            ("#" + _("Browse _Public Shares"), "app.browse-public-shares"),
            ("#" + _("Browse _Buddy Shares"), "app.browse-buddy-shares"),
            ("#" + _("Browse _Trusted Shares"), "app.browse-trusted-shares")
        )

    def _create_shares_menu(self):

        from pynicotine.gtkgui.widgets.popupmenu import PopupMenu

        menu = PopupMenu(self)
        menu.add_items(
            ("#" + _("_Rescan Shares"), "app.rescan-shares"),
            ("#" + _("Configure _Shares"), "app.configure-shares"),
            ("", None)
        )
        self._add_browse_shares_section(menu)

        return menu

    def _create_browse_shares_menu(self):

        from pynicotine.gtkgui.widgets.popupmenu import PopupMenu

        menu = PopupMenu(self)
        self._add_browse_shares_section(menu)

        return menu

    def _create_help_menu(self):

        from pynicotine.gtkgui.widgets.popupmenu import PopupMenu

        menu = PopupMenu(self)
        menu.add_items(
            ("#" + _("_Keyboard Shortcuts"), "app.keyboard-shortcuts"),
            ("#" + _("_Setup Assistant"), "app.setup-assistant"),
            ("#" + _("_Transfer Statistics"), "app.transfer-statistics"),
            ("", None)
        )
        if not self.isolated_mode:
            menu.add_items(
                ("#" + _("Report a _Bug"), "app.report-bug"),
                ("#" + _("Improve T_ranslations"), "app.improve-translations"),
                ("", None)
            )
        menu.add_items(
            ("^" + _("_About Nicotine+"), "app.about")
        )

        return menu

    def _set_up_menubar(self):

        from pynicotine.gtkgui.widgets.popupmenu import PopupMenu

        menu = PopupMenu(self)
        menu.add_items(
            (">" + _("_File"), self._create_file_menu()),
            (">" + _("_Shares"), self._create_shares_menu()),
            (">" + _("_Help"), self._create_help_menu())
        )

        menu.update_model()
        self._instance.set_menubar(menu.model)

    def create_hamburger_menu(self):

        from pynicotine.gtkgui.widgets.popupmenu import PopupMenu

        menu = PopupMenu(self)
        self._add_connection_section(menu)
        menu.add_items(
            ("#" + _("_Rescan Shares"), "app.rescan-shares"),
            (">" + _("_Browse Shares"), self._create_browse_shares_menu()),
            ("#" + _("Configure _Shares"), "app.configure-shares"),
            ("", None),
            (">" + _("_Help"), self._create_help_menu())
        )
        self._add_preferences_item(menu)
        self._add_quit_item(menu)

        menu.update_model()
        return menu

    # Notifications #

    def _show_notification(self, message, title=None, action=None, action_target=None, high_priority=False):

        if title is None:
            title = pynicotine.__application_name__

        title = title.strip()
        message = message.strip()

        try:
            if sys.platform == "win32":
                self.tray_icon.show_notification(
                    title=title, message=message, action=action, action_target=action_target,
                    high_priority=high_priority
                )
                return

            priority = Gio.NotificationPriority.HIGH if high_priority else Gio.NotificationPriority.NORMAL

            notification = Gio.Notification.new(title)
            notification.set_body(message)
            notification.set_priority(priority)

            # Fix notification icon in Snap package
            snap_name = os.environ.get("SNAP_NAME")

            if snap_name:
                notification.set_icon(Gio.ThemedIcon(name=f"snap.{snap_name}.{pynicotine.__application_id__}"))

            # Unity doesn't support default click actions, and replaces the notification with a dialog.
            # Disable actions to prevent this from happening.
            if action and os.environ.get("XDG_CURRENT_DESKTOP", "").lower() != "unity":
                if action_target:
                    notification.set_default_action_and_target(action, GLib.Variant.new_string(action_target))
                else:
                    notification.set_default_action(action)

            self._instance.send_notification(id=None, notification=notification)

            if config.sections["notifications"]["notification_popup_sound"]:
                Gdk.Display.get_default().beep()

        except Exception as error:
            log.add(_("Unable to show notification: %s"), error)

    def _show_chatroom_notification(self, room, message, title=None, high_priority=False):

        self._show_notification(
            message, title, action="app.chatroom-notification-activated", action_target=room,
            high_priority=high_priority
        )

        if high_priority:
            self.window.set_urgency_hint(True)

    def _show_download_notification(self, message, title=None, high_priority=False):

        self._show_notification(
            message, title, action="app.download-notification-activated",
            high_priority=high_priority
        )

    def _show_private_chat_notification(self, user, message, title=None):

        self._show_notification(
            message, title, action="app.private-chat-notification-activated", action_target=user,
            high_priority=True
        )
        self.window.set_urgency_hint(True)

    def _show_search_notification(self, search_token, message, title=None):

        self._show_notification(
            message, title, action="app.search-notification-activated", action_target=search_token,
            high_priority=True
        )

    def _show_upload_notification(self, message, title=None):

        self._show_notification(
            message, title, action="app.upload-notification-activated"
        )

    # Core Events #

    def on_confirm_quit_response(self, dialog, response_id, _data):

        should_finish_uploads = dialog.get_option_value()

        if response_id == "quit":
            if should_finish_uploads:
                core.uploads.request_shutdown()
            else:
                core.quit()

        elif response_id == "run_background":
            self.window.hide()

    def on_confirm_quit(self):

        has_active_uploads = core.uploads.has_active_uploads()

        if not self.window.is_visible():
            # Never show confirmation dialog when main window is hidden
            core.quit()
            return

        from pynicotine.gtkgui.widgets.dialogs import OptionDialog

        if has_active_uploads:
            message = _("You are still uploading files. Do you really want to exit?")
            option_label = _("Wait for uploads to finish")
        else:
            message = _("Do you really want to exit?")
            option_label = None

        buttons = [
            ("cancel", _("_No")),
            ("quit", _("_Quit")),
            ("run_background", _("_Run in Background"))
        ]

        OptionDialog(
            parent=self.window,
            title=_("Quit Nicotine+"),
            message=message,
            buttons=buttons,
            option_label=option_label,
            callback=self.on_confirm_quit_response
        ).present()

    def on_shares_unavailable_response(self, _dialog, response_id, _data):
        core.shares.rescan_shares(force=(response_id == "force_rescan"))

    def on_shares_unavailable(self, shares):

        from pynicotine.gtkgui.widgets.dialogs import OptionDialog

        shares_list_message = ""

        for virtual_name, folder_path in shares:
            shares_list_message += f'• "{virtual_name}" {folder_path}\n'

        OptionDialog(
            parent=self.window,
            title=_("Shares Not Available"),
            message=_("Verify that external disks are mounted and folder permissions are correct."),
            long_message=shares_list_message,
            buttons=[
                ("cancel", _("_Cancel")),
                ("ok", _("_Retry")),
                ("force_rescan", _("_Force Rescan"))
            ],
            destructive_response_id="force_rescan",
            callback=self.on_shares_unavailable_response
        ).present()

    def on_invalid_password(self, *_args):
        self.on_fast_configure(invalid_password=True)

    def on_user_status(self, msg):
        if msg.user == core.users.login_username:
            self._update_user_status()

    # Actions #

    def on_connect(self, *_args):
        if core.users.login_status == UserStatus.OFFLINE:
            core.connect()

    def on_disconnect(self, *_args):
        if core.users.login_status != UserStatus.OFFLINE:
            core.disconnect()

    def on_soulseek_privileges(self, *_args):
        core.users.request_check_privileges(should_open_url=True)

    def on_preferences(self, *_args, page_id="network"):

        if self.preferences is None:
            from pynicotine.gtkgui.dialogs.preferences import Preferences
            self.preferences = Preferences(self)

        self.preferences.set_settings()
        self.preferences.set_active_page(page_id)
        self.preferences.present()

    def on_set_debug_level(self, action, state, level):

        if state.get_boolean():
            log.add_log_level(level)
        else:
            log.remove_log_level(level)

        action.set_state(state)

    def on_debug_downloads(self, action, state):
        self.on_set_debug_level(action, state, "download")

    def on_debug_uploads(self, action, state):
        self.on_set_debug_level(action, state, "upload")

    def on_debug_searches(self, action, state):
        self.on_set_debug_level(action, state, "search")

    def on_debug_chat(self, action, state):
        self.on_set_debug_level(action, state, "chat")

    def on_debug_connections(self, action, state):
        self.on_set_debug_level(action, state, "connection")

    def on_debug_messages(self, action, state):
        self.on_set_debug_level(action, state, "message")

    def on_debug_transfers(self, action, state):
        self.on_set_debug_level(action, state, "transfer")

    def on_debug_miscellaneous(self, action, state):
        self.on_set_debug_level(action, state, "miscellaneous")

    def on_fast_configure(self, *_args, invalid_password=False):

        if self.fast_configure is None:
            from pynicotine.gtkgui.dialogs.fastconfigure import FastConfigure
            self.fast_configure = FastConfigure(self)

        if invalid_password and self.fast_configure.is_visible():
            self.fast_configure.hide()

        self.fast_configure.invalid_password = invalid_password
        self.fast_configure.present()

    def on_keyboard_shortcuts(self, *_args):

        if self.shortcuts is None:
            from pynicotine.gtkgui.dialogs.shortcuts import Shortcuts
            self.shortcuts = Shortcuts(self)

        self.shortcuts.present()

    def on_chat_history(self, *_args):
        self.chat_history.present()

    def on_room_list(self, *_args):
        self.room_list.present()

    def on_transfer_statistics(self, *_args):

        if self.statistics is None:
            from pynicotine.gtkgui.dialogs.statistics import Statistics
            self.statistics = Statistics(self)

        self.statistics.present()

    @staticmethod
    def on_report_bug(*_args):
        open_uri(pynicotine.__issue_tracker_url__)

    @staticmethod
    def on_improve_translations(*_args):
        open_uri(pynicotine.__translations_url__)

    def on_wishlist(self, *_args):

        if self.wishlist is None:
            from pynicotine.gtkgui.dialogs.wishlist import WishList
            self.wishlist = WishList(self)

        self.wishlist.present()

    def on_about(self, *_args):

        if self.about is None:
            from pynicotine.gtkgui.dialogs.about import About
            self.about = About(self)

        self.about.present()

    def on_chatroom_notification_activated(self, _action, room_variant):

        room = room_variant.get_string()
        core.chatrooms.show_room(room)

        self.window.present()

    def on_private_chat_notification_activated(self, _action, user_variant):

        user = user_variant.get_string()
        core.privatechat.show_user(user)

        self.window.present()

    def on_search_notification_activated(self, _action, search_token_variant):

        search_token = int(search_token_variant.get_string())
        core.search.show_search(search_token)

        self.window.present()

    def on_downloads(self, *_args):
        self.window.change_main_page(self.window.downloads_page)
        self.window.present()

    def on_uploads(self, *_args):
        self.window.change_main_page(self.window.uploads_page)
        self.window.present()

    def on_private_chat(self, *_args):
        self.window.change_main_page(self.window.private_page)
        self.window.present()

    def on_chat_rooms(self, *_args):
        self.window.change_main_page(self.window.chatrooms_page)
        self.window.present()

    def on_searches(self, *_args):
        self.window.change_main_page(self.window.search_page)
        self.window.present()

    def on_message_users_response(self, dialog, _response_id, target):

        message = dialog.get_entry_value()

        if message:
            core.privatechat.send_message_users(target, message)

    def on_message_downloading_users(self, *_args):

        from pynicotine.gtkgui.widgets.dialogs import EntryDialog

        EntryDialog(
            parent=self.window,
            title=_("Message Downloading Users"),
            message=_("Send private message to all users who are downloading from you:"),
            action_button_label=_("_Send Message"),
            callback=self.on_message_users_response,
            callback_data="downloading",
            show_emoji_icon=True
        ).present()

    def on_message_buddies(self, *_args):

        from pynicotine.gtkgui.widgets.dialogs import EntryDialog

        EntryDialog(
            parent=self.window,
            title=_("Message Buddies"),
            message=_("Send private message to all online buddies:"),
            action_button_label=_("_Send Message"),
            callback=self.on_message_users_response,
            callback_data="buddies",
            show_emoji_icon=True
        ).present()

    def on_rescan_shares(self, *_args):
        core.shares.rescan_shares()

    def on_browse_public_shares(self, *_args):
        core.userbrowse.browse_local_shares(permission_level=PermissionLevel.PUBLIC, new_request=True)

    def on_browse_buddy_shares(self, *_args):
        core.userbrowse.browse_local_shares(permission_level=PermissionLevel.BUDDY, new_request=True)

    def on_browse_trusted_shares(self, *_args):
        core.userbrowse.browse_local_shares(permission_level=PermissionLevel.TRUSTED, new_request=True)

    def on_load_shares_from_disk_selected(self, selected_file_paths, _data):
        for file_path in selected_file_paths:
            core.userbrowse.load_shares_list_from_disk(file_path)

    def on_load_shares_from_disk(self, *_args):

        from pynicotine.gtkgui.widgets.filechooser import FileChooser

        FileChooser(
            parent=self.window,
            title=_("Select a Saved Shares List File"),
            callback=self.on_load_shares_from_disk_selected,
            initial_folder=core.userbrowse.create_user_shares_folder(),
            select_multiple=True
        ).present()

    def on_personal_profile(self, *_args):
        core.userinfo.show_user()

    def on_configure_shares(self, *_args):
        self.on_preferences(page_id="shares")

    def on_configure_searches(self, *_args):
        self.on_preferences(page_id="searches")

    def on_configure_chats(self, *_args):
        self.on_preferences(page_id="chats")

    def on_configure_downloads(self, *_args):
        self.on_preferences(page_id="downloads")

    def on_configure_uploads(self, *_args):
        self.on_preferences(page_id="uploads")

    def on_configure_ignored_users(self, *_args):
        self.on_preferences(page_id="ignored-users")

    def on_configure_account(self, *_args):
        self.on_preferences(page_id="network")

    def on_configure_user_profile(self, *_args):
        self.on_preferences(page_id="user-profile")

    def on_window_hide_unhide(self, *_args):

        if self.window.is_visible():
            self.window.hide()
            return

        self.window.present()

        # Workaround for broken window size when restoring maximized window from tray icon
        if sys.platform == "win32" and self.window.is_maximized():
            self.window.unmaximize()
            self.window.maximize()

    def on_away_accelerator(self, action, *_args):
        """Ctrl+H: Away/Online toggle."""

        current_time = time.monotonic()

        if (current_time - action.cooldown_time) >= 1:
            # Prevent rapid key-repeat toggling to avoid server ban
            self.on_away()
            action.cooldown_time = current_time

    def on_away(self, *_args):
        """Away/Online status button."""

        if core.users.login_status == UserStatus.OFFLINE:
            core.connect()
            return

        core.users.set_away_mode(core.users.login_status != UserStatus.AWAY, save_state=True)

    # Running #

    def _raise_exception(self, exc_value):
        raise exc_value

    def _show_critical_error_dialog_response(self, _dialog, response_id, data):

        loop, error = data

        if response_id == "copy_report_bug":
            from pynicotine.gtkgui.widgets import clipboard

            clipboard.copy_text(error)
            open_uri(pynicotine.__issue_tracker_url__)

            self._show_critical_error_dialog(error, loop)
            return

        loop.quit()

    def _show_critical_error_dialog(self, error, loop):

        from pynicotine.gtkgui.widgets.dialogs import OptionDialog

        OptionDialog(
            parent=self.window,
            title=_("Critical Error"),
            message=_("Nicotine+ has encountered a critical error and needs to exit. "
                      "Please copy the following message and include it in a bug report:"),
            long_message=error,
            buttons=[
                ("quit", _("_Quit Nicotine+")),
                ("copy_report_bug", _("_Copy & Report Bug"))
            ],
            callback=self._show_critical_error_dialog_response,
            callback_data=(loop, error)
        ).present()

    def _on_critical_error(self, exc_type, exc_value, exc_traceback):

        if self.ci_mode:
            core.quit()
            self._raise_exception(exc_value)
            return

        from traceback import format_tb

        # Check if exception occurred in a plugin
        if exc_traceback is not None:
            traceback = exc_traceback

            while traceback.tb_next:
                file_path = traceback.tb_frame.f_code.co_filename

                for plugin_name in core.pluginhandler.enabled_plugins:
                    plugin_path = core.pluginhandler.get_plugin_path(plugin_name)

                    if file_path.startswith(plugin_path):
                        core.pluginhandler.show_plugin_error(plugin_name, exc_value)
                        return

                traceback = traceback.tb_next

        # Show critical error dialog
        loop = GLib.MainLoop()
        gtk_version = f"{Gtk.get_major_version()}.{Gtk.get_minor_version()}.{Gtk.get_micro_version()}"
        error = (f"Nicotine+ Version: {pynicotine.__version__}\nGTK Version: {gtk_version}\n"
                 f"Python Version: {sys.version.split()[0]} ({sys.platform})\n\n"
                 f"Type: {exc_type}\nValue: {exc_value}\nTraceback: {''.join(format_tb(exc_traceback))}")
        self._show_critical_error_dialog(error, loop)

        # Keep dialog open if error occurs on startup
        loop.run()

        # Dialog was closed, quit
        sys.excepthook = None
        core.quit()

        # Process 'quit' event after slight delay in case thread event loop is stuck
        GLib.idle_add(lambda: events.process_thread_events() == -1, priority=GLib.PRIORITY_HIGH_IDLE)

        # Log exception in terminal
        self._raise_exception(exc_value)

    def on_critical_error(self, exc_type, exc_value, exc_traceback):

        if threading.current_thread() is threading.main_thread():
            self._on_critical_error(exc_type, exc_value, exc_traceback)
            return

        # Raise exception in the main thread
        GLib.idle_add(self._raise_exception, exc_value, priority=GLib.PRIORITY_HIGH_IDLE)

    def on_process_thread_events(self):
        return events.process_thread_events()

    def on_activate(self, *_args):

        if self.window:
            # Show the window of the running application instance
            self.window.present()
            return

        from pynicotine.gtkgui.dialogs.chathistory import ChatHistory
        from pynicotine.gtkgui.dialogs.roomlist import RoomList
        from pynicotine.gtkgui.mainwindow import MainWindow
        from pynicotine.gtkgui.widgets.theme import load_icons
        from pynicotine.gtkgui.widgets.trayicon import TrayIcon

        # Process thread events 10 times per second.
        # High priority to ensure there are no delays.
        GLib.timeout_add(100, self.on_process_thread_events, priority=GLib.PRIORITY_HIGH_IDLE)

        load_icons()

        self._set_up_actions()
        self._set_up_action_accels()
        self._set_up_menubar()

        self.tray_icon = TrayIcon(self)
        self.window = MainWindow(self)
        self.chat_history = ChatHistory(self)
        self.room_list = RoomList(self)

        core.start()

        gtk_version = f"{Gtk.get_major_version()}.{Gtk.get_minor_version()}.{Gtk.get_micro_version()}"
        log.add(_("Loaded %(program)s %(version)s"), {"program": "GTK", "version": gtk_version})

        if config.sections["server"]["auto_connect_startup"]:
            core.connect()

        # Check command line option and config option
        start_hidden = (self.start_hidden or (self.tray_icon.available
                                              and config.sections["ui"]["trayicon"]
                                              and config.sections["ui"]["startup_hidden"]))

        if not start_hidden:
            self.window.present()

    def on_confirm_quit_request(self, *_args):
        core.confirm_quit()

    def on_force_quit_request(self, *_args):
        core.quit()

    def on_quit_request(self, *_args):

        if not core.uploads.has_active_uploads():
            core.quit()
            return

        core.confirm_quit()

    def on_shutdown(self, *_args):

        if self.about is not None:
            self.about.destroy()

        if self.fast_configure is not None:
            self.fast_configure.destroy()

        if self.preferences is not None:
            self.preferences.destroy()

        if self.chat_history is not None:
            self.chat_history.destroy()

        if self.room_list is not None:
            self.room_list.destroy()

        if self.file_properties is not None:
            self.file_properties.destroy()

        if self.shortcuts is not None:
            self.shortcuts.destroy()

        if self.statistics is not None:
            self.statistics.destroy()

        if self.wishlist is not None:
            self.wishlist.destroy()

        if self.spell_checker is not None:
            self.spell_checker.destroy()

        if self.window is not None:
            self.window.destroy()

        if self.tray_icon is not None:
            self.tray_icon.destroy()

        self.__dict__.clear()


===== buddies.py =====
# SPDX-FileCopyrightText: 2020-2025 Nicotine+ Contributors
# SPDX-FileCopyrightText: 2018 Mutnick <mutnick@techie.com>
# SPDX-FileCopyrightText: 2016-2017 Michael Labouebe <gfarmerfr@free.fr>
# SPDX-FileCopyrightText: 2009 quinox <quinox@users.sf.net>
# SPDX-FileCopyrightText: 2006-2009 daelstorm <daelstorm@gmail.com>
# SPDX-FileCopyrightText: 2003-2004 Hyriand <hyriand@thegraveyard.org>
# SPDX-License-Identifier: GPL-3.0-or-later

import time

from gi.repository import GObject

from pynicotine.config import config
from pynicotine.core import core
from pynicotine.events import events
from pynicotine.gtkgui.application import GTK_API_VERSION
from pynicotine.gtkgui.widgets import ui
from pynicotine.gtkgui.widgets.dialogs import EntryDialog
from pynicotine.gtkgui.widgets.popupmenu import UserPopupMenu
from pynicotine.gtkgui.widgets.theme import USER_STATUS_ICON_NAMES
from pynicotine.gtkgui.widgets.theme import get_flag_icon_name
from pynicotine.gtkgui.widgets.treeview import TreeView
from pynicotine.slskmessages import UserStatus
from pynicotine.utils import UINT64_LIMIT
from pynicotine.utils import humanize
from pynicotine.utils import human_speed


class Buddies:

    def __init__(self, window):

        (
            self.container,
            self.list_container,
            self.side_toolbar
        ) = ui.load(scope=self, path="buddies.ui")

        self.window = window
        self.page = window.userlist_page
        self.page.id = "userlist"
        self.toolbar = window.userlist_toolbar
        self.toolbar_start_content = window.userlist_title
        self.toolbar_end_content = window.userlist_end
        self.toolbar_default_widget = window.add_buddy_entry

        # Columns
        self.list_view = TreeView(
            window, parent=self.list_container, name="buddy_list",
            persistent_sort=True, activate_row_callback=self.on_row_activated,
            delete_accelerator_callback=self.on_remove_buddy,
            columns={
                # Visible columns
                "status": {
                    "column_type": "icon",
                    "title": _("Status"),
                    "width": 25,
                    "hide_header": True
                },
                "country": {
                    "column_type": "icon",
                    "title": _("Country"),
                    "width": 30,
                    "hide_header": True
                },
                "user": {
                    "column_type": "text",
                    "title": _("User"),
                    "width": 250,
                    "default_sort_type": "ascending",
                    "iterator_key": True
                },
                "speed": {
                    "column_type": "number",
                    "title": _("Speed"),
                    "width": 150,
                    "sort_column": "speed_data"
                },
                "files": {
                    "column_type": "number",
                    "title": _("Files"),
                    "width": 150,
                    "sort_column": "files_data"
                },
                "trusted": {
                    "column_type": "toggle",
                    "title": _("Trusted"),
                    "width": 0,
                    "toggle_callback": self.on_trusted
                },
                "notify": {
                    "column_type": "toggle",
                    "title": _("Notify"),
                    "width": 0,
                    "toggle_callback": self.on_notify
                },
                "privileged": {
                    "column_type": "toggle",
                    "title": _("Prioritized"),
                    "width": 0,
                    "toggle_callback": self.on_prioritized
                },
                "last_seen": {
                    "column_type": "text",
                    "title": _("Last Seen"),
                    "width": 225,
                    "sort_column": "last_seen_data"
                },
                "comments": {
                    "column_type": "text",
                    "title": _("Note"),
                    "width": 400
                },

                # Hidden data columns
                "speed_data": {"data_type": GObject.TYPE_UINT},
                "files_data": {"data_type": GObject.TYPE_UINT},
                "last_seen_data": {"data_type": GObject.TYPE_UINT64}
            }
        )

        # Popup menus
        self.popup_menu = popup = UserPopupMenu(
            window.application, parent=self.list_view.widget, callback=self.on_popup_menu,
            tab_name="userlist"
        )
        popup.add_items(
            ("#" + _("Add User _Note…"), self.on_add_note),
            ("", None),
            ("#" + _("Remove"), self.on_remove_buddy)
        )

        # Events
        for event_name, callback in (
            ("add-buddy", self.add_buddy),
            ("buddy-note", self.buddy_note),
            ("buddy-notify", self.buddy_notify),
            ("buddy-last-seen", self.buddy_last_seen),
            ("buddy-prioritized", self.buddy_prioritized),
            ("buddy-trusted", self.buddy_trusted),
            ("remove-buddy", self.remove_buddy),
            ("server-disconnect", self.server_disconnect),
            ("start", self.start),
            ("user-country", self.user_country),
            ("user-stats", self.user_stats),
            ("user-status", self.user_status)
        ):
            events.connect(event_name, callback)

        self.set_buddy_list_position()

    def start(self):

        comboboxes = (
            self.window.search.user_search_combobox,
            self.window.userbrowse.userbrowse_combobox,
            self.window.userinfo.userinfo_combobox
        )

        for combobox in comboboxes:
            combobox.freeze()

        self.list_view.freeze()

        for username, user_data in core.buddies.users.items():
            self.add_buddy(username, user_data, select_row=False)

        for combobox in comboboxes:
            combobox.unfreeze()

        self.list_view.unfreeze()

    def destroy(self):

        self.list_view.destroy()
        self.popup_menu.destroy()

        self.__dict__.clear()

    def on_focus(self, *_args):

        self.update_visible()

        if self.container.get_parent().get_visible():
            self.list_view.grab_focus()
            return True

        return False

    def set_buddy_list_position(self):

        parent_container = self.container.get_parent()
        mode = config.sections["ui"]["buddylistinchatrooms"]

        if mode not in {"tab", "chatrooms", "always"}:
            mode = "tab"

        if parent_container == self.window.buddy_list_container:
            if mode == "always":
                return

            self.window.buddy_list_container.remove(self.container)
            self.window.buddy_list_container.set_visible(False)

        elif parent_container == self.window.chatrooms_buddy_list_container:
            if mode == "chatrooms":
                return

            self.window.chatrooms_buddy_list_container.remove(self.container)
            self.window.chatrooms_buddy_list_container.set_visible(False)

        elif parent_container == self.window.userlist_content:
            if mode == "tab":
                return

            self.window.userlist_content.remove(self.container)

        if mode == "always":
            if GTK_API_VERSION >= 4:
                self.window.buddy_list_container.append(self.container)
            else:
                self.window.buddy_list_container.add(self.container)

            self.side_toolbar.set_visible(True)
            self.window.buddy_list_container.set_visible(True)
            return

        if mode == "chatrooms":
            if GTK_API_VERSION >= 4:
                self.window.chatrooms_buddy_list_container.append(self.container)
            else:
                self.window.chatrooms_buddy_list_container.add(self.container)

            self.side_toolbar.set_visible(True)
            self.window.chatrooms_buddy_list_container.set_visible(True)
            return

        if mode == "tab":
            self.side_toolbar.set_visible(False)

            if GTK_API_VERSION >= 4:
                self.window.userlist_content.append(self.container)
            else:
                self.window.userlist_content.add(self.container)

    def update_visible(self):

        if config.sections["ui"]["buddylistinchatrooms"] in {"always", "chatrooms"}:
            return

        self.window.userlist_content.set_visible(bool(self.list_view.iterators))

    def get_selected_username(self):

        for iterator in self.list_view.get_selected_rows():
            return self.list_view.get_row_value(iterator, "user")

        return None

    def on_row_activated(self, _list_view, _iterator, column_id):

        user = self.get_selected_username()

        if user is None:
            return

        if column_id == "comments":
            self.on_add_note()
            return

        core.privatechat.show_user(user)

    def on_popup_menu(self, menu, _widget):

        username = self.get_selected_username()
        menu.set_user(username)
        menu.toggle_user_items()

    def user_status(self, msg):

        iterator = self.list_view.iterators.get(msg.user)

        if iterator is None:
            return

        status = msg.status
        status_icon_name = USER_STATUS_ICON_NAMES.get(status)

        if status_icon_name and status_icon_name != self.list_view.get_row_value(iterator, "status"):
            self.list_view.set_row_value(iterator, "status", status_icon_name)

    def user_stats(self, msg):

        iterator = self.list_view.iterators.get(msg.user)

        if iterator is None:
            return

        speed = msg.avgspeed or 0
        num_files = msg.files or 0
        h_num_files = humanize(num_files)
        column_ids = []
        column_values = []

        if speed != self.list_view.get_row_value(iterator, "speed_data"):
            h_speed = human_speed(speed) if speed > 0 else ""

            column_ids.extend(("speed", "speed_data"))
            column_values.extend((h_speed, speed))

        if h_num_files != self.list_view.get_row_value(iterator, "files"):
            column_ids.extend(("files", "files_data"))
            column_values.extend((h_num_files, num_files))

        if column_ids:
            self.list_view.set_row_values(iterator, column_ids, column_values)

    def add_buddy(self, user, user_data, select_row=True):

        status = user_data.status
        country_code = user_data.country

        if country_code:
            country_code = country_code.replace("flag_", "")

        stats = core.users.watched.get(user)

        if stats is not None:
            speed = stats.upload_speed or 0
            files = stats.files
        else:
            speed = 0
            files = None

        h_speed = human_speed(speed) if speed > 0 else ""
        h_files = humanize(files) if files is not None else ""
        last_seen = UINT64_LIMIT
        h_last_seen = ""

        if user_data.last_seen:
            try:
                last_seen_time = time.strptime(user_data.last_seen, "%m/%d/%Y %H:%M:%S")
                last_seen = time.mktime(last_seen_time)
                h_last_seen = time.strftime("%x %X", last_seen_time)

            except ValueError:
                last_seen = 0
                h_last_seen = _("Never seen")

        self.list_view.add_row([
            USER_STATUS_ICON_NAMES.get(status, ""),
            get_flag_icon_name(country_code),
            str(user),
            h_speed,
            h_files,
            bool(user_data.is_trusted),
            bool(user_data.notify_status),
            bool(user_data.is_prioritized),
            str(h_last_seen),
            str(user_data.note),
            speed,
            files or 0,
            last_seen
        ], select_row=select_row)

        for combobox in (
            self.window.search.user_search_combobox,
            self.window.userbrowse.userbrowse_combobox,
            self.window.userinfo.userinfo_combobox
        ):
            combobox.append(str(user))

        self.update_visible()

    def remove_buddy(self, user):

        iterator = self.list_view.iterators.get(user)

        if iterator is None:
            return

        self.list_view.remove_row(iterator)
        self.update_visible()

        for combobox in (
            self.window.search.user_search_combobox,
            self.window.userbrowse.userbrowse_combobox,
            self.window.userinfo.userinfo_combobox
        ):
            combobox.remove_id(user)

    def buddy_note(self, user, note):

        iterator = self.list_view.iterators.get(user)

        if iterator is not None:
            self.list_view.set_row_value(iterator, "comments", note)

    def buddy_trusted(self, user, trusted):

        iterator = self.list_view.iterators.get(user)

        if iterator is not None:
            self.list_view.set_row_value(iterator, "trusted", trusted)

    def buddy_notify(self, user, notify):

        iterator = self.list_view.iterators.get(user)

        if iterator is not None:
            self.list_view.set_row_value(iterator, "notify", notify)

    def buddy_prioritized(self, user, prioritized):

        iterator = self.list_view.iterators.get(user)

        if iterator is not None:
            self.list_view.set_row_value(iterator, "privileged", prioritized)

    def buddy_last_seen(self, user, online):

        iterator = self.list_view.iterators.get(user)

        if iterator is None:
            return

        last_seen = UINT64_LIMIT
        h_last_seen = ""

        if not online:
            last_seen = time.time()
            h_last_seen = time.strftime("%x %X", time.localtime(last_seen))

        self.list_view.set_row_values(
            iterator,
            column_ids=["last_seen", "last_seen_data"],
            values=[h_last_seen, last_seen]
        )

    def user_country(self, user, country_code):

        iterator = self.list_view.iterators.get(user)

        if iterator is None:
            return

        flag_icon_name = get_flag_icon_name(country_code)

        if flag_icon_name and flag_icon_name != self.list_view.get_row_value(iterator, "country"):
            self.list_view.set_row_value(iterator, "country", flag_icon_name)

    def on_add_buddy(self, *_args):

        username = self.window.add_buddy_entry.get_text().strip()

        if not username:
            return

        self.window.add_buddy_entry.set_text("")
        core.buddies.add_buddy(username)
        self.list_view.grab_focus()

    def on_remove_buddy(self, *_args):
        core.buddies.remove_buddy(self.get_selected_username())

    def on_trusted(self, list_view, iterator):

        user = list_view.get_row_value(iterator, "user")
        value = list_view.get_row_value(iterator, "trusted")

        core.buddies.set_buddy_trusted(user, not value)

    def on_notify(self, list_view, iterator):

        user = list_view.get_row_value(iterator, "user")
        value = list_view.get_row_value(iterator, "notify")

        core.buddies.set_buddy_notify(user, not value)

    def on_prioritized(self, list_view, iterator):

        user = list_view.get_row_value(iterator, "user")
        value = list_view.get_row_value(iterator, "privileged")

        core.buddies.set_buddy_prioritized(user, not value)

    def on_add_note_response(self, dialog, _response_id, user):

        iterator = self.list_view.iterators.get(user)

        if iterator is None:
            return

        note = dialog.get_entry_value()

        if note is None:
            return

        core.buddies.set_buddy_note(user, note)

    def on_add_note(self, *_args):

        user = self.get_selected_username()
        iterator = self.list_view.iterators.get(user)

        if iterator is None:
            return

        note = self.list_view.get_row_value(iterator, "comments") or ""

        EntryDialog(
            parent=self.window,
            title=_("Add User Note"),
            message=_("Add a note about user %s:") % user,
            action_button_label=_("_Add"),
            callback=self.on_add_note_response,
            callback_data=user,
            default=note
        ).present()

    def server_disconnect(self, *_args):
        for iterator in self.list_view.iterators.values():
            self.list_view.set_row_value(iterator, "status", USER_STATUS_ICON_NAMES[UserStatus.OFFLINE])


===== chatrooms.py =====
# SPDX-FileCopyrightText: 2020-2025 Nicotine+ Contributors
# SPDX-FileCopyrightText: 2016-2017 Michael Labouebe <gfarmerfr@free.fr>
# SPDX-FileCopyrightText: 2016 Mutnick <muhing@yahoo.com>
# SPDX-FileCopyrightText: 2008-2011 quinox <quinox@users.sf.net>
# SPDX-FileCopyrightText: 2006-2009 daelstorm <daelstorm@gmail.com>
# SPDX-FileCopyrightText: 2007 gallows <g4ll0ws@gmail.com>
# SPDX-FileCopyrightText: 2003-2004 Hyriand <hyriand@thegraveyard.org>
# SPDX-License-Identifier: GPL-3.0-or-later

from itertools import chain

from gi.repository import GLib
from gi.repository import GObject
from gi.repository import Gtk
from gi.repository import Pango

from pynicotine.config import config
from pynicotine.core import core
from pynicotine.events import events
from pynicotine.gtkgui.application import GTK_API_VERSION
from pynicotine.gtkgui.popovers.chatcommandhelp import ChatCommandHelp
from pynicotine.gtkgui.popovers.roomwall import RoomWall
from pynicotine.gtkgui.widgets import ui
from pynicotine.gtkgui.widgets.combobox import ComboBox
from pynicotine.gtkgui.widgets.iconnotebook import IconNotebook
from pynicotine.gtkgui.widgets.dialogs import OptionDialog
from pynicotine.gtkgui.widgets.popupmenu import PopupMenu
from pynicotine.gtkgui.widgets.popupmenu import UserPopupMenu
from pynicotine.gtkgui.widgets.textentry import ChatEntry
from pynicotine.gtkgui.widgets.textentry import TextSearchBar
from pynicotine.gtkgui.widgets.textview import ChatView
from pynicotine.gtkgui.widgets.textview import TextView
from pynicotine.gtkgui.widgets.theme import USER_STATUS_ICON_NAMES
from pynicotine.gtkgui.widgets.theme import add_css_class
from pynicotine.gtkgui.widgets.theme import get_flag_icon_name
from pynicotine.gtkgui.widgets.treeview import TreeView
from pynicotine.logfacility import log
from pynicotine.slskmessages import UserData
from pynicotine.slskmessages import UserStatus
from pynicotine.utils import humanize
from pynicotine.utils import human_speed


class ChatRooms(IconNotebook):

    def __init__(self, window):

        super().__init__(
            window,
            parent=window.chatrooms_content,
            parent_page=window.chatrooms_page,
            switch_page_callback=self.on_switch_chat,
            reorder_page_callback=self.on_reordered_page
        )

        self.page = window.chatrooms_page
        self.page.id = "chatrooms"
        self.toolbar = window.chatrooms_toolbar
        self.toolbar_start_content = window.chatrooms_title
        self.toolbar_end_content = window.chatrooms_end
        self.toolbar_default_widget = window.chatrooms_entry

        self.chat_entry = ChatEntry(
            self.window.application, send_message_callback=core.chatrooms.send_message,
            command_callback=core.pluginhandler.trigger_chatroom_command_event,
            enable_spell_check=config.sections["ui"]["spellcheck"]
        )
        self.command_help = None
        self.room_wall = None
        self.highlighted_rooms = {}

        self.join_room_combobox = ComboBox(
            container=window.chatrooms_entry_container, has_entry=True, has_dropdown=False,
            entry=window.chatrooms_entry, visible=True
        )
        window.chatrooms_entry.set_max_length(core.chatrooms.ROOM_NAME_MAX_LENGTH)

        if GTK_API_VERSION >= 4:
            window.chatrooms_paned.set_resize_start_child(True)
        else:
            window.chatrooms_paned.child_set_property(window.chatrooms_container, "resize", True)

        for event_name, callback in (
            ("clear-room-messages", self.clear_room_messages),
            ("echo-room-message", self.echo_room_message),
            ("global-room-message", self.global_room_message),
            ("ignore-user", self.ignore_user),
            ("ignore-user-ip", self.ignore_user),
            ("join-room", self.join_room),
            ("leave-room", self.leave_room),
            ("peer-address", self.peer_address),
            ("private-room-add-operator", self.private_room_add_operator),
            ("private-room-add-user", self.private_room_add_user),
            ("private-room-remove-operator", self.private_room_remove_operator),
            ("private-room-remove-user", self.private_room_remove_user),
            ("quit", self.quit),
            ("remove-room", self.remove_room),
            ("room-completions", self.update_completions),
            ("room-list", self.room_list),
            ("say-chat-room", self.say_chat_room),
            ("server-disconnect", self.server_disconnect),
            ("show-room", self.show_room),
            ("start", self.start),
            ("unignore-user", self.unignore_user),
            ("unignore-user-ip", self.unignore_user),
            ("user-country", self.user_country),
            ("user-joined-room", self.user_joined_room),
            ("user-left-room", self.user_left_room),
            ("user-stats", self.user_stats),
            ("user-status", self.user_status)
        ):
            events.connect(event_name, callback)

        self.freeze()

    def start(self):
        self.unfreeze()

    def quit(self):
        self.freeze()

    def destroy(self):

        self.chat_entry.destroy()
        self.join_room_combobox.destroy()

        if self.command_help is not None:
            self.command_help.destroy()

        if self.room_wall is not None:
            self.room_wall.destroy()

        super().destroy()

    def on_focus(self, *_args):

        if self.window.current_page_id != self.window.chatrooms_page.id:
            return True

        if self.get_n_pages():
            return True

        if self.window.chatrooms_entry.is_sensitive():
            self.window.chatrooms_entry.grab_focus()
            return True

        return False

    def on_remove_all_pages(self, *_args):
        core.chatrooms.remove_all_rooms()

    def on_restore_removed_page(self, page_args):
        room, is_private = page_args
        core.chatrooms.show_room(room, is_private=is_private)

    def on_reordered_page(self, *_args):

        room_tab_order = {}

        # Find position of opened auto-joined rooms
        for room, room_page in self.pages.items():
            room_position = self.page_num(room_page.container)
            room_tab_order[room_position] = room

        config.sections["server"]["autojoin"] = [room for room_index, room in sorted(room_tab_order.items())]

    def on_switch_chat(self, _notebook, page, _page_num):

        if self.window.current_page_id != self.window.chatrooms_page.id:
            return

        for room, tab in self.pages.items():
            if tab.container != page:
                continue

            joined_room = core.chatrooms.joined_rooms.get(room)

            self.chat_entry.set_parent(room, tab.chat_entry_container, tab.chat_view)
            self.chat_entry.set_sensitive(joined_room is not None and joined_room.users)
            tab.toggle_chat_buttons()
            tab.update_room_user_completions()

            if self.command_help is None:
                self.command_help = ChatCommandHelp(window=self.window, interface="chatroom")

            if self.room_wall is None:
                self.room_wall = RoomWall(window=self.window)

            self.command_help.set_menu_button(tab.help_button)
            self.room_wall.set_menu_button(tab.room_wall_button)
            self.room_wall.room = room

            if not tab.loaded:
                tab.load()

            # Remove highlight
            self.unhighlight_room(room)
            break

    def on_create_room_response(self, dialog, _response_id, room):
        private = dialog.get_option_value()
        core.chatrooms.show_room(room, private)

    def on_create_room(self, *_args):

        room = self.window.chatrooms_entry.get_text().strip()

        if not room:
            return

        if (core.users.login_status != UserStatus.OFFLINE
                and room not in core.chatrooms.server_rooms and room not in core.chatrooms.private_rooms):
            room = core.chatrooms.sanitize_room_name(room)
            OptionDialog(
                parent=self.window,
                title=_("Create New Room?"),
                message=_('Do you really want to create a new room "%s"?') % room,
                option_label=_("Make room private"),
                callback=self.on_create_room_response,
                callback_data=room
            ).present()
        else:
            core.chatrooms.show_room(room)

        self.window.chatrooms_entry.set_text("")

    def clear_room_messages(self, room):

        page = self.pages.get(room)

        if page is not None:
            page.chat_view.clear()
            page.activity_view.clear()

    def clear_notifications(self):

        if self.window.current_page_id != self.window.chatrooms_page.id:
            return

        page = self.get_current_page()

        for room, tab in self.pages.items():
            if tab.container == page:
                # Remove highlight
                self.unhighlight_room(room)
                break

    def show_room(self, room, is_private=False, switch_page=True, remembered=False):

        if room not in self.pages:
            is_global = (room == core.chatrooms.GLOBAL_ROOM_NAME)
            tab_position = 0 if is_global and not remembered else -1
            self.pages[room] = tab = ChatRoom(self, room, is_private=is_private, is_global=is_global)

            self.insert_page(
                tab.container, room, focus_callback=tab.on_focus, close_callback=tab.on_leave_room,
                position=tab_position
            )
            tab.set_label(self.get_tab_label_inner(tab.container))

            if not is_global:
                combobox = self.window.search.room_search_combobox
                combobox.append(room)

        if switch_page:
            self.set_current_page(self.pages[room].container)
            self.window.change_main_page(self.window.chatrooms_page)

    def remove_room(self, room):

        page = self.pages.get(room)

        if page is None:
            return

        if page.container == self.get_current_page():
            self.chat_entry.set_parent(None)

            if self.command_help is not None:
                self.command_help.set_menu_button(None)

            if self.room_wall is not None:
                self.room_wall.set_menu_button(None)
                self.room_wall.room = None

        page.clear()
        self.remove_page(page.container, page_args=(room, page.is_private))
        del self.pages[room]
        page.destroy()

        self.chat_entry.clear_unsent_message(room)

        if room != core.chatrooms.GLOBAL_ROOM_NAME:
            combobox = self.window.search.room_search_combobox
            combobox.remove_id(room)

    def highlight_room(self, room, user):

        if not room or room in self.highlighted_rooms:
            return

        self.highlighted_rooms[room] = user
        self.window.update_title()
        self.window.application.tray_icon.update()

    def unhighlight_room(self, room):

        if room not in self.highlighted_rooms:
            return

        del self.highlighted_rooms[room]
        self.window.update_title()
        self.window.application.tray_icon.update()

    def join_room(self, msg):

        page = self.pages.get(msg.room)
        self.join_room_combobox.append(msg.room)

        if page is None:
            return

        page.join_room(msg)

        if page.container == self.get_current_page():
            self.chat_entry.set_sensitive(True)
            page.on_focus()

    def leave_room(self, msg):

        page = self.pages.get(msg.room)

        if page is not None:
            page.leave_room()

    def ignore_user(self, username, *_args):
        for page in self.pages.values():
            page.ignore_user(username)

    def unignore_user(self, username, *_args):
        for page in self.pages.values():
            page.unignore_user(username)

    def peer_address(self, msg):
        for page in self.pages.values():
            page.peer_address(msg)

    def user_stats(self, msg):
        for page in self.pages.values():
            page.user_stats(msg)

    def user_status(self, msg):
        for page in self.pages.values():
            page.user_status(msg)

    def user_country(self, user, country):
        for page in self.pages.values():
            page.user_country(user, country)

    def user_joined_room(self, msg):

        page = self.pages.get(msg.room)

        if page is not None:
            page.user_joined_room(msg)

    def user_left_room(self, msg):

        page = self.pages.get(msg.room)

        if page is not None:
            page.user_left_room(msg)

    def room_list(self, msg):

        self.join_room_combobox.freeze()
        self.join_room_combobox.clear()

        for room, _user_count in chain(msg.rooms, msg.ownedprivaterooms, msg.otherprivaterooms):
            self.join_room_combobox.append(room)

        self.join_room_combobox.unfreeze()

    def echo_room_message(self, room, text, message_type):

        page = self.pages.get(room)

        if page is not None:
            page.echo_room_message(text, message_type)

    def say_chat_room(self, msg):

        page = self.pages.get(msg.room)

        if page is not None:
            page.say_chat_room(msg)

    def global_room_message(self, msg):

        page = self.pages.get(core.chatrooms.GLOBAL_ROOM_NAME)

        if page is not None:
            page.global_room_message(msg)

    def private_room_added(self, msg):
        self.join_room_combobox.append(msg.room)

    def private_room_add_operator(self, msg):

        page = self.pages.get(msg.room)

        if page is not None:
            page.private_room_add_operator(msg)

    def private_room_add_user(self, msg):

        page = self.pages.get(msg.room)

        if page is not None:
            page.private_room_add_user(msg)

    def private_room_remove_operator(self, msg):

        page = self.pages.get(msg.room)

        if page is not None:
            page.private_room_remove_operator(msg)

    def private_room_remove_user(self, msg):

        page = self.pages.get(msg.room)

        if page is not None:
            page.private_room_remove_user(msg)

    def update_completions(self, completions):

        page = self.get_current_page()

        for tab in self.pages.values():
            if tab.container == page:
                tab.update_completions(completions)
                break

    def update_widgets(self):

        self.chat_entry.set_spell_check_enabled(config.sections["ui"]["spellcheck"])

        for tab in self.pages.values():
            tab.toggle_chat_buttons()
            tab.update_tags()

    def server_disconnect(self, *_args):

        self.chat_entry.set_sensitive(False)

        for page in self.pages.values():
            page.server_disconnect()


class ChatRoom:

    def __init__(self, chatrooms, room, is_private, is_global):

        (
            self.activity_container,
            self.activity_search_bar,
            self.activity_view_container,
            self.chat_container,
            self.chat_entry_container,
            self.chat_entry_row,
            self.chat_paned,
            self.chat_search_bar,
            self.chat_view_container,
            self.container,
            self.help_button,
            self.log_toggle,
            self.room_wall_button,
            self.room_wall_label,
            self.user_list_button,
            self.users_container,
            self.users_label,
            self.users_list_container
        ) = ui.load(scope=self, path="chatrooms.ui")

        self.chatrooms = chatrooms
        self.window = chatrooms.window
        self.room = room
        self.is_private = is_private
        self.is_global = is_global

        if GTK_API_VERSION >= 4:
            self.chat_paned.set_shrink_end_child(False)

            inner_button = next(iter(self.room_wall_button))
            self.room_wall_button.set_has_frame(False)
            self.room_wall_label.set_mnemonic_widget(inner_button)
        else:
            self.chat_paned.child_set_property(self.chat_container, "shrink", False)

        self.loaded = False

        self.activity_view = TextView(
            self.activity_view_container, parse_urls=False, editable=False,
            horizontal_margin=10, vertical_margin=5, pixels_below_lines=2
        )
        self.chat_view = ChatView(
            self.chat_view_container, chat_entry=self.chatrooms.chat_entry, editable=False,
            horizontal_margin=10, vertical_margin=5, pixels_below_lines=2,
            status_users=core.chatrooms.joined_rooms[room].users,
            roomname_event=(self.roomname_event if is_global else None),
            username_event=self.username_event
        )

        # Event Text Search
        self.activity_search_bar = TextSearchBar(
            self.activity_view.widget, self.activity_search_bar,
            placeholder_text=_("Search activity log…")
        )

        # Chat Text Search
        self.chat_search_bar = TextSearchBar(
            self.chat_view.widget, self.chat_search_bar,
            controller_widget=self.chat_container, focus_widget=self.chatrooms.chat_entry,
            placeholder_text=_("Search chat log…")
        )

        self.user_list_button.connect("toggled", self.on_toggle_user_list_visibility)
        self.user_list_button.set_active(config.sections["chatrooms"]["user_list_visible"])

        self.log_toggle.set_active(room in config.sections["logging"]["rooms"])
        self.toggle_chat_buttons()

        if GTK_API_VERSION >= 4:
            inner_button = next(iter(self.help_button))
            add_css_class(widget=inner_button, css_class="image-button")

        self.users_list_view = TreeView(
            self.window, parent=self.users_list_container, name="chat_room", secondary_name=room,
            persistent_sort=True, activate_row_callback=self.on_row_activated,
            columns={
                # Visible columns
                "status": {
                    "column_type": "icon",
                    "title": _("Status"),
                    "width": 25,
                    "hide_header": True
                },
                "country": {
                    "column_type": "icon",
                    "title": _("Country"),
                    "width": 30,
                    "hide_header": True
                },
                "user": {
                    "column_type": "text",
                    "title": _("User"),
                    "width": 110,
                    "expand_column": True,
                    "iterator_key": True,
                    "default_sort_type": "ascending",
                    "text_underline_column": "username_underline_data",
                    "text_weight_column": "username_weight_data",
                    "sensitive_column": "is_unignored_data"
                },
                "speed": {
                    "column_type": "number",
                    "title": _("Speed"),
                    "width": 80,
                    "sort_column": "speed_data",
                    "expand_column": True,
                    "sensitive_column": "is_unignored_data"
                },
                "files": {
                    "column_type": "number",
                    "title": _("Files"),
                    "sort_column": "files_data",
                    "expand_column": True,
                    "sensitive_column": "is_unignored_data"
                },

                # Hidden data columns
                "speed_data": {"data_type": GObject.TYPE_UINT},
                "files_data": {"data_type": GObject.TYPE_UINT},
                "username_weight_data": {"data_type": Pango.Weight},
                "username_underline_data": {"data_type": Pango.Underline},
                "is_unignored_data": {"data_type": GObject.TYPE_BOOLEAN}
            }
        )

        self.popup_menu_user_chat = UserPopupMenu(
            self.window.application, parent=self.chat_view.widget, connect_events=False,
            tab_name="chatrooms"
        )
        self.popup_menu_user_list = UserPopupMenu(
            self.window.application, parent=self.users_list_view.widget,
            callback=self.on_popup_menu_user, tab_name="chatrooms"
        )

        for menu in (self.popup_menu_user_chat, self.popup_menu_user_list):
            menu.add_items(
                ("", None),
                ("#" + _("Sear_ch User's Files"), menu.on_search_user)
            )

        self.popup_menu_activity_view = PopupMenu(self.window.application, self.activity_view.widget,
                                                  self.on_popup_menu_log)
        self.popup_menu_activity_view.add_items(
            ("#" + _("Find…"), self.on_find_activity_log),
            ("", None),
            ("#" + _("Copy"), self.activity_view.on_copy_text),
            ("#" + _("Copy All"), self.activity_view.on_copy_all_text),
            ("", None),
            ("#" + _("Clear Activity View"), self.activity_view.on_clear_all_text),
            ("", None),
            ("#" + _("_Leave Room"), self.on_leave_room)
        )

        self.popup_menu_chat_view = PopupMenu(self.window.application, self.chat_view.widget, self.on_popup_menu_chat)
        self.popup_menu_chat_view.add_items(
            ("#" + _("Find…"), self.on_find_room_log),
            ("", None),
            ("#" + _("Copy"), self.chat_view.on_copy_text),
            ("#" + _("Copy Link"), self.chat_view.on_copy_link),
            ("#" + _("Copy All"), self.chat_view.on_copy_all_text),
            ("", None)
        )
        if not self.window.application.isolated_mode:
            self.popup_menu_chat_view.add_items(
                ("#" + _("View Room Log"), self.on_view_room_log)
            )
        self.popup_menu_chat_view.add_items(
            ("#" + _("Delete Room Log…"), self.on_delete_room_log),
            ("", None),
            ("#" + _("Clear Message View"), self.chat_view.on_clear_all_text),
            ("#" + _("_Leave Room"), self.on_leave_room)
        )

        self.tab_menu = PopupMenu(self.window.application)
        self.tab_menu.add_items(
            ("#" + _("_Leave Room"), self.on_leave_room)
        )

        self.popup_menus = (
            self.popup_menu_user_chat, self.popup_menu_user_list,
            self.popup_menu_activity_view, self.popup_menu_chat_view, self.tab_menu
        )

        self.setup_public_feed()
        self.prepend_old_messages()

    def load(self):
        GLib.idle_add(self.read_room_logs_finished)
        self.loaded = True

    def clear(self):

        self.activity_view.clear()
        self.chat_view.clear()
        self.users_list_view.clear()

    def destroy(self):

        for menu in self.popup_menus:
            menu.destroy()

        self.activity_view.destroy()
        self.chat_view.destroy()
        self.users_list_view.destroy()
        self.__dict__.clear()

    def set_label(self, label):
        self.tab_menu.set_parent(label)

    def setup_public_feed(self):

        if not self.is_global:
            return

        for widget in (self.activity_container, self.chat_entry_container, self.help_button, self.user_list_button):
            widget.set_visible(False)

        self.chat_entry_row.set_halign(Gtk.Align.END)

    def add_user_row(self, userdata):

        username = userdata.username
        status = userdata.status
        status_icon_name = USER_STATUS_ICON_NAMES.get(status, "")
        flag_icon_name = get_flag_icon_name(userdata.country)
        speed = userdata.avgspeed or 0
        files = userdata.files or 0
        h_speed = human_speed(speed) if speed > 0 else ""
        h_files = humanize(files)
        weight = Pango.Weight.NORMAL
        underline = Pango.Underline.NONE
        is_unignored = not (core.network_filter.is_user_ignored(username)
                            or core.network_filter.is_user_ip_ignored(username))

        if self.room in core.chatrooms.private_rooms:
            if username == core.chatrooms.private_rooms[self.room].owner:
                weight = Pango.Weight.BOLD
                underline = Pango.Underline.SINGLE

            elif username in core.chatrooms.private_rooms[self.room].operators:
                weight = Pango.Weight.BOLD
                underline = Pango.Underline.NONE

        self.users_list_view.add_row([
            status_icon_name,
            flag_icon_name,
            username,
            h_speed,
            h_files,
            speed,
            files,
            weight,
            underline,
            is_unignored
        ], select_row=False)

    def read_room_logs_finished(self):

        if not hasattr(self, "chat_view"):
            # Tab was closed
            return

        self.activity_view.scroll_bottom()
        self.chat_view.scroll_bottom()

        self.activity_view.auto_scroll = self.chat_view.auto_scroll = True

    def prepend_old_messages(self):

        log_lines = log.read_log(
            folder_path=log.room_folder_path,
            basename=self.room,
            num_lines=config.sections["logging"]["readroomlines"]
        )

        if not log_lines:
            return

        self.chat_view.prepend_log_lines(log_lines, login_username=config.sections["server"]["login"])

    def populate_room_users(self, joined_users):

        # Temporarily disable sorting for increased performance
        self.users_list_view.freeze()

        for userdata in joined_users:
            username = userdata.username
            iterator = self.users_list_view.iterators.get(username)

            if iterator is not None:
                self.users_list_view.remove_row(iterator)

            self.add_user_row(userdata)

        private_room = core.chatrooms.private_rooms.get(self.room)

        # List private room members who are offline/not currently joined
        if private_room is not None:
            owner = private_room.owner

            for username in private_room.members:
                if username not in self.users_list_view.iterators:
                    self.add_user_row(UserData(username, status=UserStatus.OFFLINE))

            if owner and owner not in self.users_list_view.iterators:
                self.add_user_row(UserData(owner, status=UserStatus.OFFLINE))

        self.users_list_view.unfreeze()

        # Update user count
        self.update_user_count()

        # Update all username tags in chat log
        self.chat_view.update_user_tags()

        # Add room users to completion list
        if self.chatrooms.get_current_page() == self.container:
            self.update_room_user_completions()

    def populate_user_menu(self, user, menu):
        menu.set_user(user)
        menu.toggle_user_items()

    def on_find_activity_log(self, *_args):
        self.activity_search_bar.set_visible(True)

    def on_find_room_log(self, *_args):
        self.chat_search_bar.set_visible(True)

    def get_selected_username(self):

        for iterator in self.users_list_view.get_selected_rows():
            return self.users_list_view.get_row_value(iterator, "user")

        return None

    def on_row_activated(self, _list_view, _path, _column):

        user = self.get_selected_username()

        if user is not None:
            core.userinfo.show_user(user)

    def on_popup_menu_user(self, menu, _widget):
        user = self.get_selected_username()
        self.populate_user_menu(user, menu)

    def on_popup_menu_log(self, menu, _textview):
        menu.actions[_("Copy")].set_enabled(self.activity_view.get_has_selection())

    def on_popup_menu_chat(self, menu, _textview):
        menu.actions[_("Copy")].set_enabled(self.chat_view.get_has_selection())
        menu.actions[_("Copy Link")].set_enabled(bool(self.chat_view.get_url_for_current_pos()))

    def on_toggle_user_list_visibility(self, *_args):

        if self.is_global:
            return

        visible = self.user_list_button.get_active()
        config.sections["chatrooms"]["user_list_visible"] = visible
        tooltip = _("Hide Room Users") if visible else _("Show Room Users")

        self.user_list_button.set_tooltip_text(tooltip)
        self.users_container.set_visible(visible)

    def toggle_chat_buttons(self):

        is_log_toggle_visible = not config.sections["logging"]["chatrooms"]

        self.log_toggle.set_visible(is_log_toggle_visible)

        if self.is_global:
            self.chat_entry_row.set_visible(is_log_toggle_visible)

        self.user_list_button.set_active(config.sections["chatrooms"]["user_list_visible"])

    def _show_notification(self, room, user, text, is_mentioned):

        self.chatrooms.request_tab_changed(self.container, is_important=is_mentioned, is_quiet=self.is_global)

        if self.is_global and room in core.chatrooms.joined_rooms:
            # Don't show notifications about the Public feed that's duplicated in an open tab
            return

        if is_mentioned:
            log.add(_("%(user)s mentioned you in room %(room)s") % {"user": user, "room": room})

            if config.sections["notifications"]["notification_popup_chatroom_mention"]:
                core.notifications.show_chatroom_notification(
                    room, text,
                    title=_("Mentioned by %(user)s in Room %(room)s") % {"user": user, "room": room},
                    high_priority=True
                )

        if (self.chatrooms.get_current_page() == self.container
                and self.window.current_page_id == self.window.chatrooms_page.id and self.window.is_active()):
            # Don't show notifications if the chat is open and the window is in use
            return

        if is_mentioned:
            # We were mentioned, update tray icon and show urgency hint
            self.chatrooms.highlight_room(room, user)
            return

        if not self.is_global and config.sections["notifications"]["notification_popup_chatroom"]:
            # Don't show notifications for public feed room, they're too noisy
            core.notifications.show_chatroom_notification(
                room, text,
                title=_("Message by %(user)s in Room %(room)s") % {"user": user, "room": room}
            )

    def say_chat_room(self, msg):

        roomname = msg.room
        username = msg.user
        message = msg.message
        message_type = msg.message_type

        if message_type != "local":
            self._show_notification(
                roomname, username, message, is_mentioned=(message_type == "hilite"))

        self.chat_view.add_line(
            message, message_type=message_type, roomname=roomname if self.is_global else None, username=username,
            timestamp_format=config.sections["logging"]["rooms_timestamp"]
        )

    def global_room_message(self, msg):
        self.say_chat_room(msg)

    def echo_room_message(self, message, message_type):

        if message_type != "command":
            timestamp_format = config.sections["logging"]["rooms_timestamp"]
        else:
            timestamp_format = None

        self.chat_view.add_line(message, message_type=message_type, timestamp_format=timestamp_format)

    def user_joined_room(self, msg):

        userdata = msg.userdata
        username = userdata.username
        iterator = self.users_list_view.iterators.get(username)

        if iterator is not None:
            if not self.is_private:
                return

            self.users_list_view.remove_row(iterator)

        # Add to completion list, and completion drop-down
        if self.chatrooms.get_current_page() == self.container:
            self.chatrooms.chat_entry.add_completion(username)

        if (username != core.users.login_username
                and not core.network_filter.is_user_ignored(username)
                and not core.network_filter.is_user_ip_ignored(username)):
            self.activity_view.add_line(
                _("%s joined the room") % username,
                timestamp_format=config.sections["logging"]["rooms_timestamp"]
            )

        self.add_user_row(userdata)

        self.chat_view.update_user_tag(username)
        self.update_user_count()

    def user_left_room(self, msg):

        username = msg.username
        iterator = self.users_list_view.iterators.get(username)

        if iterator is None:
            return

        # Remove from completion list, and completion drop-down
        if self.chatrooms.get_current_page() == self.container and username not in core.buddies.users:
            self.chatrooms.chat_entry.remove_completion(username)

        if not core.network_filter.is_user_ignored(username) and \
                not core.network_filter.is_user_ip_ignored(username):
            timestamp_format = config.sections["logging"]["rooms_timestamp"]
            self.activity_view.add_line(_("%s left the room") % username, timestamp_format=timestamp_format)

        if self.is_private:
            status_icon_name = USER_STATUS_ICON_NAMES[UserStatus.OFFLINE]
            empty_str = ""
            empty_int = 0

            self.users_list_view.set_row_values(
                iterator,
                column_ids=["status", "speed", "speed_data", "files", "files_data", "country"],
                values=[status_icon_name, empty_str, empty_int, empty_str, empty_int, empty_str]
            )
        else:
            self.users_list_view.remove_row(iterator)

        self.chat_view.update_user_tag(username)
        self.update_user_count()

    def private_room_add_operator(self, msg):

        iterator = self.users_list_view.iterators.get(msg.user)

        if iterator is None:
            return

        self.users_list_view.set_row_values(
            iterator,
            column_ids=["username_weight_data", "username_underline_data"],
            values=[Pango.Weight.BOLD, Pango.Underline.NONE]
        )

    def private_room_add_user(self, msg):

        username = msg.user
        iterator = self.users_list_view.iterators.get(username)

        if iterator is not None:
            return

        self.add_user_row(UserData(username, status=UserStatus.OFFLINE))

        self.chat_view.update_user_tag(username)
        self.update_user_count()

    def private_room_remove_operator(self, msg):

        iterator = self.users_list_view.iterators.get(msg.user)

        if iterator is None:
            return

        self.users_list_view.set_row_values(
            iterator,
            column_ids=["username_weight_data", "username_underline_data"],
            values=[Pango.Weight.NORMAL, Pango.Underline.NONE]
        )

    def private_room_remove_user(self, msg):

        username = msg.user
        iterator = self.users_list_view.iterators.get(username)

        if iterator is None:
            return

        self.users_list_view.remove_row(iterator)

        self.chat_view.update_user_tag(username)
        self.update_user_count()

    def update_user_count(self):
        user_count = len(self.users_list_view.iterators)
        self.users_label.set_text(humanize(user_count))

    def ignore_user(self, username):

        iterator = self.users_list_view.iterators.get(username)

        if iterator is None:
            return

        if self.users_list_view.get_row_value(iterator, "is_unignored_data"):
            self.users_list_view.set_row_value(iterator, "is_unignored_data", False)

    def unignore_user(self, username):

        iterator = self.users_list_view.iterators.get(username)

        if iterator is None:
            return

        if (core.network_filter.is_user_ignored(username)
                or core.network_filter.is_user_ip_ignored(username)):
            return

        if not self.users_list_view.get_row_value(iterator, "is_unignored_data"):
            self.users_list_view.set_row_value(iterator, "is_unignored_data", True)

    def peer_address(self, msg):

        username = msg.user

        if not core.network_filter.is_user_ip_ignored(username):
            return

        self.ignore_user(username)

    def user_stats(self, msg):

        user = msg.user
        iterator = self.users_list_view.iterators.get(user)

        if iterator is None:
            return

        if user not in core.chatrooms.joined_rooms[self.room].users:
            # Private room member offline/not currently joined
            return

        speed = msg.avgspeed or 0
        num_files = msg.files or 0
        column_ids = []
        column_values = []

        if speed != self.users_list_view.get_row_value(iterator, "speed_data"):
            h_speed = human_speed(speed) if speed > 0 else ""

            column_ids.extend(("speed", "speed_data"))
            column_values.extend((h_speed, speed))

        if num_files != self.users_list_view.get_row_value(iterator, "files_data"):
            h_num_files = humanize(num_files)

            column_ids.extend(("files", "files_data"))
            column_values.extend((h_num_files, num_files))

        if column_ids:
            self.users_list_view.set_row_values(iterator, column_ids, column_values)

    def user_status(self, msg):

        user = msg.user
        iterator = self.users_list_view.iterators.get(user)

        if iterator is None:
            return

        if user not in core.chatrooms.joined_rooms[self.room].users:
            # Private room member offline/not currently joined
            return

        status = msg.status
        status_icon_name = USER_STATUS_ICON_NAMES.get(status)

        if not status_icon_name or status_icon_name == self.users_list_view.get_row_value(iterator, "status"):
            return

        if status == UserStatus.AWAY:
            action = _("%s has gone away")

        elif status == UserStatus.ONLINE:
            action = _("%s has returned")

        else:
            # If we reach this point, the server did something wrong. The user should have
            # left the room before an offline status is sent.
            return

        if not core.network_filter.is_user_ignored(user) and not core.network_filter.is_user_ip_ignored(user):
            self.activity_view.add_line(
                action % user, timestamp_format=config.sections["logging"]["rooms_timestamp"])

        self.users_list_view.set_row_value(iterator, "status", status_icon_name)

        self.chat_view.update_user_tag(user)

    def user_country(self, user, country_code):

        iterator = self.users_list_view.iterators.get(user)

        if iterator is None:
            return

        if user not in core.chatrooms.joined_rooms[self.room].users:
            # Private room member offline/not currently joined
            return

        flag_icon_name = get_flag_icon_name(country_code)

        if flag_icon_name and flag_icon_name != self.users_list_view.get_row_value(iterator, "country"):
            self.users_list_view.set_row_value(iterator, "country", flag_icon_name)

    def roomname_event(self, _pos_x, _pos_y, room):
        core.chatrooms.show_room(room)

    def username_event(self, pos_x, pos_y, user):

        menu = self.popup_menu_user_chat
        menu.update_model()
        self.populate_user_menu(user, menu)
        menu.popup(pos_x, pos_y)

    def update_tags(self):
        self.chat_view.update_tags()

    def server_disconnect(self):
        self.leave_room()

    def join_room(self, msg):

        self.is_private = msg.private
        self.populate_room_users(msg.users)

        self.activity_view.add_line(
            _("%s joined the room") % core.users.login_username,
            timestamp_format=config.sections["logging"]["rooms_timestamp"]
        )

    def leave_room(self):

        self.users_list_view.clear()
        self.update_user_count()

        if self.chatrooms.get_current_page() == self.container:
            self.update_room_user_completions()

        self.chat_view.update_user_tags()

    def on_focus(self, *_args):

        if self.window.current_page_id == self.window.chatrooms_page.id:
            widget = self.chatrooms.chat_entry if self.chatrooms.chat_entry.get_sensitive() else self.chat_view
            widget.grab_focus()

        return True

    def on_leave_room(self, *_args):
        core.chatrooms.remove_room(self.room)

    def on_log_toggled(self, *_args):

        if not self.log_toggle.get_active():
            if self.room in config.sections["logging"]["rooms"]:
                config.sections["logging"]["rooms"].remove(self.room)
            return

        if self.room not in config.sections["logging"]["rooms"]:
            config.sections["logging"]["rooms"].append(self.room)

    def on_view_room_log(self, *_args):
        log.open_log(log.room_folder_path, self.room)

    def on_delete_room_log_response(self, *_args):

        log.delete_log(log.room_folder_path, self.room)
        self.activity_view.clear()
        self.chat_view.clear()

    def on_delete_room_log(self, *_args):

        OptionDialog(
            parent=self.window,
            title=_("Delete Logged Messages?"),
            message=_("Do you really want to permanently delete all logged messages for this room?"),
            destructive_response_id="ok",
            callback=self.on_delete_room_log_response
        ).present()

    def update_room_user_completions(self):
        self.update_completions(core.chatrooms.completions.copy())

    def update_completions(self, completions):

        # We want to include users for this room only
        if config.sections["words"]["roomusers"]:
            room_users = core.chatrooms.joined_rooms[self.room].users
            completions.update(room_users)

        self.chatrooms.chat_entry.set_completions(completions)


===== downloads.py =====
# SPDX-FileCopyrightText: 2020-2025 Nicotine+ Contributors
# SPDX-FileCopyrightText: 2016-2017 Michael Labouebe <gfarmerfr@free.fr>
# SPDX-FileCopyrightText: 2016-2018 Mutnick <mutnick@techie.com>
# SPDX-FileCopyrightText: 2013 eLvErDe <gandalf@le-vert.net>
# SPDX-FileCopyrightText: 2008-2012 quinox <quinox@users.sf.net>
# SPDX-FileCopyrightText: 2009 hedonist <ak@sensi.org>
# SPDX-FileCopyrightText: 2006-2009 daelstorm <daelstorm@gmail.com>
# SPDX-FileCopyrightText: 2003-2004 Hyriand <hyriand@thegraveyard.org>
# SPDX-License-Identifier: GPL-3.0-or-later

import os

from pynicotine.core import core
from pynicotine.events import events
from pynicotine.gtkgui.application import GTK_API_VERSION
from pynicotine.gtkgui.popovers.downloadspeeds import DownloadSpeeds
from pynicotine.gtkgui.transfers import Transfers
from pynicotine.gtkgui.widgets import clipboard
from pynicotine.gtkgui.widgets.dialogs import OptionDialog
from pynicotine.transfers import TransferStatus
from pynicotine.utils import human_speed
from pynicotine.utils import open_file_path
from pynicotine.utils import open_folder_path


class Downloads(Transfers):

    def __init__(self, window):

        self.path_separator = os.sep
        self.path_label = _("Path")
        self.retry_label = _("_Resume")
        self.abort_label = _("P_ause")

        self.transfer_page = self.page = window.downloads_page
        self.page.id = "downloads"
        self.toolbar = window.downloads_toolbar
        self.toolbar_start_content = window.downloads_title
        self.toolbar_end_content = window.downloads_end
        self.toolbar_default_widget = window.download_users_button

        self.user_counter = window.download_users_label
        self.file_counter = window.download_files_label
        self.expand_button = window.downloads_expand_button
        self.expand_icon = window.downloads_expand_icon
        self.grouping_button = window.downloads_grouping_button
        self.status_label = window.download_status_label

        super().__init__(window, transfer_type="download")

        if GTK_API_VERSION >= 4:
            window.downloads_content.append(self.container)
        else:
            window.downloads_content.add(self.container)

        self.popup_menu_clear.add_items(
            ("#" + _("Finished / Filtered"), self.on_clear_finished_filtered),
            ("", None),
            ("#" + _("Finished"), self.on_clear_finished),
            ("#" + _("Paused"), self.on_clear_paused),
            ("#" + _("Filtered"), self.on_clear_filtered),
            ("#" + _("Deleted"), self.on_clear_deleted),
            ("#" + _("Queued…"), self.on_try_clear_queued),
            ("", None),
            ("#" + _("Everything…"), self.on_try_clear_all),
        )
        self.popup_menu_clear.update_model()

        for event_name, callback in (
            ("abort-download", self.abort_transfer),
            ("abort-downloads", self.abort_transfers),
            ("clear-download", self.clear_transfer),
            ("clear-downloads", self.clear_transfers),
            ("download-large-folder", self.download_large_folder),
            ("folder-download-finished", self.folder_download_finished),
            ("set-connection-stats", self.set_connection_stats),
            ("start", self.start),
            ("update-download", self.update_model),
            ("update-download-limits", self.update_limits)
        ):
            events.connect(event_name, callback)

        self.download_speeds = DownloadSpeeds(window)

    def start(self):
        self.init_transfers(core.downloads.transfers.values())

    def destroy(self):
        self.download_speeds.destroy()
        super().destroy()

    def get_transfer_folder_path(self, transfer):
        return transfer.folder_path

    def retry_selected_transfers(self):
        core.downloads.retry_downloads(self.selected_transfers)

    def abort_selected_transfers(self):
        core.downloads.abort_downloads(self.selected_transfers)

    def remove_selected_transfers(self):
        core.downloads.clear_downloads(downloads=self.selected_transfers)

    def set_connection_stats(self, download_bandwidth=0, **_kwargs):

        # Sync parent row updates with connection stats
        self._update_pending_parent_rows()

        download_bandwidth = human_speed(download_bandwidth)
        download_bandwidth_text = f"{download_bandwidth} ( {len(core.downloads.active_users)} )"

        if self.window.download_status_label.get_text() == download_bandwidth_text:
            return

        self.window.download_status_label.set_text(download_bandwidth_text)
        self.window.application.tray_icon.set_download_status(
            _("Downloads: %(speed)s") % {"speed": download_bandwidth})

    def on_try_clear_queued(self, *_args):

        OptionDialog(
            parent=self.window,
            title=_("Clear Queued Downloads"),
            message=_("Do you really want to clear all queued downloads?"),
            destructive_response_id="ok",
            callback=self.on_clear_queued
        ).present()

    def on_clear_all_response(self, *_args):
        core.downloads.clear_downloads()

    def on_try_clear_all(self, *_args):

        OptionDialog(
            parent=self.window,
            title=_("Clear All Downloads"),
            message=_("Do you really want to clear all downloads?"),
            destructive_response_id="ok",
            callback=self.on_clear_all_response
        ).present()

    def folder_download_response(self, _dialog, _response_id, data):
        download_callback, callback_args = data
        download_callback(*callback_args)

    def folder_download_finished(self, _folder_path):
        if self.window.current_page_id != self.transfer_page.id:
            self.window.notebook.request_tab_changed(self.transfer_page, is_important=True)

    def download_large_folder(self, username, folder, numfiles, download_callback, callback_args):

        OptionDialog(
            parent=self.window,
            title=_("Download %(num)i files?") % {"num": numfiles},
            message=_("Do you really want to download %(num)i files from %(user)s's folder %(folder)s?") % {
                "num": numfiles, "user": username, "folder": folder},
            buttons=[
                ("cancel", _("_Cancel")),
                ("download", _("_Download Folder"))
            ],
            callback=self.folder_download_response,
            callback_data=(download_callback, callback_args)
        ).present()

    def on_copy_file_url(self, *_args):

        transfer = next(iter(self.selected_transfers), None)

        if transfer:
            url = core.userbrowse.get_soulseek_url(transfer.username, transfer.virtual_path)
            clipboard.copy_text(url)

    def on_copy_folder_url(self, *_args):

        transfer = next(iter(self.selected_transfers), None)

        if transfer:
            folder_path, separator, _basename = transfer.virtual_path.rpartition("\\")
            url = core.userbrowse.get_soulseek_url(transfer.username, folder_path + separator)

            clipboard.copy_text(url)

    def on_open_file_manager(self, *_args):

        folder_path = None

        for transfer in self.selected_transfers:
            file_path = core.downloads.get_current_download_file_path(transfer)
            folder_path = os.path.dirname(file_path)

            if transfer.status == TransferStatus.FINISHED:
                # Prioritize finished downloads
                break

        open_folder_path(folder_path)

    def on_open_file(self, *_args):

        for transfer in self.selected_transfers:
            file_path = core.downloads.get_current_download_file_path(transfer)
            open_file_path(file_path)

    def on_browse_folder(self, *_args):

        transfer = next(iter(self.selected_transfers), None)

        if not transfer:
            return

        user = transfer.username
        path = transfer.virtual_path

        core.userbrowse.browse_user(user, path=path)

    def on_clear_queued(self, *_args):
        core.downloads.clear_downloads(statuses={TransferStatus.QUEUED})

    def on_clear_finished(self, *_args):
        core.downloads.clear_downloads(statuses={TransferStatus.FINISHED})

    def on_clear_paused(self, *_args):
        core.downloads.clear_downloads(statuses={TransferStatus.PAUSED})

    def on_clear_finished_filtered(self, *_args):
        core.downloads.clear_downloads(statuses={TransferStatus.FINISHED, TransferStatus.FILTERED})

    def on_clear_filtered(self, *_args):
        core.downloads.clear_downloads(statuses={TransferStatus.FILTERED})

    def on_clear_deleted(self, *_args):
        core.downloads.clear_downloads(clear_deleted=True)


===== interests.py =====
# SPDX-FileCopyrightText: 2020-2025 Nicotine+ Contributors
# SPDX-FileCopyrightText: 2006-2009 daelstorm <daelstorm@gmail.com>
# SPDX-FileCopyrightText: 2003-2004 Hyriand <hyriand@thegraveyard.org>
# SPDX-License-Identifier: GPL-3.0-or-later

from gi.repository import GLib
from gi.repository import GObject

from pynicotine.config import config
from pynicotine.core import core
from pynicotine.events import events
from pynicotine.gtkgui.application import GTK_API_VERSION
from pynicotine.gtkgui.widgets import ui
from pynicotine.gtkgui.widgets.combobox import ComboBox
from pynicotine.gtkgui.widgets.popupmenu import PopupMenu
from pynicotine.gtkgui.widgets.popupmenu import UserPopupMenu
from pynicotine.gtkgui.widgets.treeview import TreeView
from pynicotine.gtkgui.widgets.theme import USER_STATUS_ICON_NAMES
from pynicotine.gtkgui.widgets.theme import get_flag_icon_name
from pynicotine.slskmessages import UserStatus
from pynicotine.utils import humanize
from pynicotine.utils import human_speed


class Interests:

    def __init__(self, window):

        (
            self.add_dislike_container,
            self.add_dislike_entry,
            self.add_like_container,
            self.add_like_entry,
            self.container,
            self.dislikes_list_container,
            self.likes_list_container,
            self.recommendations_button,
            self.recommendations_label,
            self.recommendations_list_container,
            self.similar_users_label,
            self.similar_users_list_container
        ) = ui.load(scope=self, path="interests.ui")

        if GTK_API_VERSION >= 4:
            window.interests_container.append(self.container)
        else:
            window.interests_container.add(self.container)

        self.window = window
        self.page = window.interests_page
        self.page.id = "interests"
        self.toolbar = window.interests_toolbar
        self.toolbar_start_content = window.interests_title
        self.toolbar_end_content = window.interests_end
        self.toolbar_default_widget = None
        self.popup_menus = []

        self.populated_recommends = False

        # Columns
        self.likes_list_view = TreeView(
            window, parent=self.likes_list_container,
            delete_accelerator_callback=self.on_remove_thing_i_like,
            columns={
                "likes": {
                    "column_type": "text",
                    "title": _("Likes"),
                    "default_sort_type": "ascending"
                }
            }
        )

        self.dislikes_list_view = TreeView(
            window, parent=self.dislikes_list_container,
            delete_accelerator_callback=self.on_remove_thing_i_dislike,
            columns={
                "dislikes": {
                    "column_type": "text",
                    "title": _("Dislikes"),
                    "default_sort_type": "ascending"
                }
            }
        )

        self.recommendations_list_view = TreeView(
            window, parent=self.recommendations_list_container,
            activate_row_callback=self.on_r_row_activated,
            columns={
                # Visible columns
                "rating": {
                    "column_type": "number",
                    "title": _("Rating"),
                    "width": 0,
                    "sort_column": "rating_data",
                    "default_sort_type": "descending"
                },
                "item": {
                    "column_type": "text",
                    "title": _("Item"),
                    "iterator_key": True
                },

                # Hidden data columns
                "rating_data": {"data_type": GObject.TYPE_INT}
            }
        )

        self.similar_users_list_view = TreeView(
            window, parent=self.similar_users_list_container,
            activate_row_callback=self.on_ru_row_activated,
            columns={
                # Visible columns
                "status": {
                    "column_type": "icon",
                    "title": _("Status"),
                    "width": 25,
                    "hide_header": True
                },
                "country": {
                    "column_type": "icon",
                    "title": _("Country"),
                    "width": 30,
                    "hide_header": True
                },
                "user": {
                    "column_type": "text",
                    "title": _("User"),
                    "width": 120,
                    "expand_column": True,
                    "iterator_key": True
                },
                "speed": {
                    "column_type": "number",
                    "title": _("Speed"),
                    "width": 90,
                    "sort_column": "speed_data",
                    "expand_column": True
                },
                "files": {
                    "column_type": "number",
                    "title": _("Files"),
                    "sort_column": "files_data",
                    "expand_column": True
                },

                # Hidden data columns
                "speed_data": {"data_type": GObject.TYPE_UINT},
                "files_data": {"data_type": GObject.TYPE_UINT},
                "rating_data": {
                    "data_type": GObject.TYPE_UINT,
                    "default_sort_type": "descending"
                }
            }
        )

        self.likes_list_view.freeze()
        self.dislikes_list_view.freeze()

        for item in config.sections["interests"]["likes"]:
            if isinstance(item, str):
                self.add_thing_i_like(item, select_row=False)

        for item in config.sections["interests"]["dislikes"]:
            if isinstance(item, str):
                self.add_thing_i_hate(item, select_row=False)

        self.likes_list_view.unfreeze()
        self.dislikes_list_view.unfreeze()

        # Comboboxes

        self.add_like_combobox = ComboBox(
            container=self.add_like_container, has_entry=True,
            entry=self.add_like_entry, item_selected_callback=self.on_add_thing_i_like
        )
        self.add_dislike_combobox = ComboBox(
            container=self.add_dislike_container, has_entry=True,
            entry=self.add_dislike_entry, item_selected_callback=self.on_add_thing_i_dislike
        )

        # Popup menus
        popup = PopupMenu(self.window.application, self.likes_list_view.widget)
        popup.add_items(
            ("#" + _("_Recommendations for Item"), self.on_recommend_item, self.likes_list_view, "likes"),
            ("#" + _("_Search for Item"), self.on_recommend_search, self.likes_list_view, "likes"),
            ("", None),
            ("#" + _("Remove"), self.on_remove_thing_i_like)
        )
        self.popup_menus.append(popup)

        popup = PopupMenu(self.window.application, self.dislikes_list_view.widget)
        popup.add_items(
            ("#" + _("_Recommendations for Item"), self.on_recommend_item, self.dislikes_list_view, "dislikes"),
            ("#" + _("_Search for Item"), self.on_recommend_search, self.dislikes_list_view, "dislikes"),
            ("", None),
            ("#" + _("Remove"), self.on_remove_thing_i_dislike)
        )
        self.popup_menus.append(popup)

        popup = PopupMenu(self.window.application, self.recommendations_list_view.widget, self.on_popup_r_menu)
        popup.add_items(
            ("$" + _("I _Like This"), self.on_like_recommendation, self.recommendations_list_view, "item"),
            ("$" + _("I _Dislike This"), self.on_dislike_recommendation, self.recommendations_list_view, "item"),
            ("", None),
            ("#" + _("_Recommendations for Item"), self.on_recommend_item, self.recommendations_list_view, "item"),
            ("#" + _("_Search for Item"), self.on_recommend_search, self.recommendations_list_view, "item")
        )
        self.popup_menus.append(popup)

        popup = UserPopupMenu(
            self.window.application, parent=self.similar_users_list_view.widget, callback=self.on_popup_ru_menu,
            tab_name="interests"
        )
        self.popup_menus.append(popup)

        for event_name, callback in (
            ("add-dislike", self.add_thing_i_hate),
            ("add-interest", self.add_thing_i_like),
            ("global-recommendations", self.global_recommendations),
            ("item-recommendations", self.item_recommendations),
            ("item-similar-users", self.item_similar_users),
            ("recommendations", self.recommendations),
            ("remove-dislike", self.remove_thing_i_hate),
            ("remove-interest", self.remove_thing_i_like),
            ("server-login", self.server_login),
            ("server-disconnect", self.server_disconnect),
            ("similar-users", self.similar_users),
            ("user-country", self.user_country),
            ("user-stats", self.user_stats),
            ("user-status", self.user_status)
        ):
            events.connect(event_name, callback)

    def destroy(self):

        for menu in self.popup_menus:
            menu.destroy()

        self.likes_list_view.destroy()
        self.dislikes_list_view.destroy()
        self.recommendations_list_view.destroy()
        self.similar_users_list_view.destroy()

        self.__dict__.clear()

    def on_focus(self, *_args):

        self.populate_recommendations()
        self.recommendations_list_view.grab_focus()
        return True

    def server_login(self, msg):

        if not msg.success:
            return

        self.recommendations_button.set_sensitive(True)

        if self.window.current_page_id != self.window.interests_page.id:
            # Only populate recommendations if the tab is open on login
            return

        self.populate_recommendations()

    def server_disconnect(self, *_args):

        self.recommendations_button.set_sensitive(False)

        for iterator in self.similar_users_list_view.iterators.values():
            self.similar_users_list_view.set_row_value(iterator, "status", USER_STATUS_ICON_NAMES[UserStatus.OFFLINE])

        self.populated_recommends = False

    def populate_recommendations(self):
        """Populates the lists of recommendations and similar users if
        empty."""

        if self.populated_recommends or core.users.login_status == UserStatus.OFFLINE:
            return

        self.show_recommendations()

    def show_recommendations(self, always_global=False):

        self.recommendations_label.set_label(_("Recommendations"))
        self.similar_users_label.set_label(_("Similar Users"))

        if always_global or (not self.likes_list_view.iterators and not self.dislikes_list_view.iterators):
            core.interests.request_global_recommendations()
        else:
            core.interests.request_recommendations()

        core.interests.request_similar_users()
        self.populated_recommends = True

    def show_item_recommendations(self, list_view, column_id):

        for iterator in list_view.get_selected_rows():
            item = list_view.get_row_value(iterator, column_id)

            core.interests.request_item_recommendations(item)
            core.interests.request_item_similar_users(item)
            self.populated_recommends = True

            if self.window.current_page_id != self.window.interests_page.id:
                self.window.change_main_page(self.window.interests_page)
            return

    def add_thing_i_like(self, item, select_row=True):

        item = item.strip().lower()

        if not item:
            return

        iterator = self.likes_list_view.iterators.get(item)

        if iterator is None:
            self.likes_list_view.add_row([item], select_row=select_row)

    def add_thing_i_hate(self, item, select_row=True):

        item = item.strip().lower()

        if not item:
            return

        iterator = self.dislikes_list_view.iterators.get(item)

        if iterator is None:
            self.dislikes_list_view.add_row([item], select_row=select_row)

    def remove_thing_i_like(self, item):

        iterator = self.likes_list_view.iterators.get(item)

        if iterator is not None:
            self.likes_list_view.remove_row(iterator)

    def remove_thing_i_hate(self, item):

        iterator = self.dislikes_list_view.iterators.get(item)

        if iterator is not None:
            self.dislikes_list_view.remove_row(iterator)

    def on_add_thing_i_like(self, *_args):

        item = self.add_like_entry.get_text().strip()

        if not item:
            return

        self.add_like_entry.set_text("")
        self.add_like_combobox.remove_id(item)
        core.interests.add_thing_i_like(item)

    def on_add_thing_i_dislike(self, *_args):

        item = self.add_dislike_entry.get_text().strip()

        if not item:
            return

        self.add_dislike_entry.set_text("")
        self.add_dislike_combobox.remove_id(item)
        core.interests.add_thing_i_hate(item)

    def on_remove_thing_i_like(self, *_args):

        for iterator in self.likes_list_view.get_selected_rows():
            item = self.likes_list_view.get_row_value(iterator, "likes")

            core.interests.remove_thing_i_like(item)
            return

    def on_remove_thing_i_dislike(self, *_args):

        for iterator in self.dislikes_list_view.get_selected_rows():
            item = self.dislikes_list_view.get_row_value(iterator, "dislikes")

            core.interests.remove_thing_i_hate(item)
            return

    def on_like_recommendation(self, action, state, list_view, column_id):

        for iterator in list_view.get_selected_rows():
            item = list_view.get_row_value(iterator, column_id)

            if state.get_boolean():
                core.interests.add_thing_i_like(item)
            else:
                core.interests.remove_thing_i_like(item)

            action.set_state(state)
            return

    def on_dislike_recommendation(self, action, state, list_view, column_id):

        for iterator in list_view.get_selected_rows():
            item = list_view.get_row_value(iterator, column_id)

            if state.get_boolean():
                core.interests.add_thing_i_hate(item)
            else:
                core.interests.remove_thing_i_hate(item)

            action.set_state(state)
            return

    def on_recommend_item(self, _action, _state, list_view, column_id):
        self.show_item_recommendations(list_view, column_id)

    def on_recommend_search(self, _action, _state, list_view, column_id):

        for iterator in list_view.get_selected_rows():
            item = list_view.get_row_value(iterator, column_id)

            core.search.do_search(item, mode="global")
            return

    def on_refresh_recommendations(self, *_args):
        self.show_recommendations()

    def set_recommendations(self, recommendations, unrecommendations, item=None):

        if item:
            self.recommendations_label.set_label(_("Recommendations (%s)") % item)
        else:
            self.recommendations_label.set_label(_("Recommendations"))

        widgets = (self.add_like_combobox, self.add_dislike_combobox, self.recommendations_list_view)

        for widget in widgets:
            widget.clear()
            widget.freeze()

        for thing, rating in recommendations:
            if thing not in self.likes_list_view.iterators:
                self.add_like_combobox.append(thing)

            self.recommendations_list_view.add_row([humanize(rating), thing, rating], select_row=False)

        for thing, rating in unrecommendations:
            if thing not in self.dislikes_list_view.iterators:
                self.add_dislike_combobox.append(thing)

            self.recommendations_list_view.add_row([humanize(rating), thing, rating], select_row=False)

        for widget in widgets:
            widget.unfreeze()

    def global_recommendations(self, msg):
        self.set_recommendations(msg.recommendations, msg.unrecommendations)

    def recommendations(self, msg):

        if msg.recommendations or msg.unrecommendations:
            self.set_recommendations(msg.recommendations, msg.unrecommendations)
            return

        # No personal recommendations, fall back to global ones
        self.show_recommendations(always_global=True)

    def item_recommendations(self, msg):
        self.set_recommendations(msg.recommendations, msg.unrecommendations, msg.thing)

    def set_similar_users(self, users, item=None):

        if item:
            self.similar_users_label.set_label(_("Similar Users (%s)") % item)
        else:
            self.similar_users_label.set_label(_("Similar Users"))

        self.similar_users_list_view.clear()
        self.similar_users_list_view.freeze()

        for index, (user, rating) in enumerate(reversed(list(users.items()))):
            status = core.users.statuses.get(user, UserStatus.OFFLINE)
            country_code = core.users.countries.get(user, "")
            stats = core.users.watched.get(user)
            rating = index + (1000 * rating)  # Preserve default sort order

            if stats is not None:
                speed = stats.upload_speed or 0
                files = stats.files or 0
            else:
                speed = 0
                files = 0

            h_speed = human_speed(speed) if speed > 0 else ""
            h_files = humanize(files)

            self.similar_users_list_view.add_row([
                USER_STATUS_ICON_NAMES[status],
                get_flag_icon_name(country_code),
                user,
                h_speed,
                h_files,
                speed,
                files,
                rating
            ], select_row=False)

        self.similar_users_list_view.unfreeze()

    def similar_users(self, msg):
        self.set_similar_users(msg.users)

    def item_similar_users(self, msg):
        rating = 0
        self.set_similar_users({user: rating for user in msg.users}, msg.thing)

    def user_country(self, user, country_code):

        iterator = self.similar_users_list_view.iterators.get(user)

        if iterator is None:
            return

        flag_icon_name = get_flag_icon_name(country_code)

        if flag_icon_name and flag_icon_name != self.similar_users_list_view.get_row_value(iterator, "country"):
            self.similar_users_list_view.set_row_value(iterator, "country", flag_icon_name)

    def user_status(self, msg):

        iterator = self.similar_users_list_view.iterators.get(msg.user)

        if iterator is None:
            return

        status_icon_name = USER_STATUS_ICON_NAMES.get(msg.status)

        if status_icon_name and status_icon_name != self.similar_users_list_view.get_row_value(iterator, "status"):
            self.similar_users_list_view.set_row_value(iterator, "status", status_icon_name)

    def user_stats(self, msg):

        iterator = self.similar_users_list_view.iterators.get(msg.user)

        if iterator is None:
            return

        speed = msg.avgspeed or 0
        num_files = msg.files or 0
        column_ids = []
        column_values = []

        if speed != self.similar_users_list_view.get_row_value(iterator, "speed_data"):
            h_speed = human_speed(speed) if speed > 0 else ""

            column_ids.extend(("speed", "speed_data"))
            column_values.extend((h_speed, speed))

        if num_files != self.similar_users_list_view.get_row_value(iterator, "files_data"):
            h_num_files = humanize(num_files)

            column_ids.extend(("files", "files_data"))
            column_values.extend((h_num_files, num_files))

        if column_ids:
            self.similar_users_list_view.set_row_values(iterator, column_ids, column_values)

    @staticmethod
    def toggle_menu_items(menu, list_view, column_id):

        for iterator in list_view.get_selected_rows():
            item = list_view.get_row_value(iterator, column_id)

            menu.actions[_("I _Like This")].set_state(
                GLib.Variant.new_boolean(item in config.sections["interests"]["likes"])
            )
            menu.actions[_("I _Dislike This")].set_state(
                GLib.Variant.new_boolean(item in config.sections["interests"]["dislikes"])
            )
            return

    def on_popup_r_menu(self, menu, *_args):
        self.toggle_menu_items(menu, self.recommendations_list_view, column_id="item")

    def on_r_row_activated(self, *_args):
        self.show_item_recommendations(self.recommendations_list_view, column_id="item")

    def on_popup_ru_menu(self, menu, *_args):

        for iterator in self.similar_users_list_view.get_selected_rows():
            user = self.similar_users_list_view.get_row_value(iterator, "user")

            menu.set_user(user)
            menu.toggle_user_items()
            return

    def on_ru_row_activated(self, *_args):

        for iterator in self.similar_users_list_view.get_selected_rows():
            user = self.similar_users_list_view.get_row_value(iterator, "user")

            core.userinfo.show_user(user)
            return


===== mainwindow.py =====
# SPDX-FileCopyrightText: 2020-2025 Nicotine+ Contributors
# SPDX-FileCopyrightText: 2016-2017 Michael Labouebe <gfarmerfr@free.fr>
# SPDX-FileCopyrightText: 2016-2018 Mutnick <mutnick@techie.com>
# SPDX-FileCopyrightText: 2008-2011 quinox <quinox@users.sf.net>
# SPDX-FileCopyrightText: 2006-2009 daelstorm <daelstorm@gmail.com>
# SPDX-FileCopyrightText: 2009 hedonist <ak@sensi.org>
# SPDX-FileCopyrightText: 2003-2004 Hyriand <hyriand@thegraveyard.org>
# SPDX-License-Identifier: GPL-3.0-or-later

import os
import sys
import time

from gi.repository import Gdk
from gi.repository import Gio
from gi.repository import GLib
from gi.repository import Gtk

import pynicotine
from pynicotine.config import config
from pynicotine.core import core
from pynicotine.events import events
from pynicotine.gtkgui.application import GTK_API_VERSION
from pynicotine.gtkgui.application import GTK_MINOR_VERSION
from pynicotine.gtkgui.buddies import Buddies
from pynicotine.gtkgui.chatrooms import ChatRooms
from pynicotine.gtkgui.downloads import Downloads
from pynicotine.gtkgui.interests import Interests
from pynicotine.gtkgui.privatechat import PrivateChats
from pynicotine.gtkgui.search import Searches
from pynicotine.gtkgui.uploads import Uploads
from pynicotine.gtkgui.userbrowse import UserBrowses
from pynicotine.gtkgui.userinfo import UserInfos
from pynicotine.gtkgui.widgets import ui
from pynicotine.gtkgui.widgets.dialogs import MessageDialog
from pynicotine.gtkgui.widgets.iconnotebook import IconNotebook
from pynicotine.gtkgui.widgets.popupmenu import PopupMenu
from pynicotine.gtkgui.widgets.textentry import TextSearchBar
from pynicotine.gtkgui.widgets.textview import TextView
from pynicotine.gtkgui.widgets.theme import USER_STATUS_ICON_NAMES
from pynicotine.gtkgui.widgets.theme import add_css_class
from pynicotine.gtkgui.widgets.theme import remove_css_class
from pynicotine.gtkgui.widgets.theme import set_global_style
from pynicotine.gtkgui.widgets.theme import set_use_header_bar
from pynicotine.gtkgui.widgets.window import Window
from pynicotine.logfacility import log
from pynicotine.slskmessages import UserStatus
from pynicotine.utils import humanize
from pynicotine.utils import open_folder_path


class MainWindow(Window):

    def __init__(self, application):

        self.application = application
        self.current_page_id = ""
        self.auto_away = False
        self.away_timer_id = None
        self.away_cooldown_time = 0
        self.is_fullscreen = False
        self.gesture_click = None
        self.window_active_handler = None
        self.window_visible_handler = None

        # Load UI

        (
            self.add_buddy_entry,
            self.buddy_list_container,
            self.chatrooms_buddy_list_container,
            self.chatrooms_container,
            self.chatrooms_content,
            self.chatrooms_end,
            self.chatrooms_entry,
            self.chatrooms_entry_container,
            self.chatrooms_page,
            self.chatrooms_paned,
            self.chatrooms_title,
            self.chatrooms_toolbar,
            self.connections_label,
            self.container,
            self.content,
            self.download_files_label,
            self.download_status_button,
            self.download_status_label,
            self.download_users_button,
            self.download_users_label,
            self.downloads_content,
            self.downloads_end,
            self.downloads_expand_button,
            self.downloads_expand_icon,
            self.downloads_grouping_button,
            self.downloads_page,
            self.downloads_title,
            self.downloads_toolbar,
            self.header_bar,
            self.header_end,
            self.header_end_container,
            self.header_menu,
            self.header_title,
            self.hide_window_button,
            self.horizontal_paned,
            self.interests_container,
            self.interests_end,
            self.interests_page,
            self.interests_title,
            self.interests_toolbar,
            self.log_container,
            self.log_search_bar,
            self.log_view_container,
            self.private_content,
            self.private_end,
            self.private_entry,
            self.private_entry_container,
            self.private_page,
            self.private_title,
            self.private_toolbar,
            self.room_search_entry,
            self.scan_progress_container,
            self.scan_progress_label,
            self.scan_progress_spinner,
            self.search_content,
            self.search_end,
            self.search_entry,
            self.search_mode_button,
            self.search_mode_label,
            self.search_page,
            self.search_title,
            self.search_toolbar,
            self.status_label,
            self.upload_files_label,
            self.upload_status_button,
            self.upload_status_label,
            self.upload_users_button,
            self.upload_users_label,
            self.uploads_content,
            self.uploads_end,
            self.uploads_expand_button,
            self.uploads_expand_icon,
            self.uploads_grouping_button,
            self.uploads_page,
            self.uploads_title,
            self.uploads_toolbar,
            self.user_search_entry,
            self.user_status_button,
            self.user_status_icon,
            self.user_status_label,
            self.userbrowse_content,
            self.userbrowse_end,
            self.userbrowse_entry,
            self.userbrowse_page,
            self.userbrowse_title,
            self.userbrowse_toolbar,
            self.userinfo_content,
            self.userinfo_end,
            self.userinfo_entry,
            self.userinfo_page,
            self.userinfo_title,
            self.userinfo_toolbar,
            self.userlist_content,
            self.userlist_end,
            self.userlist_page,
            self.userlist_title,
            self.userlist_toolbar,
            self.vertical_paned
        ) = ui.load(scope=self, path="mainwindow.ui")

        super().__init__(widget=Gtk.ApplicationWindow(child=self.container))
        self.header_bar.pack_end(self.header_end)

        if GTK_API_VERSION >= 4:
            try:
                self.header_bar.set_use_native_controls(True)  # pylint: disable=no-member

            except AttributeError:
                # Older GTK version
                pass

            self.header_bar.set_show_title_buttons(True)

            self.horizontal_paned.set_resize_start_child(True)
            self.horizontal_paned.set_shrink_start_child(False)
            self.horizontal_paned.set_resize_end_child(False)
            self.chatrooms_paned.set_resize_end_child(False)
            self.chatrooms_paned.set_shrink_start_child(False)

            self.vertical_paned.set_resize_start_child(True)
            self.vertical_paned.set_shrink_start_child(False)
            self.vertical_paned.set_resize_end_child(False)
            self.vertical_paned.set_shrink_end_child(False)

            # Workaround for screen reader support in GTK <4.12
            for label, button in (
                (self.search_mode_label, self.search_mode_button),
                (self.download_status_label, self.download_status_button),
                (self.upload_status_label, self.upload_status_button)
            ):
                inner_button = next(iter(button))
                label.set_mnemonic_widget(inner_button)
        else:
            self.header_bar.set_has_subtitle(False)
            self.header_bar.set_show_close_button(True)

            self.horizontal_paned.child_set_property(self.vertical_paned, "resize", True)
            self.horizontal_paned.child_set_property(self.vertical_paned, "shrink", False)
            self.horizontal_paned.child_set_property(self.buddy_list_container, "resize", False)
            self.chatrooms_paned.child_set_property(self.chatrooms_buddy_list_container, "resize", False)
            self.chatrooms_paned.child_set_property(self.chatrooms_container, "shrink", False)

            self.vertical_paned.child_set_property(self.content, "resize", True)
            self.vertical_paned.child_set_property(self.content, "shrink", False)
            self.vertical_paned.child_set_property(self.log_container, "resize", False)
            self.vertical_paned.child_set_property(self.log_container, "shrink", False)

        # Avoid unnecessary 'notify' signals when updating number of currently scanned folders
        self.scan_progress_label.freeze_notify()

        # Logging
        self.log_view = TextView(
            self.log_view_container, auto_scroll=not config.sections["logging"]["logcollapsed"],
            parse_urls=False, editable=False, vertical_margin=5, pixels_below_lines=2
        )
        self.log_search_bar = TextSearchBar(
            self.log_view.widget, self.log_search_bar, controller_widget=self.log_container,
            placeholder_text=_("Search log…")
        )

        self.create_log_context_menu()
        events.connect("log-message", self.log_callback)

        # Events
        for event_name, callback in (
            ("quit", self.on_quit),
            ("server-login", self.update_user_status),
            ("server-disconnect", self.update_user_status),
            ("set-connection-stats", self.set_connection_stats),
            ("shares-preparing", self.shares_preparing),
            ("shares-ready", self.shares_ready),
            ("shares-scanning", self.shares_scanning),
            ("user-status", self.user_status)
        ):
            events.connect(event_name, callback)

        # Main notebook
        self.notebook = IconNotebook(
            self,
            parent=self.content,
            switch_page_callback=self.on_switch_page,
            reorder_page_callback=self.on_page_reordered
        )

        # Secondary notebooks
        self.interests = Interests(self)
        self.chatrooms = ChatRooms(self)
        self.search = Searches(self)
        self.downloads = Downloads(self)
        self.uploads = Uploads(self)
        self.buddies = Buddies(self)
        self.privatechat = PrivateChats(self)
        self.userinfo = UserInfos(self)
        self.userbrowse = UserBrowses(self)

        self.tabs = {
            "chatrooms": self.chatrooms,
            "downloads": self.downloads,
            "interests": self.interests,
            "private": self.privatechat,
            "search": self.search,
            "uploads": self.uploads,
            "userbrowse": self.userbrowse,
            "userinfo": self.userinfo,
            "userlist": self.buddies
        }

        # Actions and menu
        self.set_up_actions()
        self.set_up_menu()

        # Tab visibility/order
        self.append_main_tabs()
        self.set_tab_positions()
        self.set_main_tabs_order()
        self.set_main_tabs_visibility()
        self.set_last_session_tab()
        self.connect_tab_signals()

        # Apply UI customizations
        set_global_style(self.application.isolated_mode)

        # Show window
        self.init_window()

    # Initialize #

    def init_window(self):

        isolated_mode = self.application.isolated_mode

        # Set main window title and icon
        self.set_title(pynicotine.__application_name__)
        self.widget.set_default_icon_name(pynicotine.__application_id__)

        # Set main window size
        self.widget.set_default_size(
            width=0 if isolated_mode else config.sections["ui"]["width"],
            height=0 if isolated_mode else config.sections["ui"]["height"]
        )

        # Hide close button in isolated_mode mode (e.g. Broadway backend)
        if isolated_mode:
            self.widget.set_deletable(False)

            if os.environ.get("GDK_BACKEND") == "broadway":
                self.widget.set_resizable(False)

        # Set main window position
        elif GTK_API_VERSION == 3:
            x_pos = config.sections["ui"]["xposition"]
            y_pos = config.sections["ui"]["yposition"]

            if x_pos == -1 and y_pos == -1:
                self.widget.set_position(Gtk.WindowPosition.CENTER)  # pylint: disable=c-extension-no-member
            else:
                self.widget.move(x_pos, y_pos)

        # Maximize main window if necessary
        if config.sections["ui"]["maximized"] or isolated_mode:
            self.widget.maximize()

        # Auto-away mode
        if GTK_API_VERSION >= 4:
            self.gesture_click = Gtk.GestureClick()
            self.widget.add_controller(self.gesture_click)

            key_controller = Gtk.EventControllerKey()
            key_controller.set_propagation_phase(Gtk.PropagationPhase.CAPTURE)
            key_controller.connect("key-released", self.on_cancel_auto_away)
            self.widget.add_controller(key_controller)

        else:
            self.gesture_click = Gtk.GestureMultiPress(widget=self.widget)  # pylint: disable=c-extension-no-member
            self.widget.connect("key-release-event", self.on_cancel_auto_away)

        self.gesture_click.set_button(0)
        self.gesture_click.set_propagation_phase(Gtk.PropagationPhase.CAPTURE)
        self.gesture_click.connect("pressed", self.on_cancel_auto_away)

        # Clear notifications when main window is focused
        self.window_active_handler = self.widget.connect("notify::is-active", self.on_window_active_changed)
        self.window_visible_handler = self.widget.connect("notify::visible", self.on_window_visible_changed)

        # System window close (X) and fullscreen
        if GTK_API_VERSION >= 4:
            self.widget.connect("close-request", self.on_close_window_request)
            self.widget.connect("notify::fullscreened", self.on_window_fullscreen_changed_gtk4)
        else:
            self.widget.connect("delete-event", self.on_close_window_request)
            self.widget.connect("window-state-event", self.on_window_state_changed_gtk3)

        self.application.add_window(self.widget)

    def set_help_overlay(self, help_overlay):
        self.widget.set_help_overlay(help_overlay)

    # Window State #

    def on_window_active_changed(self, *_args):

        self.save_window_state()

        if not self.is_active():
            return

        self.chatrooms.clear_notifications()
        self.privatechat.clear_notifications()
        self.on_cancel_auto_away()

        self.set_urgency_hint(False)

    def on_window_fullscreen_changed_gtk4(self, *_args):
        self.is_fullscreen = self.widget.is_fullscreen()
        self.toggle_fullscreen_toolbar()

    def on_window_state_changed_gtk3(self, _window, event):

        if not event.changed_mask & Gdk.WindowState.FULLSCREEN:  # pylint: disable=c-extension-no-member
            return

        self.is_fullscreen = (
            event.new_window_state & Gdk.WindowState.FULLSCREEN  # pylint: disable=c-extension-no-member
        )
        self.toggle_fullscreen_toolbar()

    def on_window_visible_changed(self, *_args):
        self.application.tray_icon.update()

    def update_title(self):

        notification_text = ""

        if not config.sections["notifications"]["notification_window_title"]:
            # Reset Title
            pass

        elif self.privatechat.highlighted_users:
            # Private Chats have a higher priority
            user = self.privatechat.highlighted_users[-1]
            notification_text = _("Private Message from %(user)s") % {"user": user}
            self.set_urgency_hint(True)

        elif self.chatrooms.highlighted_rooms:
            # Allow for the possibility the username is not available
            room, user = list(self.chatrooms.highlighted_rooms.items())[-1]
            notification_text = _("Mentioned by %(user)s in Room %(room)s") % {"user": user, "room": room}
            self.set_urgency_hint(True)

        elif any(is_important for is_important in self.search.unread_pages.values()):
            notification_text = _("Wishlist Results Found")

        if not notification_text:
            self.set_title(pynicotine.__application_name__)
            return

        self.set_title(f"{pynicotine.__application_name__} - {notification_text}")

    def set_urgency_hint(self, enabled):

        surface = self.get_surface()
        is_active = self.is_active()

        try:
            surface.set_urgency_hint(enabled and not is_active)

        except AttributeError:
            # No support for urgency hints
            pass

    def save_window_state(self):

        config.sections["ui"]["maximized"] = self.is_maximized()

        if config.sections["ui"]["maximized"]:
            return

        width = self.get_width()
        height = self.get_height()

        if width <= 0 or height <= 0:
            return

        config.sections["ui"]["width"] = width
        config.sections["ui"]["height"] = height

        position = self.get_position()

        if position is None:
            return

        x_pos, y_pos = position

        config.sections["ui"]["xposition"] = x_pos
        config.sections["ui"]["yposition"] = y_pos

    # Actions #

    def add_action(self, action):
        self.widget.add_action(action)

    def lookup_action(self, action_name):
        return self.widget.lookup_action(action_name)

    def set_up_actions(self):

        # Main

        if GTK_API_VERSION == 3:
            action = Gio.SimpleAction(name="main-menu")
            action.connect("activate", self.on_menu)
            self.add_action(action)

        action = Gio.SimpleAction(name="change-focus-view")
        action.connect("activate", self.on_change_focus_view)
        self.add_action(action)

        action = Gio.SimpleAction(name="toggle-status")
        action.connect("activate", self.on_toggle_status)
        self.add_action(action)

        # View

        state = GLib.Variant.new_boolean(not config.sections["logging"]["logcollapsed"])
        action = Gio.SimpleAction(name="show-log-pane", state=state)
        action.connect("change-state", self.on_show_log_pane)
        self.add_action(action)

        # Search

        state = GLib.Variant.new_string("global")
        action = Gio.SimpleAction(name="search-mode", parameter_type=state.get_type(), state=state)
        action.connect("change-state", self.search.on_search_mode)
        self.add_action(action)

        # Notebook Tabs

        action = Gio.SimpleAction(name="reopen-closed-tab")
        action.connect("activate", self.on_reopen_closed_tab)
        self.add_action(action)

        action = Gio.SimpleAction(name="close-tab")
        action.connect("activate", self.on_close_tab)
        self.add_action(action)

        action = Gio.SimpleAction(name="cycle-tabs")
        action.connect("activate", self.on_cycle_tabs)
        self.add_action(action)

        action = Gio.SimpleAction(name="cycle-tabs-reverse")
        action.connect("activate", self.on_cycle_tabs, True)
        self.add_action(action)

        for num in range(1, 10):
            action = Gio.SimpleAction(name=f"primary-tab-{num}")
            action.connect("activate", self.on_change_primary_tab, num)
            self.add_action(action)

    # Primary Menus #

    def set_up_menu(self):

        menu = self.application.create_hamburger_menu()
        menu.set_menu_button(self.header_menu)

        if GTK_API_VERSION == 3:
            return

        # F10 shortcut to open menu
        self.header_menu.set_primary(True)

        # Ensure menu button always gets focus after closing menu (fixed in GTK 4.16)
        if (GTK_API_VERSION, GTK_MINOR_VERSION) < (4, 16):
            popover = self.header_menu.get_popover()
            popover.connect("closed", lambda *_args: self.header_menu.grab_focus())

    def on_menu(self, *_args):
        self.header_menu.set_active(not self.header_menu.get_active())

    # Headerbar/Toolbar #

    def show_header_bar(self, page_id, leaving_fullscreen=False):
        """Set a headerbar for the main window (client side decorations
        enabled)"""

        if leaving_fullscreen or self.widget.get_titlebar() != self.header_bar:
            if not leaving_fullscreen:
                self.widget.set_titlebar(self.header_bar)

            self.widget.set_show_menubar(False)

            if GTK_API_VERSION == 3:
                self.lookup_action("main-menu").set_enabled(True)

                # Avoid "Untitled window" in certain desktop environments
                self.header_bar.set_title(self.widget.get_title())

        title_widget = self.tabs[page_id].toolbar_start_content
        title_widget.get_parent().remove(title_widget)

        end_widget = self.tabs[page_id].toolbar_end_content
        end_widget.get_parent().remove(end_widget)

        for widget in end_widget:
            # Themes decide if header bar buttons should be flat
            if isinstance(widget, Gtk.Button):
                remove_css_class(widget, "flat")

            # Header bars never contain separators, hide them
            elif isinstance(widget, Gtk.Separator):
                widget.set_visible(False)

        if GTK_API_VERSION >= 4:
            self.header_title.append(title_widget)
            self.header_end_container.append(end_widget)
        else:
            self.header_title.add(title_widget)
            self.header_end_container.add(end_widget)

    def hide_current_header_bar(self):
        """Hide the current CSD headerbar."""

        if not self.current_page_id:
            return

        if self.header_bar.get_focus_child():
            # Unfocus the header bar
            self.notebook.grab_focus()

        title_widget = self.tabs[self.current_page_id].toolbar_start_content
        end_widget = self.tabs[self.current_page_id].toolbar_end_content
        self.header_title.remove(title_widget)
        self.header_end_container.remove(end_widget)

        toolbar = self.tabs[self.current_page_id].toolbar
        toolbar_content = next(iter(toolbar))

        if GTK_API_VERSION >= 4:
            toolbar_content.append(title_widget)
            toolbar_content.append(end_widget)
        else:
            toolbar_content.add(title_widget)
            toolbar_content.add(end_widget)

    def show_toolbar(self, page_id, entering_fullscreen=False):
        """Show the non-CSD toolbar."""

        if not self.widget.get_show_menubar():
            self.widget.set_show_menubar(True)
            self.header_menu.get_popover().set_visible(False)

            if GTK_API_VERSION == 3:
                # Don't override builtin accelerator for menu bar
                self.lookup_action("main-menu").set_enabled(False)

            if not entering_fullscreen and self.widget.get_titlebar():
                self.widget.unrealize()
                self.widget.set_titlebar(None)
                self.widget.map()

        for widget in self.tabs[page_id].toolbar_end_content:
            # Make secondary buttons at the end of the toolbar flat. Keep buttons
            # next to text entries raised for more prominence.
            if isinstance(widget, Gtk.Button):
                add_css_class(widget, "flat")

            elif isinstance(widget, Gtk.Separator):
                widget.set_visible(True)

        toolbar = self.tabs[page_id].toolbar
        toolbar.set_visible(True)

    def hide_current_toolbar(self):
        """Hide the current toolbar."""

        if not self.current_page_id:
            return

        toolbar = self.tabs[self.current_page_id].toolbar
        toolbar.set_visible(False)

    def set_active_header_bar(self, page_id):
        """Switch out the active headerbar for another one.

        This is used when changing the active notebook tab.
        """

        if config.sections["ui"]["header_bar"] and not self.is_fullscreen:
            self.hide_current_header_bar()
            self.show_header_bar(page_id)
        else:
            self.hide_current_toolbar()
            self.show_toolbar(page_id)

        self.current_page_id = config.sections["ui"]["last_tab_id"] = page_id

    def _show_dialogs(self, dialogs):
        for dialog in dialogs:
            dialog.present()

    def set_use_header_bar(self, enabled):

        if enabled == (not self.widget.get_show_menubar()):
            return

        active_dialogs = Window.active_dialogs

        # Hide active dialogs to prevent parenting issues
        for dialog in reversed(active_dialogs):
            dialog.hide()

        # Toggle header bar
        if enabled:
            self.hide_current_toolbar()
            self.show_header_bar(self.current_page_id)
        else:
            self.hide_current_header_bar()
            self.show_toolbar(self.current_page_id)

        set_use_header_bar(enabled)
        config.sections["ui"]["header_bar"] = enabled

        # Show active dialogs again after a slight delay
        if active_dialogs:
            GLib.idle_add(self._show_dialogs, active_dialogs, priority=GLib.PRIORITY_HIGH_IDLE)

    def toggle_fullscreen_toolbar(self):

        if not config.sections["ui"]["header_bar"]:
            return

        if self.is_fullscreen:
            self.hide_current_header_bar()
            self.show_toolbar(self.current_page_id, entering_fullscreen=True)
            return

        self.hide_current_toolbar()
        self.show_header_bar(self.current_page_id, leaving_fullscreen=True)

    def on_change_focus_view(self, *_args):
        """F6 - move focus between header bar/toolbar and main content."""

        tab = self.tabs[self.current_page_id]
        title_widget = tab.toolbar_start_content

        # Find the correct widget to focus in the main view
        if title_widget.get_focus_child():
            if isinstance(tab, IconNotebook):
                # Attempt to focus a widget in a secondary notebook
                notebook = tab
                secondary_page = notebook.get_current_page()

                if secondary_page is not None:
                    # Found a focusable widget
                    secondary_page.focus_callback()
                    return
            else:
                # No notebook present, attempt to focus the main content widget
                page_container = next(iter(tab.page))
                content_widget = list(page_container)[-1]

                if content_widget.child_focus(Gtk.DirectionType.TAB_FORWARD):
                    # Found a focusable widget
                    return

        # Find the correct widget to focus in the header bar/toolbar
        if tab.toolbar_default_widget is not None:
            tab.toolbar_default_widget.grab_focus()

    # Main Notebook #

    def append_main_tabs(self):

        for tab_id, tab_text, tab_icon_name in (
            ("search", _("Search Files"), "system-search-symbolic"),
            ("downloads", _("Downloads"), "folder-download-symbolic"),
            ("uploads", _("Uploads"), "emblem-shared-symbolic"),
            ("userbrowse", _("Browse Shares"), "folder-symbolic"),
            ("userinfo", _("User Profiles"), "avatar-default-symbolic"),
            ("private", _("Private Chat"), "mail-unread-symbolic"),
            ("userlist", _("Buddies"), "system-users-symbolic"),
            ("chatrooms", _("Chat Rooms"), "user-available-symbolic"),
            ("interests", _("Interests"), "emblem-default-symbolic")
        ):
            tab = self.tabs[tab_id]
            self.notebook.append_page(tab.page, tab_text, focus_callback=tab.on_focus)

            tab_label = self.notebook.get_tab_label(tab.page)
            tab_label.set_start_icon_name(tab_icon_name)
            self.notebook.set_tab_reorderable(tab.page, True)
            self.set_tab_expand(tab.page)

    def connect_tab_signals(self):

        self.notebook.connect_signals()
        self.chatrooms.connect_signals()
        self.search.connect_signals()
        self.privatechat.connect_signals()
        self.userinfo.connect_signals()
        self.userbrowse.connect_signals()

    def on_switch_page(self, _notebook, page, _page_num):
        self.set_active_header_bar(page.id)

    def on_page_reordered(self, *_args):

        page_ids = []

        for i in range(self.notebook.get_n_pages()):
            page = self.notebook.get_nth_page(i)
            page_ids.append(page.id)

        config.sections["ui"]["modes_order"] = page_ids

    def on_reopen_closed_tab(self, *_args):
        """Ctrl+Shift+T - reopen recently closed tab."""

        tab = self.tabs[self.current_page_id]

        if not isinstance(tab, IconNotebook):
            return False

        notebook = tab
        notebook.restore_removed_page()
        return True

    def on_close_tab(self, *_args):
        """Ctrl+W and Ctrl+F4 - close current secondary tab."""

        tab = self.tabs[self.current_page_id]

        if not isinstance(tab, IconNotebook):
            return False

        notebook = tab
        secondary_page = notebook.get_current_page()

        if secondary_page is None:
            return False

        tab_label = notebook.get_tab_label(secondary_page)
        tab_label.close_callback()
        return True

    def on_cycle_tabs(self, _widget, _state, backwards=False):
        """Ctrl+Tab and Shift+Ctrl+Tab - cycle through secondary tabs."""

        tab = self.tabs[self.current_page_id]

        if not isinstance(tab, IconNotebook):
            return False

        notebook = tab
        num_pages = notebook.get_n_pages()
        current_page_num = notebook.get_current_page_num()

        if backwards:
            if current_page_num <= 0:
                notebook.set_current_page_num(num_pages - 1)
            else:
                notebook.prev_page()

            return True

        if current_page_num == (num_pages - 1):
            notebook.set_current_page_num(0)
        else:
            notebook.next_page()

        return True

    def on_change_primary_tab(self, _widget, _state, tab_num=1):
        """Alt+1-9 or Ctrl+1-9 - change main tab."""

        visible_pages = []

        for i in range(self.notebook.get_n_pages()):
            page = self.notebook.get_nth_page(i)

            if page.get_visible():
                visible_pages.append(page)

        if len(visible_pages) < tab_num:
            return False

        page_num = self.notebook.page_num(visible_pages[tab_num - 1])
        self.notebook.set_current_page_num(page_num)
        return True

    def change_main_page(self, page):
        self.show_tab(page)
        self.notebook.set_current_page(page)

    def show_tab(self, page):

        config.sections["ui"]["modes_visible"][page.id] = True
        page.set_visible(True)

        self.content.set_visible(True)

    def hide_tab(self, page):

        config.sections["ui"]["modes_visible"][page.id] = False
        page.set_visible(False)

        if self.notebook.get_n_pages() <= 1:
            self.content.set_visible(False)

    def set_main_tabs_order(self):

        for order, page_id in enumerate(config.sections["ui"]["modes_order"]):
            tab = self.tabs.get(page_id)

            if tab is not None:
                self.notebook.reorder_child(tab.page, order)

    def set_main_tabs_visibility(self):

        visible_tab_found = False
        buddies_tab_active = (config.sections["ui"]["buddylistinchatrooms"] == "tab")

        for i in range(self.notebook.get_n_pages()):
            page = self.notebook.get_nth_page(i)

            if config.sections["ui"]["modes_visible"].get(page.id, True):
                if page.id == "userlist" and not buddies_tab_active:
                    continue

                visible_tab_found = True
                self.show_tab(page)
                continue

            self.hide_tab(page)

        if not visible_tab_found:
            # Ensure at least one tab is visible
            self.show_tab(self.search_page)

    def set_last_session_tab(self):

        if not config.sections["ui"]["tab_select_previous"]:
            return

        last_tab_id = config.sections["ui"]["last_tab_id"]
        tab = self.tabs.get(last_tab_id)

        if tab is None:
            return

        if tab.page.get_visible():
            self.notebook.set_current_page(tab.page)

    def set_tab_expand(self, page):

        tab_position = config.sections["ui"]["tabmain"]
        expand = tab_position in {"Top", "Bottom"}
        self.notebook.set_tab_expand(page, expand)

    def set_tab_positions(self):

        default_pos = Gtk.PositionType.TOP
        positions = {
            "Top": Gtk.PositionType.TOP,
            "Bottom": Gtk.PositionType.BOTTOM,
            "Left": Gtk.PositionType.LEFT,
            "Right": Gtk.PositionType.RIGHT
        }

        # Main notebook
        main_position = positions.get(config.sections["ui"]["tabmain"], default_pos)
        self.notebook.set_tab_pos(main_position)

        # Ensure title/menubar borders are visible when needed
        remove_css_class(self.widget, "menubar-border")
        remove_css_class(self.widget, "titlebar-border")

        if main_position != Gtk.PositionType.TOP:
            if config.sections["ui"]["header_bar"]:
                add_css_class(self.widget, "titlebar-border")

            add_css_class(self.widget, "menubar-border")

        # Other notebooks
        self.chatrooms.set_tab_pos(positions.get(config.sections["ui"]["tabrooms"], default_pos))
        self.privatechat.set_tab_pos(positions.get(config.sections["ui"]["tabprivate"], default_pos))
        self.userinfo.set_tab_pos(positions.get(config.sections["ui"]["tabinfo"], default_pos))
        self.userbrowse.set_tab_pos(positions.get(config.sections["ui"]["tabbrowse"], default_pos))
        self.search.set_tab_pos(positions.get(config.sections["ui"]["tabsearch"], default_pos))

    # Connection #

    def update_user_status(self, *_args):

        status = core.users.login_status
        is_away = (status == UserStatus.AWAY)

        # Away mode
        if not is_away:
            self.set_auto_away(False)
        else:
            self.remove_away_timer()

        # Status bar
        username = core.users.login_username
        icon_name = USER_STATUS_ICON_NAMES[status]
        icon_args = (Gtk.IconSize.BUTTON,) if GTK_API_VERSION == 3 else ()  # pylint: disable=no-member

        if status == UserStatus.AWAY:
            status_text = _("Away")

        elif status == UserStatus.ONLINE:
            status_text = _("Online")

        else:
            username = None
            status_text = _("Offline")

        if self.user_status_button.get_tooltip_text() != username:
            # Hide widget to keep tooltips for other widgets visible
            self.user_status_button.set_visible(False)
            self.user_status_button.set_tooltip_text(username)
            self.user_status_button.set_visible(True)

        if self.user_status_label.get_text() != status_text:
            self.user_status_icon.set_from_icon_name(icon_name, *icon_args)
            self.user_status_label.set_text(status_text)

        if self.user_status_button.get_active():
            toggle_status_action = self.lookup_action("toggle-status")

            toggle_status_action.set_enabled(False)
            self.user_status_button.set_active(False)
            toggle_status_action.set_enabled(True)

    def user_status(self, msg):
        if msg.user == core.users.login_username:
            self.update_user_status()

    # Search #

    def on_search(self, *_args):
        self.search.on_search()

    def on_search_entry_changed(self, entry, *_args):
        entry.props.secondary_icon_name = "edit-clear-symbolic" if entry.get_text() else None

    def on_search_entry_icon_press(self, entry, icon_pos, *_args):

        if icon_pos == Gtk.EntryIconPosition.SECONDARY:
            entry.set_text("")
            return

        self.on_search()

    # User Info #

    def on_show_user_profile(self, *_args):
        self.userinfo.on_show_user_profile()

    # Shares #

    def on_get_shares(self, *_args):
        self.userbrowse.on_get_shares()

    # Chat #

    def on_get_private_chat(self, *_args):
        self.privatechat.on_get_private_chat()

    def on_create_room(self, *_args):
        self.chatrooms.on_create_room()

    # Away Mode #

    def set_auto_away(self, active=True):

        if active:
            self.auto_away = True
            self.away_timer_id = None

            if core.users.login_status != UserStatus.AWAY:
                core.users.set_away_mode(True)

            return

        if self.auto_away:
            self.auto_away = False

            if core.users.login_status == UserStatus.AWAY:
                core.users.set_away_mode(False)

        # Reset away timer
        self.remove_away_timer()
        self.create_away_timer()

    def create_away_timer(self):

        if core.users.login_status != UserStatus.ONLINE:
            return

        away_interval = config.sections["server"]["autoaway"]

        if away_interval > 0:
            self.away_timer_id = events.schedule(delay=(60 * away_interval), callback=self.set_auto_away)

    def remove_away_timer(self):
        events.cancel_scheduled(self.away_timer_id)

    def on_cancel_auto_away(self, *_args):

        current_time = time.monotonic()

        if (current_time - self.away_cooldown_time) >= 5:
            self.set_auto_away(False)
            self.away_cooldown_time = current_time

    # User Actions #

    def on_add_buddy(self, *_args):
        self.buddies.on_add_buddy()

    # Log Pane #

    def create_log_context_menu(self):

        self.popup_menu_log_categories = PopupMenu(self.application)
        self.popup_menu_log_categories.add_items(
            ("$" + _("Downloads"), "app.log-downloads"),
            ("$" + _("Uploads"), "app.log-uploads"),
            ("$" + _("Search"), "app.log-searches"),
            ("$" + _("Chat"), "app.log-chat"),
            ("", None),
            ("$" + _("[Debug] Connections"), "app.log-connections"),
            ("$" + _("[Debug] Messages"), "app.log-messages"),
            ("$" + _("[Debug] Transfers"), "app.log-transfers"),
            ("$" + _("[Debug] Miscellaneous"), "app.log-miscellaneous"),
        )

        self.popup_menu_log_view = PopupMenu(self.application, self.log_view.widget, self.on_popup_menu_log)
        self.popup_menu_log_view.add_items(
            ("#" + _("_Find…"), self.on_find_log_window),
            ("", None),
            ("#" + _("_Copy"), self.log_view.on_copy_text),
            ("#" + _("Copy _All"), self.log_view.on_copy_all_text),
            ("", None)
        )
        if not self.application.isolated_mode:
            self.popup_menu_log_view.add_items(
                ("#" + _("View _Debug Logs"), self.on_view_debug_logs),
                ("#" + _("View _Transfer Logs"), self.on_view_transfer_logs),
                ("", None)
            )
        self.popup_menu_log_view.add_items(
            (">" + _("_Log Categories"), self.popup_menu_log_categories),
            ("", None),
            ("#" + _("Clear Log View"), self.on_clear_log_view)
        )

    def log_callback(self, timestamp_format, msg, title, level):
        events.invoke_main_thread(self.update_log, timestamp_format, msg, title, level)

    def update_log(self, timestamp_format, msg, title, level):

        if title:
            MessageDialog(parent=self, title=title, message=msg, selectable=True).present()

        # Keep verbose debug messages out of statusbar to make it more useful
        if level not in {"transfer", "connection", "message", "miscellaneous"}:
            self.set_status_text(msg)

        self.log_view.add_line(msg, timestamp_format=timestamp_format)

    def on_popup_menu_log(self, menu, _textview):
        menu.actions[_("_Copy")].set_enabled(self.log_view.get_has_selection())

    def on_find_log_window(self, *_args):
        self.log_search_bar.set_visible(True)

    @staticmethod
    def on_view_debug_logs(*_args):
        open_folder_path(log.debug_folder_path, create_folder=True)

    @staticmethod
    def on_view_transfer_logs(*_args):
        open_folder_path(log.transfer_folder_path, create_folder=True)

    def on_clear_log_view(self, *_args):
        self.log_view.on_clear_all_text()
        self.set_status_text("")

    def on_show_log_pane(self, action, state):

        action.set_state(state)
        visible = state.get_boolean()
        self.log_view.auto_scroll = visible

        if visible:
            self.log_view.scroll_bottom()

        config.sections["logging"]["logcollapsed"] = not visible

    # Status Bar #

    def set_status_text(self, msg):

        # Hide widget to keep tooltips for other widgets visible
        self.status_label.set_visible(False)
        self.status_label.set_text(msg)
        self.status_label.set_tooltip_text(msg)
        self.status_label.set_visible(True)

    def set_connection_stats(self, total_conns=0, **_kwargs):

        total_conns_text = repr(total_conns)

        if self.connections_label.get_text() != total_conns_text:
            self.connections_label.set_text(total_conns_text)

    def shares_preparing(self):

        label = _("Preparing Shares")

        # Hide widget to keep tooltips for other widgets visible
        self.scan_progress_container.set_visible(False)
        self.scan_progress_container.set_tooltip_text(label)
        self.scan_progress_label.set_label(label)
        self.scan_progress_container.set_visible(True)
        self.scan_progress_spinner.start()

    def shares_scanning(self, folder_count=None):

        if folder_count is not None:
            self.scan_progress_label.set_label(
                _("Scanned Folders: %s") % humanize(folder_count))
            return

        label = _("Scanning Shares")

        # Hide widget to keep tooltips for other widgets visible
        self.scan_progress_container.set_visible(False)
        self.scan_progress_container.set_tooltip_text(label)
        self.scan_progress_label.set_label(label)
        self.scan_progress_container.set_visible(True)
        self.scan_progress_spinner.start()

    def shares_ready(self, _successful):
        self.scan_progress_container.set_visible(False)
        self.scan_progress_spinner.stop()

    def on_toggle_status(self, *_args):

        if core.uploads.pending_shutdown:
            core.uploads.cancel_shutdown()
        else:
            self.application.lookup_action("away").activate()

        self.user_status_button.set_active(False)

    # Exit #

    def on_close_window_request(self, *_args):

        if not config.sections["ui"]["exitdialog"]:     # 'Quit Program'
            core.quit()

        elif config.sections["ui"]["exitdialog"] == 1:  # 'Show Confirmation Dialog'
            core.confirm_quit()

        elif config.sections["ui"]["exitdialog"] >= 2:  # 'Run in Background'
            self.hide()

        return True

    def on_quit(self, *_args):
        self.save_window_state()

    def hide(self):

        if not self.is_visible():
            return

        # Close any visible dialogs
        for dialog in reversed(Window.active_dialogs):
            dialog.close()

        # Save config, in case application is killed later
        config.write_configuration()

        # Hide window
        if sys.platform == "darwin":
            # macOS-specific way to hide the application, to ensure it is restored when clicking the dock icon
            self.hide_window_button.set_action_name("gtkinternal.hide")
            self.hide_window_button.emit("clicked")
            return

        if sys.platform == "win32":
            if GTK_API_VERSION >= 4:
                self.widget.minimize()
            else:
                self.widget.iconify()

        super().hide()

    def destroy(self):

        for tab in self.tabs.values():
            tab.destroy()

        self.notebook.destroy()
        self.log_search_bar.destroy()
        self.log_view.destroy()
        self.popup_menu_log_view.destroy()
        self.popup_menu_log_categories.destroy()

        self.widget.disconnect(self.window_active_handler)
        self.widget.disconnect(self.window_visible_handler)

        super().destroy()


===== privatechat.py =====
# SPDX-FileCopyrightText: 2020-2025 Nicotine+ Contributors
# SPDX-FileCopyrightText: 2016-2017 Michael Labouebe <gfarmerfr@free.fr>
# SPDX-FileCopyrightText: 2008-2011 quinox <quinox@users.sf.net>
# SPDX-FileCopyrightText: 2007 gallows <g4ll0ws@gmail.com>
# SPDX-FileCopyrightText: 2006-2009 daelstorm <daelstorm@gmail.com>
# SPDX-FileCopyrightText: 2003-2004 Hyriand <hyriand@thegraveyard.org>
# SPDX-License-Identifier: GPL-3.0-or-later

from gi.repository import GLib

from pynicotine.config import config
from pynicotine.core import core
from pynicotine.events import events
from pynicotine.gtkgui.application import GTK_API_VERSION
from pynicotine.gtkgui.popovers.chatcommandhelp import ChatCommandHelp
from pynicotine.gtkgui.widgets import ui
from pynicotine.gtkgui.widgets.combobox import ComboBox
from pynicotine.gtkgui.widgets.iconnotebook import IconNotebook
from pynicotine.gtkgui.widgets.popupmenu import PopupMenu
from pynicotine.gtkgui.widgets.popupmenu import UserPopupMenu
from pynicotine.gtkgui.widgets.dialogs import OptionDialog
from pynicotine.gtkgui.widgets.textentry import ChatEntry
from pynicotine.gtkgui.widgets.textentry import TextSearchBar
from pynicotine.gtkgui.widgets.textview import ChatView
from pynicotine.gtkgui.widgets.theme import add_css_class
from pynicotine.logfacility import log
from pynicotine.slskmessages import UserStatus


class PrivateChats(IconNotebook):

    def __init__(self, window):

        super().__init__(
            window,
            parent=window.private_content,
            parent_page=window.private_page,
            switch_page_callback=self.on_switch_chat,
            reorder_page_callback=self.on_reordered_page
        )

        self.page = window.private_page
        self.page.id = "private"
        self.toolbar = window.private_toolbar
        self.toolbar_start_content = window.private_title
        self.toolbar_end_content = window.private_end
        self.toolbar_default_widget = window.private_entry

        self.chat_entry = ChatEntry(
            window.application, send_message_callback=core.privatechat.send_message,
            command_callback=core.pluginhandler.trigger_private_chat_command_event,
            enable_spell_check=config.sections["ui"]["spellcheck"]
        )
        self.username_combobox = ComboBox(
            container=window.private_entry_container, has_entry=True, has_dropdown=False,
            entry=window.private_entry, visible=True
        )
        self.command_help = None
        self.highlighted_users = []

        for event_name, callback in (
            ("clear-private-messages", self.clear_messages),
            ("echo-private-message", self.echo_private_message),
            ("message-user", self.message_user),
            ("private-chat-completions", self.update_completions),
            ("private-chat-show-user", self.show_user),
            ("private-chat-remove-user", self.remove_user),
            ("quit", self.quit),
            ("server-disconnect", self.server_disconnect),
            ("server-login", self.server_login),
            ("start", self.start),
            ("user-status", self.user_status)
        ):
            events.connect(event_name, callback)

        self.freeze()

    def start(self):

        self.unfreeze()

        for username in self.window.application.chat_history.list_view.iterators:
            self.username_combobox.append(username)

    def quit(self):
        self.freeze()

    def destroy(self):

        self.chat_entry.destroy()
        self.username_combobox.destroy()

        if self.command_help is not None:
            self.command_help.destroy()

        super().destroy()

    def on_focus(self, *_args):

        if self.window.current_page_id != self.window.private_page.id:
            return True

        if self.get_n_pages():
            return True

        if self.window.private_entry.is_sensitive():
            self.window.private_entry.grab_focus()
            return True

        return False

    def on_remove_all_pages(self, *_args):
        core.privatechat.remove_all_users()

    def on_restore_removed_page(self, page_args):
        username, = page_args
        core.privatechat.show_user(username)

    def on_reordered_page(self, *_args):

        tab_order = {}

        for user, tab in self.pages.items():
            tab_position = self.page_num(tab.container)
            tab_order[tab_position] = user

        config.sections["privatechat"]["users"] = [user for tab_index, user in sorted(tab_order.items())]

    def on_switch_chat(self, _notebook, page, _page_num):

        if self.window.current_page_id != self.window.private_page.id:
            return

        for user, tab in self.pages.items():
            if tab.container != page:
                continue

            self.chat_entry.set_parent(user, tab.chat_entry_container, tab.chat_view)
            tab.update_room_user_completions()

            if self.command_help is None:
                self.command_help = ChatCommandHelp(window=self.window, interface="private_chat")

            self.command_help.set_menu_button(tab.help_button)

            if not tab.loaded:
                tab.load()

            # Remove highlight if selected tab belongs to a user in the list of highlights
            self.unhighlight_user(user)
            break

    def on_get_private_chat(self, *_args):

        username = self.window.private_entry.get_text().strip()

        if not username:
            return

        self.window.private_entry.set_text("")
        core.privatechat.show_user(username)

    def clear_messages(self, user):

        page = self.pages.get(user)

        if page is not None:
            page.chat_view.clear()

    def clear_notifications(self):

        if self.window.current_page_id != self.window.private_page.id:
            return

        page = self.get_current_page()

        for user, tab in self.pages.items():
            if tab.container == page:
                # Remove highlight
                self.unhighlight_user(user)
                break

    def user_status(self, msg):

        page = self.pages.get(msg.user)

        if page is not None:
            self.set_user_status(page.container, msg.user, msg.status)
            page.chat_view.update_user_tag(msg.user)

        if msg.user == core.users.login_username:
            for page in self.pages.values():
                # We've enabled/disabled away mode, update our username color in all chats
                page.chat_view.update_user_tag(msg.user)

    def show_user(self, user, switch_page=True, remembered=False):

        if user not in self.pages:
            self.pages[user] = page = PrivateChat(self, user)
            tab_position = -1 if remembered else 0

            self.insert_page(
                page.container, user, focus_callback=page.on_focus, close_callback=page.on_close, user=user,
                position=tab_position
            )
            page.set_label(self.get_tab_label_inner(page.container))

        if switch_page:
            self.set_current_page(self.pages[user].container)
            self.window.change_main_page(self.window.private_page)

    def remove_user(self, user):

        page = self.pages.get(user)

        if page is None:
            return

        if page.container == self.get_current_page():
            self.chat_entry.set_parent(None)

            if self.command_help is not None:
                self.command_help.set_menu_button(None)

        page.clear()
        self.remove_page(page.container, page_args=(user,))
        del self.pages[user]
        page.destroy()

        self.chat_entry.clear_unsent_message(user)

    def highlight_user(self, user):

        if not user or user in self.highlighted_users:
            return

        self.highlighted_users.append(user)
        self.window.update_title()
        self.window.application.tray_icon.update()

    def unhighlight_user(self, user):

        if user not in self.highlighted_users:
            return

        self.highlighted_users.remove(user)
        self.window.update_title()
        self.window.application.tray_icon.update()

    def echo_private_message(self, user, text, message_type):

        page = self.pages.get(user)

        if page is not None:
            page.echo_private_message(text, message_type)

    def message_user(self, msg, **_unused):

        page = self.pages.get(msg.user)

        if page is not None:
            page.message_user(msg)

    def update_completions(self, completions):

        page = self.get_current_page()

        for tab in self.pages.values():
            if tab.container == page:
                tab.update_completions(completions)
                break

    def update_widgets(self):

        self.chat_entry.set_spell_check_enabled(config.sections["ui"]["spellcheck"])

        for tab in self.pages.values():
            tab.toggle_chat_buttons()
            tab.update_tags()

    def server_login(self, msg):

        if not msg.success:
            return

        page = self.get_current_page()
        self.chat_entry.set_sensitive(True)

        for tab in self.pages.values():
            if tab.container == page:
                tab.on_focus()
                break

    def server_disconnect(self, *_args):

        self.chat_entry.set_sensitive(False)

        for user, page in self.pages.items():
            page.server_disconnect()
            self.set_user_status(page.container, user, UserStatus.OFFLINE)


class PrivateChat:

    def __init__(self, chats, user):

        (
            self.chat_entry_container,
            self.chat_view_container,
            self.container,
            self.help_button,
            self.log_toggle,
            self.search_bar
        ) = ui.load(scope=self, path="privatechat.ui")

        self.user = user
        self.chats = chats
        self.window = chats.window

        self.loaded = False
        self.offline_message = False

        self.chat_view = ChatView(
            self.chat_view_container, chat_entry=self.chats.chat_entry, editable=False,
            horizontal_margin=10, vertical_margin=5, pixels_below_lines=2,
            username_event=self.username_event
        )

        # Text Search
        self.search_bar = TextSearchBar(
            self.chat_view.widget, self.search_bar,
            controller_widget=self.container, focus_widget=self.chats.chat_entry,
            placeholder_text=_("Search chat log…")
        )

        self.log_toggle.set_active(user in config.sections["logging"]["private_chats"])
        self.toggle_chat_buttons()

        if GTK_API_VERSION >= 4:
            inner_button = next(iter(self.help_button))
            add_css_class(widget=inner_button, css_class="image-button")

        self.popup_menu_user_chat = UserPopupMenu(
            self.window.application, parent=self.chat_view.widget, connect_events=False,
            username=user, tab_name="privatechat"
        )
        self.popup_menu_user_tab = UserPopupMenu(
            self.window.application, callback=self.on_popup_menu_user, username=user,
            tab_name="privatechat"
        )

        for menu in (self.popup_menu_user_chat, self.popup_menu_user_tab):
            menu.add_items(
                ("", None),
                ("#" + _("Close All Tabs…"), self.on_close_all_tabs),
                ("#" + _("_Close Tab"), self.on_close)
            )

        self.popup_menu = PopupMenu(self.window.application, self.chat_view.widget, self.on_popup_menu_chat)
        self.popup_menu.add_items(
            ("#" + _("Find…"), self.on_find_chat_log),
            ("", None),
            ("#" + _("Copy"), self.chat_view.on_copy_text),
            ("#" + _("Copy Link"), self.chat_view.on_copy_link),
            ("#" + _("Copy All"), self.chat_view.on_copy_all_text),
            ("", None)
        )
        if not self.window.application.isolated_mode:
            self.popup_menu.add_items(
                ("#" + _("View Chat Log"), self.on_view_chat_log)
            )
        self.popup_menu.add_items(
            ("#" + _("Delete Chat Log…"), self.on_delete_chat_log),
            ("", None),
            ("#" + _("Clear Message View"), self.chat_view.on_clear_all_text),
            ("", None),
            (">" + _("User Actions"), self.popup_menu_user_tab),
        )

        self.popup_menus = (self.popup_menu, self.popup_menu_user_chat, self.popup_menu_user_tab)

        self.prepend_old_messages()

    def load(self):
        GLib.idle_add(self.read_private_log_finished)
        self.loaded = True

    def read_private_log_finished(self):

        if not hasattr(self, "chat_view"):
            # Tab was closed
            return

        self.chat_view.scroll_bottom()
        self.chat_view.auto_scroll = True

    def prepend_old_messages(self):

        log_lines = log.read_log(
            folder_path=log.private_chat_folder_path,
            basename=self.user,
            num_lines=config.sections["logging"]["readprivatelines"]
        )

        if not log_lines:
            return

        self.chat_view.prepend_log_lines(log_lines, login_username=config.sections["server"]["login"])

    def server_disconnect(self):
        self.offline_message = False
        self.chat_view.update_user_tags()

    def clear(self):
        self.chat_view.clear()
        self.chats.unhighlight_user(self.user)

    def destroy(self):

        for menu in self.popup_menus:
            menu.destroy()

        self.chat_view.destroy()
        self.search_bar.destroy()
        self.__dict__.clear()

    def set_label(self, label):
        self.popup_menu_user_tab.set_parent(label)

    def on_popup_menu_chat(self, menu, _widget):

        self.popup_menu_user_tab.toggle_user_items()

        menu.actions[_("Copy")].set_enabled(self.chat_view.get_has_selection())
        menu.actions[_("Copy Link")].set_enabled(bool(self.chat_view.get_url_for_current_pos()))

    def on_popup_menu_user(self, _menu, _widget):
        self.popup_menu_user_tab.toggle_user_items()

    def toggle_chat_buttons(self):
        self.log_toggle.set_visible(not config.sections["logging"]["privatechat"])

    def on_log_toggled(self, *_args):

        if not self.log_toggle.get_active():
            if self.user in config.sections["logging"]["private_chats"]:
                config.sections["logging"]["private_chats"].remove(self.user)
            return

        if self.user not in config.sections["logging"]["private_chats"]:
            config.sections["logging"]["private_chats"].append(self.user)

    def on_find_chat_log(self, *_args):
        self.search_bar.set_visible(True)

    def on_view_chat_log(self, *_args):
        log.open_log(log.private_chat_folder_path, self.user)

    def on_delete_chat_log_response(self, *_args):

        log.delete_log(log.private_chat_folder_path, self.user)
        self.chats.window.application.chat_history.remove_user(self.user)
        self.chats.username_combobox.remove_id(self.user)
        self.chat_view.clear()

    def on_delete_chat_log(self, *_args):

        OptionDialog(
            parent=self.window,
            title=_("Delete Logged Messages?"),
            message=_("Do you really want to permanently delete all logged messages for this user?"),
            destructive_response_id="ok",
            callback=self.on_delete_chat_log_response
        ).present()

    def _show_notification(self, text, is_mentioned=False):

        is_buddy = (self.user in core.buddies.users)

        self.chats.request_tab_changed(self.container, is_important=is_buddy or is_mentioned)

        if (self.chats.get_current_page() == self.container
                and self.window.current_page_id == self.window.private_page.id and self.window.is_active()):
            # Don't show notifications if the chat is open and the window is in use
            return

        # Update tray icon and show urgency hint
        self.chats.highlight_user(self.user)

        if config.sections["notifications"]["notification_popup_private_message"]:
            core.notifications.show_private_chat_notification(
                self.user, text,
                title=_("Private Message from %(user)s") % {"user": self.user}
            )

    def message_user(self, msg):

        is_outgoing_message = (msg.message_id is None)
        is_new_message = msg.is_new_message
        message_type = msg.message_type

        username = msg.user
        tag_username = (core.users.login_username if is_outgoing_message else username)

        timestamp = msg.timestamp if not is_new_message else None
        timestamp_format = config.sections["logging"]["private_timestamp"]
        message = msg.message

        if not is_outgoing_message:
            self._show_notification(message, is_mentioned=(message_type == "hilite"))

        if not is_outgoing_message and not is_new_message:
            if not self.offline_message:
                self.chat_view.add_line(
                    _("* Messages sent while you were offline"), message_type="hilite",
                    timestamp_format=timestamp_format
                )
                self.offline_message = True

        else:
            self.offline_message = False

        self.chat_view.add_line(
            message, message_type=message_type, timestamp=timestamp, timestamp_format=timestamp_format,
            username=tag_username
        )
        self.chats.window.application.chat_history.update_user(username, message)
        self.chats.username_combobox.append(username)

    def echo_private_message(self, message, message_type):

        if message_type != "command":
            timestamp_format = config.sections["logging"]["private_timestamp"]
        else:
            timestamp_format = None

        self.chat_view.add_line(message, message_type=message_type, timestamp_format=timestamp_format)

    def username_event(self, pos_x, pos_y, user):

        self.popup_menu_user_chat.update_model()
        self.popup_menu_user_chat.set_user(user)
        self.popup_menu_user_chat.toggle_user_items()
        self.popup_menu_user_chat.popup(pos_x, pos_y)

    def update_tags(self):
        self.chat_view.update_tags()

    def on_focus(self, *_args):

        if self.window.current_page_id == self.window.private_page.id:
            widget = self.chats.chat_entry if self.chats.chat_entry.get_sensitive() else self.chat_view
            widget.grab_focus()

        return True

    def on_close(self, *_args):
        core.privatechat.remove_user(self.user)

    def on_close_all_tabs(self, *_args):
        self.chats.remove_all_pages()

    def update_room_user_completions(self):
        self.update_completions(core.privatechat.completions.copy())

    def update_completions(self, completions):

        # Tab-complete the recipient username
        completions.add(self.user)

        self.chats.chat_entry.set_completions(completions)


===== search.py =====
# SPDX-FileCopyrightText: 2020-2025 Nicotine+ Contributors
# SPDX-FileCopyrightText: 2016-2018 Mutnick <mutnick@techie.com>
# SPDX-FileCopyrightText: 2016-2017 Michael Labouebe <gfarmerfr@free.fr>
# SPDX-FileCopyrightText: 2008-2011 quinox <quinox@users.sf.net>
# SPDX-FileCopyrightText: 2006-2009 daelstorm <daelstorm@gmail.com>
# SPDX-FileCopyrightText: 2003-2004 Hyriand <hyriand@thegraveyard.org>
# SPDX-License-Identifier: GPL-3.0-or-later

import operator
import os
import re

from itertools import islice

from gi.repository import GLib
from gi.repository import GObject
from gi.repository import Gtk

from pynicotine.config import config
from pynicotine.core import core
from pynicotine.events import events
from pynicotine.gtkgui.application import GTK_API_VERSION
from pynicotine.gtkgui.dialogs.download import Download
from pynicotine.gtkgui.dialogs.fileproperties import FileProperties
from pynicotine.gtkgui.widgets import clipboard
from pynicotine.gtkgui.widgets import ui
from pynicotine.gtkgui.widgets.accelerator import Accelerator
from pynicotine.gtkgui.widgets.combobox import ComboBox
from pynicotine.gtkgui.widgets.iconnotebook import IconNotebook
from pynicotine.gtkgui.widgets.infobar import InfoBar
from pynicotine.gtkgui.widgets.popupmenu import PopupMenu
from pynicotine.gtkgui.widgets.popupmenu import FilePopupMenu
from pynicotine.gtkgui.widgets.popupmenu import UserPopupMenu
from pynicotine.gtkgui.widgets.theme import add_css_class
from pynicotine.gtkgui.widgets.theme import get_file_type_icon_name
from pynicotine.gtkgui.widgets.theme import get_flag_icon_name
from pynicotine.gtkgui.widgets.theme import remove_css_class
from pynicotine.gtkgui.widgets.treeview import TreeView
from pynicotine.gtkgui.widgets.treeview import create_grouping_menu
from pynicotine.logfacility import log
from pynicotine.shares import FileTypes
from pynicotine.slskmessages import FileListMessage
from pynicotine.slskmessages import UserStatus
from pynicotine.utils import factorize
from pynicotine.utils import humanize
from pynicotine.utils import human_size
from pynicotine.utils import human_speed


class SearchResultFile:
    __slots__ = ("path", "attributes")

    def __init__(self, path, attributes=None):
        self.path = path
        self.attributes = attributes


class Searches(IconNotebook):

    def __init__(self, window):

        super().__init__(
            window,
            parent=window.search_content,
            parent_page=window.search_page,
            switch_page_callback=self.on_switch_search_page
        )

        self.page = window.search_page
        self.page.id = "search"
        self.toolbar = window.search_toolbar
        self.toolbar_start_content = window.search_title
        self.toolbar_end_content = window.search_end
        self.toolbar_default_widget = window.search_entry

        self.modes = {
            "global": _("_Global"),
            "buddies": _("_Buddies"),
            "rooms": _("_Rooms"),
            "user": _("_User")
        }

        mode_menu = PopupMenu(window.application)
        mode_menu.add_items(
            ("O" + self.modes["global"], "win.search-mode", "global"),
            ("O" + self.modes["buddies"], "win.search-mode", "buddies"),
            ("O" + self.modes["rooms"], "win.search-mode", "rooms"),
            ("O" + self.modes["user"], "win.search-mode", "user")
        )
        mode_menu.update_model()
        mode_menu.set_menu_button(window.search_mode_button)
        window.search_mode_label.set_label(self.modes["global"])

        if GTK_API_VERSION >= 4:
            inner_button = next(iter(window.search_mode_button))
            add_css_class(inner_button, "arrow-button")

        self.room_search_combobox = ComboBox(
            container=self.window.search_title, has_entry=True,
            entry=self.window.room_search_entry, visible=False
        )

        self.user_search_combobox = ComboBox(
            container=self.window.search_title, has_entry=True,
            entry=self.window.user_search_entry, visible=False
        )

        self.search_combobox = ComboBox(
            container=self.window.search_title, has_entry=True,
            entry=self.window.search_entry
        )

        self.download_dialog = None
        self.file_properties = None

        for event_name, callback in (
            ("add-search", self.add_search),
            ("add-wish", self.update_wish_button),
            ("file-search-response", self.file_search_response),
            ("quit", self.quit),
            ("remove-search", self.remove_search),
            ("remove-wish", self.update_wish_button),
            ("show-search", self.show_search)
        ):
            events.connect(event_name, callback)

        self.populate_search_history()

    def quit(self):
        self.freeze()

    def destroy(self):

        self.room_search_combobox.destroy()
        self.user_search_combobox.destroy()
        self.search_combobox.destroy()

        if self.download_dialog is not None:
            self.download_dialog.destroy()

        if self.file_properties is not None:
            self.file_properties.destroy()

        super().destroy()

    def on_focus(self, *_args):

        if self.window.current_page_id != self.window.search_page.id:
            return True

        self.window.search_entry.grab_focus()
        return True

    def on_restore_removed_page(self, page_args):
        search_term, mode, room, users = page_args
        core.search.do_search(search_term, mode, room=room, users=users)

    def on_remove_all_pages(self, *_args):
        core.search.remove_all_searches()

    def on_switch_search_page(self, _notebook, page, _page_num):

        if self.window.current_page_id != self.window.search_page.id:
            return

        for tab in self.pages.values():
            if tab.container != page:
                continue

            self.window.update_title()
            break

    def on_search_mode(self, action, state):

        action.set_state(state)
        search_mode = state.get_string()

        self.window.search_mode_label.set_label(self.modes[search_mode])

        self.user_search_combobox.set_visible(search_mode == "user")
        self.room_search_combobox.set_visible(search_mode == "rooms")

        # Hide popover after click
        self.window.search_mode_button.get_popover().set_visible(False)

    def on_search(self):

        text = self.window.search_entry.get_text().strip()

        if not text:
            return

        mode = self.window.lookup_action("search-mode").get_state().get_string()
        room = self.room_search_combobox.get_text()
        user = self.user_search_combobox.get_text()
        users = [user] if user else []

        if mode == "rooms" and not room:
            return

        self.window.search_entry.set_text("")
        core.search.do_search(text, mode, room=room, users=users)

    def populate_search_history(self):

        self.search_combobox.freeze()

        if not config.sections["searches"]["enable_history"]:
            self.search_combobox.clear()
        else:
            for term in islice(config.sections["searches"]["history"], core.search.SEARCH_HISTORY_LIMIT):
                self.search_combobox.append(str(term))

        self.search_combobox.unfreeze()

    def add_search_history_item(self, term):

        if not config.sections["searches"]["enable_history"]:
            return

        self.search_combobox.remove_id(term)
        self.search_combobox.prepend(term)

        while self.search_combobox.get_num_items() > core.search.SEARCH_HISTORY_LIMIT:
            self.search_combobox.remove_pos(-1)

    def create_page(self, token, text, mode=None, mode_label=None, room=None, users=None,
                    show_page=True):

        page = self.pages.get(token)

        if page is None:
            self.pages[token] = page = Search(
                self, text=text, token=token, mode=mode, mode_label=mode_label,
                room=room, users=users, show_page=show_page)
        else:
            mode_label = page.mode_label

        if not show_page:
            return page

        if mode_label is not None:
            text = f"({mode_label}) {text}"

        self.append_page(page.container, text, focus_callback=page.on_focus,
                         close_callback=page.on_close)
        page.set_label(self.get_tab_label_inner(page.container))

        return page

    def add_search(self, token, search, switch_page=True):

        mode = search.mode
        mode_label = None
        room = search.room
        users = search.users

        if mode == "rooms":
            mode_label = room.strip() if room else ""

        elif mode == "user":
            mode_label = ",".join(users)

        elif mode == "buddies":
            mode_label = _("Buddies")

        page = self.create_page(token, search.term_sanitized, mode, mode_label, room=room, users=users)

        if switch_page:
            self.show_search(token)

        page.show_error_message()
        self.add_search_history_item(search.term_sanitized)

    def show_search(self, token):

        page = self.pages.get(token)

        if page is None:
            return

        self.set_current_page(page.container)
        self.window.change_main_page(self.window.search_page)

    def remove_search(self, token):

        page = self.pages.get(token)

        if page is None:
            return

        page.clear()

        if page.show_page:
            mode = page.mode

            if mode == "wishlist":
                # For simplicity's sake, turn wishlist tabs into regular ones when restored
                mode = "global"

            self.remove_page(page.container, page_args=(page.text, mode, page.room, page.searched_users))

        del self.pages[token]
        page.destroy()

    def clear_search_history(self):

        self.search_combobox.freeze()
        self.window.search_entry.set_text("")

        config.sections["searches"]["history"] = []
        config.write_configuration()

        self.search_combobox.clear()
        self.search_combobox.unfreeze()

    def add_filter_history_item(self, filter_id, value):
        for page in self.pages.values():
            page.add_filter_history_item(filter_id, value)

    def clear_filter_history(self):

        # Clear filter history in config
        for filter_id in ("filterin", "filterout", "filtertype", "filtersize", "filterbr", "filterlength", "filtercc"):
            config.sections["searches"][filter_id] = []

        config.write_configuration()

        # Update filters in search tabs
        for page in self.pages.values():
            page.filters_undo = page.FILTERS_EMPTY
            page.populate_filter_history()

    def file_search_response(self, msg):

        page = self.pages.get(msg.token)

        if page is None:
            search_item = core.search.searches.get(msg.token)

            if search_item is None:
                return

            search_term = search_item.term
            mode = "wishlist"
            mode_label = _("Wish")
            page = self.create_page(msg.token, search_term, mode, mode_label, show_page=False)

        # No more things to add because we've reached the result limit
        if page.num_results_found >= config.sections["searches"]["max_displayed_results"]:
            core.search.remove_allowed_token(msg.token)
            page.update_result_counter()
            return

        page.file_search_response(msg)

    def update_wish_button(self, wish):

        for page in self.pages.values():
            if page.text == wish:
                page.update_wish_button()


class Search:

    FILTER_GENERIC_FILE_TYPES = (
        ("audio", FileTypes.AUDIO),
        ("executable", FileTypes.EXECUTABLE),
        ("image", FileTypes.IMAGE),
        ("video", FileTypes.VIDEO),
        ("document", FileTypes.DOCUMENT),
        ("text", FileTypes.TEXT),
        ("archive", FileTypes.ARCHIVE)
    )
    FILTER_PRESETS = {
        "filterbr": ("!0", "128 <=192", ">192 <320", "=320", ">320"),
        "filtersize": (">50MiB", ">20MiB <=50MiB", ">10MiB <=20MiB", ">5MiB <=10MiB", "<=5MiB"),
        "filtertype": ("audio", "image", "video", "document", "text", "archive", "!executable", "audio image text"),
        "filterlength": (">15:00", ">8:00 <=15:00", ">5:00 <=8:00", ">2:00 <=5:00", "<=2:00")
    }
    FILTER_SPLIT_DIGIT_PATTERN = re.compile(r"(?:[|&\s])+(?<![<>!=]\s)")  # [pipe, ampersand, space]
    FILTER_SPLIT_TEXT_PATTERN = re.compile(r"(?:[|&,;\s])+(?<!!\s)")      # [pipe, ampersand, comma, semicolon, space]
    FILTERS_EMPTY = {
        "filterin": (None, ""),
        "filterout": (None, ""),
        "filtersize": (None, ""),
        "filterbr": (None, ""),
        "filterslot": (False, False),
        "filtercc": (None, ""),
        "filtertype": (None, ""),
        "filterlength": (None, ""),
        "filterpublic": (False, False),
    }

    def __init__(self, searches, text, token, mode, mode_label, room, users, show_page):

        (
            self.add_wish_button,
            self.add_wish_icon,
            self.add_wish_label,
            self.clear_undo_filters_button,
            self.clear_undo_filters_icon,
            self.container,
            self.expand_button,
            self.expand_icon,
            self.filter_bitrate_container,
            self.filter_bitrate_entry,
            self.filter_country_container,
            self.filter_country_entry,
            self.filter_exclude_container,
            self.filter_exclude_entry,
            self.filter_file_size_container,
            self.filter_file_size_entry,
            self.filter_file_type_container,
            self.filter_file_type_entry,
            self.filter_free_slot_button,
            self.filter_include_container,
            self.filter_include_entry,
            self.filter_length_container,
            self.filter_length_entry,
            self.filter_public_files_button,
            self.filters_button,
            self.filters_container,
            self.filters_label,
            self.grouping_button,
            self.info_bar_container,
            self.results_button,
            self.results_label,
            self.retry_button,
            self.tree_container
        ) = ui.load(scope=self, path="search.ui")

        self.searches = searches
        self.window = searches.window

        self.text = text
        self.token = token
        self.mode = mode
        self.mode_label = mode_label
        self.room = room
        self.searched_users = users
        self.show_page = show_page
        self.initialized = False
        self.users = {}
        self.folders = {}
        self.all_data = []
        self.grouping_mode = None
        self.row_id = 0
        self.filters = {}
        self.filters_undo = self.FILTERS_EMPTY
        self.populating_filters = False
        self.refiltering = False
        self.active_filter_count = 0
        self.num_results_found = 0
        self.num_results_visible = 0

        # Use dict instead of list for faster membership checks
        self.selected_users = {}
        self.selected_results = {}

        self.info_bar = InfoBar(parent=self.info_bar_container, button=self.retry_button)

        # Combo boxes
        self.filter_include_combobox = ComboBox(
            container=self.filter_include_container, has_entry=True, has_entry_completion=False,
            entry=self.filter_include_entry, item_selected_callback=self.on_refilter)

        self.filter_exclude_combobox = ComboBox(
            container=self.filter_exclude_container, has_entry=True, has_entry_completion=False,
            entry=self.filter_exclude_entry, item_selected_callback=self.on_refilter)

        self.filter_file_type_combobox = ComboBox(
            container=self.filter_file_type_container, has_entry=True, has_entry_completion=False,
            entry=self.filter_file_type_entry, item_selected_callback=self.on_refilter)

        self.filter_file_size_combobox = ComboBox(
            container=self.filter_file_size_container, has_entry=True, has_entry_completion=False,
            entry=self.filter_file_size_entry, item_selected_callback=self.on_refilter)

        self.filter_bitrate_combobox = ComboBox(
            container=self.filter_bitrate_container, has_entry=True, has_entry_completion=False,
            entry=self.filter_bitrate_entry, item_selected_callback=self.on_refilter)

        self.filter_length_combobox = ComboBox(
            container=self.filter_length_container, has_entry=True, has_entry_completion=False,
            entry=self.filter_length_entry, item_selected_callback=self.on_refilter)

        self.filter_country_combobox = ComboBox(
            container=self.filter_country_container, has_entry=True, has_entry_completion=False,
            entry=self.filter_country_entry, item_selected_callback=self.on_refilter)

        self.tree_view = TreeView(
            self.window, parent=self.tree_container, name="file_search", persistent_sort=True,
            multi_select=True, activate_row_callback=self.on_row_activated, focus_in_callback=self.on_refilter,
            columns={
                # Visible columns
                "user": {
                    "column_type": "text",
                    "title": _("User"),
                    "width": 200,
                    "sensitive_column": "public_data"
                },
                "country": {
                    "column_type": "icon",
                    "title": _("Country"),
                    "width": 30,
                    "hide_header": True
                },
                "speed": {
                    "column_type": "number",
                    "title": _("Speed"),
                    "width": 120,
                    "sort_column": "speed_data",
                    "sensitive_column": "public_data"
                },
                "in_queue": {
                    "column_type": "number",
                    "title": _("In Queue"),
                    "width": 110,
                    "sort_column": "in_queue_data",
                    "sensitive_column": "public_data"
                },
                "private": {
                    "column_type": "icon",
                    "title": _("Private"),
                    "width": 35,
                    "sort_column": "public_data",
                    "hide_header": True,
                    "sensitive_column": "public_data"
                },
                "folder": {
                    "column_type": "text",
                    "title": _("Folder"),
                    "width": 200,
                    "expand_column": True,
                    "sensitive_column": "public_data",
                    "tooltip_callback": self.on_file_path_tooltip
                },
                "file_type": {
                    "column_type": "icon",
                    "title": _("File Type"),
                    "width": 40,
                    "hide_header": True,
                    "sensitive_column": "public_data"
                },
                "filename": {
                    "column_type": "text",
                    "title": _("Filename"),
                    "width": 200,
                    "expand_column": True,
                    "sensitive_column": "public_data",
                    "tooltip_callback": self.on_file_path_tooltip
                },
                "size": {
                    "column_type": "number",
                    "title": _("Size"),
                    "width": 180,
                    "sort_column": "size_data",
                    "sensitive_column": "public_data"
                },
                "quality": {
                    "column_type": "number",
                    "title": _("Quality"),
                    "width": 150,
                    "sort_column": "bitrate_data",
                    "sensitive_column": "public_data"
                },
                "length": {
                    "column_type": "number",
                    "title": _("Duration"),
                    "width": 100,
                    "sort_column": "length_data",
                    "sensitive_column": "public_data"
                },

                # Hidden data columns
                "speed_data": {"data_type": GObject.TYPE_UINT},
                "in_queue_data": {"data_type": GObject.TYPE_UINT},
                "size_data": {"data_type": GObject.TYPE_UINT64},
                "bitrate_data": {"data_type": GObject.TYPE_UINT},
                "length_data": {"data_type": GObject.TYPE_UINT},
                "public_data": {"data_type": GObject.TYPE_BOOLEAN},
                "file_data": {"data_type": GObject.TYPE_PYOBJECT},
                "id_data": {
                    "data_type": GObject.TYPE_INT,
                    "default_sort_type": "ascending",
                    "iterator_key": True
                }
            }
        )

        # Popup menus
        self.popup_menu_users = UserPopupMenu(self.window.application, tab_name="search")

        self.popup_menu_copy = PopupMenu(self.window.application)
        self.popup_menu_copy.add_items(
            ("#" + _("Copy File Path"), self.on_copy_file_path),
            ("#" + _("Copy File URL"), self.on_copy_file_url),
            ("#" + _("Copy Folder URL"), self.on_copy_folder_url)
        )

        self.popup_menu = FilePopupMenu(
            self.window.application, parent=self.tree_view.widget, callback=self.on_popup_menu
        )
        self.popup_menu.add_items(
            ("#" + _("Download _File(s)"), self.on_download_files),
            ("#" + _("_Download Folder(s)…"), self.on_download_folders),
            ("", None),
            ("#" + _("F_ile Properties"), self.on_file_properties),
            ("", None),
            ("#" + _("View User _Profile"), self.on_user_profile),
            ("#" + _("_Browse Folder"), self.on_browse_folder),
            ("", None),
            (">" + _("_Copy"), self.popup_menu_copy),
            (">" + _("User Actions"), self.popup_menu_users)
        )

        self.tab_menu = PopupMenu(self.window.application)
        self.tab_menu.add_items(
            ("#" + _("Edit…"), self.on_edit_search),
            ("#" + _("Search _Again"), self.on_search_again),
            ("#" + _("Copy Search Term"), self.on_copy_search_term),
            ("", None),
            ("#" + _("Clear All Results"), self.on_clear),
            ("", None),
            ("#" + _("Close All Tabs…"), self.on_close_all_tabs),
            ("#" + _("_Close Tab"), self.on_close)
        )

        self.popup_menus = (
            self.popup_menu, self.popup_menu_users, self.popup_menu_copy, self.tab_menu
        )

        # Key bindings
        for widget in (self.container, self.tree_view.widget):
            Accelerator("<Primary>f", widget, self.on_show_filter_bar_accelerator)

        Accelerator("Escape", self.filters_container, self.on_close_filter_bar_accelerator)
        Accelerator("<Alt>Return", self.tree_view.widget, self.on_file_properties_accelerator)

        # Grouping
        menu = create_grouping_menu(self.window, config.sections["searches"]["group_searches"], self.on_group)
        self.grouping_button.set_menu_model(menu)

        if GTK_API_VERSION >= 4:
            inner_button = next(iter(self.grouping_button))
            add_css_class(widget=inner_button, css_class="image-button")

        # Workaround for GTK bug where clicks stop working after clicking inside popover once
        if GTK_API_VERSION >= 4 and os.environ.get("GDK_BACKEND") == "broadway":
            popover = list(self.grouping_button)[-1]
            popover.set_has_arrow(False)

        self.expand_button.set_active(config.sections["searches"]["expand_searches"])
        self.filter_public_files_button.set_visible(config.sections["searches"]["private_search_results"])

        # Filter button widgets
        self.filter_buttons = {
            "filterslot": self.filter_free_slot_button,
            "filterpublic": self.filter_public_files_button
        }

        # Filter combobox widgets
        self.filter_comboboxes = {
            "filterin": self.filter_include_combobox,
            "filterout": self.filter_exclude_combobox,
            "filtersize": self.filter_file_size_combobox,
            "filterbr": self.filter_bitrate_combobox,
            "filtercc": self.filter_country_combobox,
            "filtertype": self.filter_file_type_combobox,
            "filterlength": self.filter_length_combobox
        }

        # Filter text entry widgets
        for filter_id, combobox in self.filter_comboboxes.items():
            combobox.entry.filter_id = filter_id

            buffer = combobox.entry.get_buffer()
            buffer.connect_after("deleted-text", self.on_filter_entry_deleted_text)

            if GTK_API_VERSION == 3:
                add_css_class(combobox.dropdown, "dropdown-scrollbar")

        self.filters_button.set_active(config.sections["searches"]["filters_visible"])
        self.populate_filter_history()
        self.populate_default_filters()

        # Wishlist
        self.update_wish_button()

    def show_error_message(self):
        if core.users.statuses.get(core.users.login_username, UserStatus.OFFLINE) == UserStatus.OFFLINE:
            self.info_bar.show_error_message(_("Cannot receive search results while offline."))

    def clear(self):
        self.clear_model(stored_results=True)

    def destroy(self):

        for menu in self.popup_menus:
            menu.destroy()

        for combobox in self.filter_comboboxes.values():
            combobox.destroy()

        self.info_bar.destroy()
        self.tree_view.destroy()
        self.window.update_title()
        self.__dict__.clear()

    def set_label(self, label):
        self.tab_menu.set_parent(label)

    def update_filter_widgets(self):

        self.update_filter_counter(self.active_filter_count)

        if self.filters_undo == self.FILTERS_EMPTY:
            tooltip_text = _("Clear Filters")
            icon_name = "edit-clear-symbolic"
        else:
            tooltip_text = _("Restore Filters")
            icon_name = "edit-undo-symbolic"

        if self.clear_undo_filters_icon.get_icon_name() == icon_name:
            return

        icon_args = (Gtk.IconSize.BUTTON,) if GTK_API_VERSION == 3 else ()  # pylint: disable=no-member
        self.clear_undo_filters_button.set_tooltip_text(tooltip_text)
        self.clear_undo_filters_icon.set_from_icon_name(icon_name, *icon_args)

    def populate_filter_history(self):

        for filter_id, widget in self.filter_comboboxes.items():
            widget.freeze()
            widget.clear()

            presets = self.FILTER_PRESETS.get(filter_id)
            filter_history = config.sections["searches"][filter_id]

            if presets:
                for index, value in enumerate(presets):
                    widget.append(value, item_id=f"preset_{index}")

                if filter_history:
                    widget.append("")  # Separator

            for value in islice(filter_history, core.search.RESULT_FILTER_HISTORY_LIMIT):
                widget.append(value)

            widget.unfreeze()

    def populate_default_filters(self):

        if not config.sections["searches"]["enablefilters"]:
            return

        sfilter = config.sections["searches"]["defilter"]
        num_filters = len(sfilter)
        stored_filters = self.FILTERS_EMPTY.copy()

        # Convert from list to dict
        for i, filter_id in enumerate(stored_filters):
            if i >= num_filters:
                break

            if filter_id in self.filter_buttons:
                stored_filters[filter_id] = (False, bool(sfilter[i]))

            elif filter_id in self.filter_comboboxes:
                stored_filters[filter_id] = (None, str(sfilter[i]))

        self.set_filters(stored_filters)

    def set_filters(self, stored_filters):
        """Recall result filter values from a dict."""

        self.populating_filters = True

        for filter_id, button in self.filter_buttons.items():
            _value, h_value = stored_filters.get(filter_id, (False, False))
            button.set_active(h_value)

        for filter_id, combobox in self.filter_comboboxes.items():
            _value, h_value = stored_filters.get(filter_id, (None, ""))
            combobox.set_text(h_value)

        self.populating_filters = False

        self.on_refilter()

    def add_result_list(self, result_list, user, country_code, inqueue, ulspeed, h_speed,
                        h_queue, is_private=False):
        """Adds a list of search results to the treeview.

        Lists can either contain publicly or privately shared files.
        """

        update_ui = False
        search = core.search.searches[self.token]
        row_id = 0

        for _code, file_path, size, _ext, file_attributes, *_unused in result_list:
            if self.num_results_found >= config.sections["searches"]["max_displayed_results"]:
                break

            file_path_lower = file_path.lower()

            if any(word in file_path_lower for word in search.excluded_words):
                # Filter out results with filtered words (e.g. nicotine -music)
                log.add_debug(("Filtered out excluded search result %s from user %s for "
                               'search term "%s"'), (file_path, user, self.text))
                continue

            if not all(word in file_path_lower for word in search.included_words):
                # Certain users may send us wrong results, filter out such ones
                continue

            self.num_results_found += 1
            file_path_split = file_path.split("\\")

            if config.sections["ui"]["reverse_file_paths"]:
                # Reverse file path, file name is the first item. next() retrieves the name and removes
                # it from the iterator.
                file_path_split = reversed(file_path_split)
                name = next(file_path_split)

            else:
                # Regular file path, file name is the last item. Retrieve it and remove it from the list.
                name = file_path_split.pop()

            # Join the resulting items into a folder path
            folder_path = "\\".join(file_path_split)

            h_size = human_size(size, config.sections["ui"]["file_size_unit"])
            h_quality, bitrate, h_length, length = FileListMessage.parse_audio_quality_length(size, file_attributes)
            private_icon_name = "security-medium-symbolic" if is_private else ""

            is_result_visible = self.append(
                [
                    user,
                    get_flag_icon_name(country_code),
                    h_speed,
                    h_queue,
                    private_icon_name,
                    folder_path,
                    get_file_type_icon_name(name),
                    name,
                    h_size,
                    h_quality,
                    h_length,
                    ulspeed,
                    inqueue,
                    size,
                    bitrate,
                    length,
                    not is_private,
                    SearchResultFile(file_path, file_attributes),
                    row_id
                ]
            )

            if is_result_visible:
                update_ui = True

        return update_ui

    def file_search_response(self, msg):

        user = msg.username

        if user in self.users:
            return

        self.initialized = True

        ip_address, _port = msg.addr
        country_code = (
            core.network_filter.get_country_code(ip_address)
            or core.users.countries.get(user)
        )

        if msg.freeulslots:
            inqueue = 0
            h_queue = ""
        else:
            inqueue = msg.inqueue or 1  # Ensure value is always >= 1
            h_queue = humanize(inqueue)

        h_speed = ""
        ulspeed = msg.ulspeed or 0

        if ulspeed > 0:
            h_speed = human_speed(ulspeed)

        update_ui_private = False

        if msg.privatelist and config.sections["searches"]["private_search_results"]:
            update_ui_private = self.add_result_list(
                msg.privatelist, user, country_code, inqueue, ulspeed, h_speed, h_queue,
                is_private=True
            )

        update_ui = self.add_result_list(
            msg.list, user, country_code, inqueue, ulspeed, h_speed, h_queue) or update_ui_private

        if update_ui:
            # If this search wasn't initiated by us (e.g. wishlist), and the results aren't spoofed, show tab
            is_wish = (self.mode == "wishlist")

            if not self.show_page:
                self.searches.create_page(self.token, self.text)
                self.show_page = True

            tab_changed = self.searches.request_tab_changed(self.container, is_important=is_wish)

            if tab_changed and is_wish:
                self.window.update_title()

                if config.sections["notifications"]["notification_popup_wish"]:
                    core.notifications.show_search_notification(
                        str(self.token), self.text,
                        title=_("Wishlist Results Found")
                    )

        # Update number of results, even if they are all filtered
        self.update_result_counter()

    def append(self, row):

        self.all_data.append(row)

        if not self.check_filter(row):
            return False

        self.add_row_to_model(row)
        return True

    def add_row_to_model(self, row):

        (user, flag, h_speed, h_queue, private_icon_name, h_folder_path, _unused, _unused, _unused, _unused,
            _unused, speed, queue, _unused, _unused, _unused, is_public, file_data, _unused) = row

        expand_allowed = self.initialized
        expand_user = False
        expand_folder = False
        parent_iterator = None
        user_child_iterators = None
        user_folder_child_iterators = None

        if self.grouping_mode != "ungrouped":
            # Group by folder or user

            empty_int = 0
            empty_str = ""

            if user not in self.users:
                iterator = self.tree_view.add_row(
                    [
                        user,
                        flag,
                        h_speed,
                        h_queue,
                        empty_str,
                        empty_str,
                        empty_str,
                        empty_str,
                        empty_str,
                        empty_str,
                        empty_str,
                        speed,
                        queue,
                        empty_int,
                        empty_int,
                        empty_int,
                        is_public,
                        None,
                        self.row_id
                    ], select_row=False
                )

                if expand_allowed:
                    expand_user = self.grouping_mode == "folder_grouping" or self.expand_button.get_active()

                self.row_id += 1
                self.users[user] = (iterator, [])

            user_iterator, user_child_iterators = self.users[user]

            if self.grouping_mode == "folder_grouping":
                # Group by folder

                folder_path = file_data.path.rpartition("\\")[0]
                user_folder_path = user + folder_path

                if user_folder_path not in self.folders:
                    iterator = self.tree_view.add_row(
                        [
                            user,
                            flag,
                            h_speed,
                            h_queue,
                            private_icon_name,
                            h_folder_path,
                            empty_str,
                            empty_str,
                            empty_str,
                            empty_str,
                            empty_str,
                            speed,
                            queue,
                            empty_int,
                            empty_int,
                            empty_int,
                            is_public,
                            SearchResultFile(folder_path),
                            self.row_id
                        ], select_row=False, parent_iterator=user_iterator
                    )
                    user_child_iterators.append(iterator)
                    expand_folder = expand_allowed and self.expand_button.get_active()
                    self.row_id += 1
                    self.folders[user_folder_path] = (iterator, [])

                row = row[:]
                row[4] = row[5] = ""  # Folder not visible for file row if "group by folder" is enabled

                user_folder_iterator, user_folder_child_iterators = self.folders[user_folder_path]
                parent_iterator = user_folder_iterator

            else:
                parent_iterator = user_iterator

        else:
            if user not in self.users:
                self.users[user] = (None, [])

            user_iterator, user_child_iterators = self.users[user]

        row[18] = self.row_id
        iterator = self.tree_view.add_row(row, select_row=False, parent_iterator=parent_iterator)
        self.row_id += 1

        if user_folder_child_iterators is not None:
            user_folder_child_iterators.append(iterator)
        else:
            user_child_iterators.append(iterator)

        if expand_user:
            self.tree_view.expand_row(user_iterator)

        if expand_folder:
            self.tree_view.expand_row(user_folder_iterator)

        self.num_results_visible += 1
        return iterator

    # Result Filters #

    def add_filter_history_item(self, filter_id, value):

        combobox = self.filter_comboboxes[filter_id]
        position = len(self.FILTER_PRESETS.get(filter_id, ()))

        combobox.freeze()

        if position:
            # Separator item
            if position == combobox.get_num_items():
                combobox.append("")

            position += 1

        num_items_limit = core.search.RESULT_FILTER_HISTORY_LIMIT + position

        combobox.remove_id(value)
        combobox.insert(position=position, item=value)

        while combobox.get_num_items() > num_items_limit:
            combobox.remove_pos(-1)

        combobox.unfreeze()

    def push_history(self, filter_id, value):

        if not value:
            return

        history = config.sections["searches"].get(filter_id)

        if history is None:
            # Button filters do not store history
            return

        if history and history[0] == value:
            # Most recent item selected, nothing to do
            return

        if value in history:
            history.remove(value)

        elif len(history) >= core.search.RESULT_FILTER_HISTORY_LIMIT:
            del history[-1]

        history.insert(0, value)
        config.write_configuration()

        self.searches.add_filter_history_item(filter_id, value)

    @staticmethod
    def _split_operator(condition):
        """Returns (operation, digit)"""

        operators = {
            "<": operator.lt,
            "<=": operator.le,
            "==": operator.eq,
            "!=": operator.ne,
            ">=": operator.ge,
            ">": operator.gt
        }

        if condition.startswith((">=", "<=", "==", "!=")):
            return operators.get(condition[:2]), condition[2:]

        if condition.startswith((">", "<")):
            return operators.get(condition[:1]), condition[1:]

        if condition.startswith(("=", "!")):
            return operators.get(condition[:1] + "="), condition[1:]

        return operator.ge, condition

    def check_digit(self, result_filter, value, file_size=False):
        """Check if any conditions in result_filter match value."""

        allowed = blocked = False

        for condition in result_filter:
            operation, digit = self._split_operator(condition)

            if file_size:
                digit, factor = factorize(digit)

                if digit is None:
                    # Invalid Size unit
                    continue

                # Exact match unlikely, approximate to within +/- 0.1 MiB (or 1 MiB if over 100 MiB)
                adjust = factor / 8 if factor > 1024 and digit < 104857600 else factor  # TODO: GiB

            else:
                adjust = 0

                try:
                    # Bitrate in Kb/s or Duration in seconds
                    digit = int(digit)
                except ValueError:
                    if ":" not in digit:
                        # Invalid syntax
                        continue

                    try:
                        # Duration: Convert string from HH:MM:SS or MM:SS into Seconds as integer
                        digit = sum(x * int(t) for x, t in zip([1, 60, 3600], reversed(digit.split(":"))))
                    except ValueError:
                        # Invalid Duration unit
                        continue

            if (digit - adjust) <= value <= (digit + adjust):
                if operation is operator.eq:
                    return True

                if operation is operator.ne:
                    return False

            if value and operation(value, digit) and not blocked:
                allowed = True
                continue

            blocked = True

        return False if blocked else allowed

    @staticmethod
    def check_country(result_filter, value):

        allowed = False

        for country_code in result_filter:
            if country_code == value:
                allowed = True

            elif country_code.startswith("!") and country_code[1:] != value:
                allowed = True

            elif country_code.startswith("!") and country_code[1:] == value:
                return False

        return allowed

    @staticmethod
    def check_file_type(result_filter, value):

        allowed = False
        found_inclusive = False

        for ext in result_filter:
            exclude_ext = None

            if ext.startswith("!"):
                exclude_ext = ext[1:]

                if not exclude_ext.startswith("."):
                    exclude_ext = "." + exclude_ext

            elif not ext.startswith("."):
                ext = "." + ext

            if ext.startswith("!") and value.endswith(exclude_ext):
                return False

            if not ext.startswith("!"):
                found_inclusive = True

                if value.endswith(ext):
                    allowed = True

        if not found_inclusive:
            allowed = True

        return allowed

    def check_filter(self, row):

        if self.active_filter_count <= 0:
            return True

        for filter_id, (filter_value, _h_filter_value) in self.filters.items():
            if not filter_value:
                continue

            if filter_id == "filtertype" and not self.check_file_type(filter_value, row[17].path.lower()):
                return False

            if filter_id == "filtercc" and not self.check_country(filter_value, row[1][-2:].upper()):
                return False

            if filter_id == "filterin" and not filter_value.search(row[17].path) and not filter_value.fullmatch(row[0]):
                return False

            if filter_id == "filterout" and (filter_value.search(row[17].path) or filter_value.fullmatch(row[0])):
                return False

            if filter_id == "filterslot" and row[12] > 0:
                return False

            if filter_id == "filtersize" and not self.check_digit(filter_value, row[13], file_size=True):
                return False

            if filter_id == "filterbr" and not self.check_digit(filter_value, row[14]):
                return False

            if filter_id == "filterlength" and not self.check_digit(filter_value, row[15]):
                return False

            if filter_id == "filterpublic" and not row[16]:
                return False

        return True

    def update_filter_counter(self, count):

        if count > 0:
            self.filters_label.set_label(_("_Result Filters [%d]") % count)
        else:
            self.filters_label.set_label(_("_Result Filters"))

        self.filters_label.set_tooltip_text(_("%d active filter(s)") % count)

    def clear_model(self, stored_results=False):

        self.initialized = False

        if stored_results:
            self.all_data.clear()
            self.num_results_found = 0

        self.users.clear()
        self.folders.clear()
        self.tree_view.clear()
        self.row_id = 0
        self.num_results_visible = 0

    def update_model(self):

        self.tree_view.freeze()

        for row in self.all_data:
            if self.check_filter(row):
                self.add_row_to_model(row)

        # Update number of results
        self.update_result_counter()

        self.tree_view.unfreeze()

        if self.grouping_mode != "ungrouped":
            # Group by folder or user

            if self.expand_button.get_active():
                self.tree_view.expand_all_rows()
            else:
                self.tree_view.collapse_all_rows()

                if self.grouping_mode == "folder_grouping":
                    self.tree_view.expand_root_rows()

        self.initialized = True

    def update_wish_button(self):

        if self.mode not in {"global", "wishlist"}:
            self.add_wish_button.set_visible(False)
            return

        if not core.search.is_wish(self.text):
            icon_name = "list-add-symbolic"
            label = _("Add Wi_sh")
        else:
            icon_name = "list-remove-symbolic"
            label = _("Remove Wi_sh")

        icon_args = (Gtk.IconSize.BUTTON,) if GTK_API_VERSION == 3 else ()  # pylint: disable=no-member
        self.add_wish_icon.set_from_icon_name(icon_name, *icon_args)
        self.add_wish_label.set_label(label)

    def on_add_wish(self, *_args):

        if core.search.is_wish(self.text):
            core.search.remove_wish(self.text)
        else:
            core.search.add_wish(self.text)

    def add_popup_menu_user(self, popup, user):

        popup.add_items(
            ("", None),
            ("#" + _("Select User's Results"), self.on_select_user_results, user)
        )
        popup.update_model()
        popup.toggle_user_items()

    def populate_popup_menu_users(self):

        self.popup_menu_users.clear()

        if not self.selected_users:
            return

        # Multiple users, create submenus for some of them
        if len(self.selected_users) > 1:
            for user in islice(self.selected_users, 20):
                popup = UserPopupMenu(self.window.application, username=user, tab_name="search")
                self.add_popup_menu_user(popup, user)
                self.popup_menu_users.add_items((">" + user, popup))
                self.popup_menu_users.update_model()
            return

        # Single user, add items directly to "User Actions" submenu
        user = next(iter(self.selected_users), None)
        self.popup_menu_users.setup_user_menu(user)
        self.add_popup_menu_user(self.popup_menu_users, user)

    def on_close_filter_bar_accelerator(self, *_args):
        """Escape - hide filter bar."""

        self.filters_button.set_active(False)
        return True

    def on_show_filter_bar_accelerator(self, *_args):
        """Ctrl+F - show filter bar."""

        self.filters_button.set_active(True)
        self.filter_include_combobox.grab_focus()
        return True

    def on_file_properties_accelerator(self, *_args):
        """Alt+Return - show file properties dialog."""

        self.select_results()
        self.on_file_properties()
        return True

    def on_select_user_results(self, _action, _parameter, selected_user):

        if not self.selected_users:
            return

        _user_iterator, user_child_iterators = self.users[selected_user]

        self.tree_view.unselect_all_rows()

        for iterator in user_child_iterators:
            if self.tree_view.get_row_value(iterator, "filename"):
                self.tree_view.select_row(iterator, should_scroll=False)
                continue

            user_folder_path = selected_user + self.tree_view.get_row_value(iterator, "file_data").path
            user_folder_data = self.folders.get(user_folder_path)

            if not user_folder_data:
                continue

            _user_folder_iter, user_folder_child_iterators = user_folder_data

            for i_iterator in user_folder_child_iterators:
                self.tree_view.select_row(i_iterator, should_scroll=False)

    def select_result(self, iterator):

        user = self.tree_view.get_row_value(iterator, "user")

        if user not in self.selected_users:
            self.selected_users[user] = None

        if self.tree_view.get_row_value(iterator, "filename"):
            row_id = self.tree_view.get_row_value(iterator, "id_data")

            if row_id not in self.selected_results:
                self.selected_results[row_id] = iterator

            return

        self.select_child_results(iterator, user)

    def select_child_results(self, iterator, user):

        folder_path = self.tree_view.get_row_value(iterator, "folder")

        if folder_path:
            folder_path = self.tree_view.get_row_value(iterator, "file_data").path
            user_folder_path = user + folder_path
            row_data = self.folders[user_folder_path]
        else:
            row_data = self.users[user]

        _row_iter, child_transfers = row_data

        for i_iterator in child_transfers:
            self.select_result(i_iterator)

    def select_results(self):

        self.selected_results.clear()
        self.selected_users.clear()

        for iterator in self.tree_view.get_selected_rows():
            self.select_result(iterator)

    def update_result_counter(self):

        max_limit = config.sections["searches"]["max_displayed_results"]
        max_limited = (self.num_results_found >= max_limit)

        if max_limited or self.num_results_found > self.num_results_visible:
            # Append plus symbol "+" if Results are Filtered and/or reached 'Maximum per search'
            str_plus = "+"

            # Display total results on the tooltip, but only if we know the exact number of results
            if max_limited:
                total = f"> {max_limit}+"
            else:
                total = self.num_results_found

            self.results_button.set_tooltip_text(_("Total: %s") % total)
        else:
            str_plus = ""
            tooltip_text = _("Results")

            if self.results_button.get_tooltip_text() != tooltip_text:
                self.results_button.set_tooltip_text(tooltip_text)

        self.results_label.set_text(humanize(self.num_results_visible) + str_plus)

    def on_file_path_tooltip(self, treeview, iterator):

        file_data = treeview.get_row_value(iterator, "file_data")

        if not file_data:
            return None

        return file_data.path

    def on_row_activated(self, treeview, iterator, _column):

        self.select_results()

        folder_path = treeview.get_row_value(iterator, "folder")
        basename = treeview.get_row_value(iterator, "filename")

        if not folder_path and not basename:
            # Don't activate user rows
            return

        if not basename:
            self.on_download_folders()
        else:
            self.on_download_files()

        treeview.unselect_all_rows()

    def on_popup_menu(self, menu, _widget):

        self.select_results()
        self.populate_popup_menu_users()
        menu.set_num_selected_files(len(self.selected_results))

    def on_browse_folder(self, *_args):

        iterator = next(iter(self.selected_results.values()), None)

        if iterator is None:
            return

        user = self.tree_view.get_row_value(iterator, "user")
        path = self.tree_view.get_row_value(iterator, "file_data").path

        core.userbrowse.browse_user(user, path=path)

    def on_user_profile(self, *_args):

        iterator = next(iter(self.selected_results.values()), None)

        if iterator is None:
            return

        user = self.tree_view.get_row_value(iterator, "user")
        core.userinfo.show_user(user)

    def on_file_properties(self, *_args):

        data = []
        selected_size = 0
        selected_length = 0

        for iterator in self.selected_results.values():
            file_data = self.tree_view.get_row_value(iterator, "file_data")
            file_path = file_data.path
            file_size = self.tree_view.get_row_value(iterator, "size_data")
            selected_size += file_size
            selected_length += self.tree_view.get_row_value(iterator, "length_data")
            country_code = self.tree_view.get_row_value(iterator, "country")[-2:].upper()
            folder_path, _separator, basename = file_path.rpartition("\\")

            data.append({
                "user": self.tree_view.get_row_value(iterator, "user"),
                "file_path": file_path,
                "basename": basename,
                "virtual_folder_path": folder_path,
                "size": file_size,
                "speed": self.tree_view.get_row_value(iterator, "speed_data"),
                "queue_position": self.tree_view.get_row_value(iterator, "in_queue_data"),
                "file_attributes": file_data.attributes,
                "country_code": country_code
            })

        if data:
            if self.searches.file_properties is None:
                self.searches.file_properties = FileProperties(self.window.application)

            self.searches.file_properties.update_properties(data, selected_size, selected_length)
            self.searches.file_properties.present()

    def on_download_files(self, *_args, download_folder_path=None):

        for iterator in self.selected_results.values():
            user = self.tree_view.get_row_value(iterator, "user")
            file_data = self.tree_view.get_row_value(iterator, "file_data")
            file_path = file_data.path
            size = self.tree_view.get_row_value(iterator, "size_data")

            core.downloads.enqueue_download(
                user, file_path, folder_path=download_folder_path, size=size,
                file_attributes=file_data.attributes)

    def on_download_folders(self, *_args):

        data = []
        user_folder_paths = set()
        selected_iterators = self.selected_results.values()
        selected = True

        for iterator in selected_iterators:
            user = self.tree_view.get_row_value(iterator, "user")
            file_data = self.tree_view.get_row_value(iterator, "file_data")
            file_path = file_data.path
            size = self.tree_view.get_row_value(iterator, "size_data")
            user_folder_paths.add((user, file_path.rpartition("\\")[0]))

            data.append((user, file_path, size, file_data.attributes, selected, None))

        selected = False

        for username, folder_path in user_folder_paths:
            user_folder_path = username + folder_path

            if user_folder_path in self.folders:
                _user_folder_iter, child_iterators = self.folders[user_folder_path]
            else:
                _user_iter, child_iterators = self.users[username]

            for i_iterator in child_iterators:
                file_data = self.tree_view.get_row_value(i_iterator, "file_data")
                file_path = file_data.path
                i_folder_path = file_path.rpartition("\\")[0]

                if i_folder_path != folder_path:
                    continue

                size = self.tree_view.get_row_value(i_iterator, "size_data")
                data.append((username, file_path, size, file_data.attributes, selected, None))

        if self.searches.download_dialog is None:
            self.searches.download_dialog = Download(self.window.application)

        self.searches.download_dialog.update_files(data, select_all=True)
        self.searches.download_dialog.present()

    def on_copy_file_path(self, *_args):

        iterator = next(iter(self.selected_results.values()), None)

        if iterator is None:
            return

        file_path = self.tree_view.get_row_value(iterator, "file_data").path
        clipboard.copy_text(file_path)

    def on_copy_file_url(self, *_args):

        iterator = next(iter(self.selected_results.values()), None)

        if iterator is None:
            return

        user = self.tree_view.get_row_value(iterator, "user")
        file_path = self.tree_view.get_row_value(iterator, "file_data").path
        url = core.userbrowse.get_soulseek_url(user, file_path)
        clipboard.copy_text(url)

    def on_copy_folder_url(self, *_args):

        iterator = next(iter(self.selected_results.values()), None)

        if iterator is None:
            return

        user = self.tree_view.get_row_value(iterator, "user")
        file_path = self.tree_view.get_row_value(iterator, "file_data").path
        folder_path, separator, _basename = file_path.rpartition("\\")
        url = core.userbrowse.get_soulseek_url(user, folder_path + separator)

        clipboard.copy_text(url)

    def on_counter_button(self, *_args):

        if self.num_results_found > self.num_results_visible:
            self.on_clear_undo_filters()
        else:
            self.window.application.lookup_action("configure-searches").activate()

    def on_group(self, action, state):

        mode = state.get_string()
        active = mode != "ungrouped"
        popover = self.grouping_button.get_popover()

        if popover is not None:
            popover.set_visible(False)

        if GTK_API_VERSION >= 4:
            self.grouping_button.set_has_frame(active)
        else:
            self.grouping_button.set_relief(
                Gtk.ReliefStyle.NORMAL if active else Gtk.ReliefStyle.NONE  # pylint: disable=c-extension-no-member
            )

        config.sections["searches"]["group_searches"] = mode
        self.tree_view.set_show_expanders(active)
        self.expand_button.set_visible(active)

        self.grouping_mode = mode

        self.clear_model()
        self.tree_view.has_tree = active
        self.tree_view.create_model()
        self.update_model()

        action.set_state(state)

    def on_toggle_expand_all(self, *_args):

        active = self.expand_button.get_active()

        if active:
            icon_name = "view-restore-symbolic"
            tooltip_text = _("Collapse All")
            self.tree_view.expand_all_rows()
        else:
            icon_name = "view-fullscreen-symbolic"
            tooltip_text = _("Expand All")
            self.tree_view.collapse_all_rows()

            if self.grouping_mode == "folder_grouping":
                self.tree_view.expand_root_rows()

        icon_args = (Gtk.IconSize.BUTTON,) if GTK_API_VERSION == 3 else ()  # pylint: disable=no-member
        self.expand_icon.set_from_icon_name(icon_name, *icon_args)
        self.expand_button.set_tooltip_text(tooltip_text)

        config.sections["searches"]["expand_searches"] = active

    def on_toggle_filters(self, *_args):

        visible = self.filters_button.get_active()
        self.filters_container.set_reveal_child(visible)
        config.sections["searches"]["filters_visible"] = visible

        if visible:
            self.filter_include_combobox.grab_focus()
            return

        self.tree_view.grab_focus()

    def on_copy_search_term(self, *_args):
        clipboard.copy_text(self.text)

    def on_edit_search(self, *_args):

        if self.mode == "wishlist":
            self.window.application.lookup_action("wishlist").activate()
            return

        self.window.lookup_action("search-mode").change_state(GLib.Variant.new_string(self.mode))

        if self.mode == "room":
            self.window.room_search_entry.set_text(self.room)

        elif self.mode == "user":
            self.window.user_search_entry.set_text(self.searched_users[0])

        self.window.search_entry.set_text(self.text)
        self.window.search_entry.set_position(-1)
        self.window.search_entry.grab_focus_without_selecting()

    def on_search_again(self, *_args):

        self.info_bar.set_visible(False)
        core.search.send_search_request(self.token)
        self.show_error_message()

    def on_refilter(self, *_args):

        if self.populating_filters:
            return

        self.refiltering = True

        filter_in = filter_out = filter_size = filter_bitrate = filter_country = filter_file_type = filter_length = None
        filter_in_str = self.filter_include_combobox.get_text().strip()
        filter_out_str = self.filter_exclude_combobox.get_text().strip()
        filter_size_str = self.filter_file_size_combobox.get_text().strip()
        filter_bitrate_str = self.filter_bitrate_combobox.get_text().strip()
        filter_country_str = self.filter_country_combobox.get_text().strip()
        filter_file_type_str = self.filter_file_type_combobox.get_text().strip()
        filter_length_str = self.filter_length_combobox.get_text().strip()
        filter_free_slot = self.filter_free_slot_button.get_active()
        filter_public = self.filter_public_files_button.get_active()

        # Include/exclude text
        error_entries = set()

        if filter_in_str:
            try:
                filter_in = re.compile(filter_in_str, flags=re.IGNORECASE)
            except re.error:
                error_entries.add(self.filter_include_entry)

        if filter_out_str:
            try:
                filter_out = re.compile(filter_out_str, flags=re.IGNORECASE)
            except re.error:
                error_entries.add(self.filter_exclude_entry)

        for entry in (self.filter_include_entry, self.filter_exclude_entry):
            # Set red background if invalid regex pattern is detected
            css_class_function = add_css_class if entry in error_entries else remove_css_class
            css_class_function(entry, "error")

        # Split at | pipes ampersands & space(s) but don't split <>=! math operators spaced before digit condition
        seperator_pattern = self.FILTER_SPLIT_DIGIT_PATTERN

        if filter_size_str:
            filter_size = seperator_pattern.split(filter_size_str)

        if filter_bitrate_str:
            filter_bitrate = seperator_pattern.split(filter_bitrate_str)

        if filter_length_str:
            filter_length = seperator_pattern.split(filter_length_str)

        # Split at commas, in addition to | pipes ampersands & space(s) but don't split ! not operator before condition
        seperator_pattern = self.FILTER_SPLIT_TEXT_PATTERN

        if filter_country_str:
            filter_country = seperator_pattern.split(filter_country_str.upper())

        if filter_file_type_str:
            filter_file_type = seperator_pattern.split(filter_file_type_str.lower())

            # Replace generic file type filters with real file extensions
            for filter_name, file_extensions in self.FILTER_GENERIC_FILE_TYPES:
                excluded_filter_name = f"!{filter_name}"

                if filter_name in filter_file_type:
                    filter_file_type.remove(filter_name)
                    filter_file_type += list(file_extensions)

                elif excluded_filter_name in filter_file_type:
                    filter_file_type.remove(excluded_filter_name)
                    filter_file_type += ["!" + x for x in file_extensions]

        filters = {
            "filterin": (filter_in, filter_in_str),
            "filterout": (filter_out, filter_out_str),
            "filtersize": (filter_size, filter_size_str),
            "filterbr": (filter_bitrate, filter_bitrate_str),
            "filterslot": (filter_free_slot, filter_free_slot),
            "filtercc": (filter_country, filter_country_str),
            "filtertype": (filter_file_type, filter_file_type_str),
            "filterlength": (filter_length, filter_length_str),
            "filterpublic": (filter_public, filter_public),
        }

        if self.filters == filters:
            # Filters have not changed, no need to refilter
            self.refiltering = False
            return

        if self.filters and filters == self.FILTERS_EMPTY:
            # Filters cleared, enable Restore Filters
            self.filters_undo = self.filters
        else:
            # Filters active, enable Clear Filters
            self.filters_undo = self.FILTERS_EMPTY

        self.active_filter_count = 0

        # Add filters to history
        for filter_id, (_value, h_value) in filters.items():
            if not h_value:
                continue

            if filter_id == "filterpublic" and not config.sections["searches"]["private_search_results"]:
                continue

            self.push_history(filter_id, h_value)
            self.active_filter_count += 1

        # Apply the new filters
        self.filters = filters
        self.update_filter_widgets()
        self.clear_model()
        self.update_model()

        self.refiltering = False

    def on_filter_entry_deleted_text(self, buffer, *_args):
        if not self.refiltering and buffer.get_length() <= 0:
            self.on_refilter()

    def on_filter_entry_icon_press(self, entry, *_args):

        entry_text = entry.get_text()
        filter_id = entry.filter_id
        _filter_value, h_filter_value = self.filters.get(filter_id)

        if not entry_text:
            # Recall last filter
            history = config.sections["searches"].get(filter_id)
            recall_text = history[0] if history else ""

            entry.set_text(recall_text)
            entry.set_position(-1)
            entry.grab_focus_without_selecting()

        elif entry_text == h_filter_value:
            # Clear Filter
            entry.set_text("")
            return

        # Activate new, edited or recalled filter
        self.on_refilter()

    def on_clear_undo_filters(self, *_args):

        self.set_filters(self.filters_undo)

        if not self.filters_button.get_active():
            self.tree_view.grab_focus()

    def on_clear(self, *_args):

        self.clear_model(stored_results=True)

        # Allow parsing search result messages again
        core.search.add_allowed_token(self.token)

        # Update number of results widget
        self.update_result_counter()

    def on_focus(self, *_args):

        if not self.window.search_entry.get_text():
            # Only focus treeview if we're not entering a new search term
            self.tree_view.grab_focus()

        return True

    def on_close(self, *_args):
        core.search.remove_search(self.token)

    def on_close_all_tabs(self, *_args):
        self.searches.remove_all_pages()


===== transfers.py =====
# SPDX-FileCopyrightText: 2020-2025 Nicotine+ Contributors
# SPDX-FileCopyrightText: 2018 Mutnick <mutnick@techie.com>
# SPDX-FileCopyrightText: 2016-2017 Michael Labouebe <gfarmerfr@free.fr>
# SPDX-FileCopyrightText: 2008-2011 quinox <quinox@users.sf.net>
# SPDX-FileCopyrightText: 2009 hedonist <ak@sensi.org>
# SPDX-FileCopyrightText: 2006-2009 daelstorm <daelstorm@gmail.com>
# SPDX-FileCopyrightText: 2003-2004 Hyriand <hyriand@thegraveyard.org>
# SPDX-License-Identifier: GPL-3.0-or-later

import os

from itertools import islice

from gi.repository import GObject
from gi.repository import Gtk

from pynicotine.config import config
from pynicotine.core import core
from pynicotine.gtkgui.application import GTK_API_VERSION
from pynicotine.gtkgui.dialogs.fileproperties import FileProperties
from pynicotine.gtkgui.widgets import clipboard
from pynicotine.gtkgui.widgets import ui
from pynicotine.gtkgui.widgets.accelerator import Accelerator
from pynicotine.gtkgui.widgets.popupmenu import PopupMenu
from pynicotine.gtkgui.widgets.popupmenu import FilePopupMenu
from pynicotine.gtkgui.widgets.popupmenu import UserPopupMenu
from pynicotine.gtkgui.widgets.theme import add_css_class
from pynicotine.gtkgui.widgets.theme import get_file_type_icon_name
from pynicotine.gtkgui.widgets.theme import remove_css_class
from pynicotine.gtkgui.widgets.treeview import TreeView
from pynicotine.gtkgui.widgets.treeview import create_grouping_menu
from pynicotine.slskmessages import FileListMessage
from pynicotine.slskmessages import TransferRejectReason
from pynicotine.transfers import Transfer
from pynicotine.transfers import TransferStatus
from pynicotine.utils import UINT64_LIMIT
from pynicotine.utils import human_length
from pynicotine.utils import human_size
from pynicotine.utils import human_speed
from pynicotine.utils import humanize


class Transfers:

    STATUSES = {
        TransferStatus.QUEUED: _("Queued"),
        f"{TransferStatus.QUEUED} (prioritized)": _("Queued (prioritized)"),
        f"{TransferStatus.QUEUED} (privileged)": _("Queued (privileged)"),
        TransferStatus.GETTING_STATUS: _("Getting status"),
        TransferStatus.TRANSFERRING: _("Transferring"),
        TransferStatus.CONNECTION_CLOSED: _("Connection closed"),
        TransferStatus.CONNECTION_TIMEOUT: _("Connection timeout"),
        TransferStatus.USER_LOGGED_OFF: _("User logged off"),
        TransferStatus.PAUSED: _("Paused"),
        TransferStatus.CANCELLED: _("Cancelled"),
        TransferStatus.FINISHED: _("Finished"),
        TransferStatus.FILTERED: _("Filtered"),
        TransferStatus.DOWNLOAD_FOLDER_ERROR: _("Download folder error"),
        TransferStatus.LOCAL_FILE_ERROR: _("Local file error"),
        TransferRejectReason.BANNED: _("Banned"),
        TransferRejectReason.FILE_NOT_SHARED: _("File not shared"),
        TransferRejectReason.PENDING_SHUTDOWN: _("Pending shutdown"),
        TransferRejectReason.FILE_READ_ERROR: _("File read error")
    }
    STATUS_PRIORITIES = {
        TransferStatus.FILTERED: 0,
        TransferStatus.FINISHED: 1,
        TransferStatus.PAUSED: 2,
        TransferStatus.CANCELLED: 3,
        TransferStatus.QUEUED: 4,
        f"{TransferStatus.QUEUED} (prioritized)": 4,
        f"{TransferStatus.QUEUED} (privileged)": 4,
        TransferStatus.USER_LOGGED_OFF: 5,
        TransferStatus.CONNECTION_CLOSED: 6,
        TransferStatus.CONNECTION_TIMEOUT: 7,
        TransferRejectReason.FILE_NOT_SHARED: 8,
        TransferRejectReason.PENDING_SHUTDOWN: 9,
        TransferRejectReason.FILE_READ_ERROR: 10,
        TransferStatus.LOCAL_FILE_ERROR: 11,
        TransferStatus.DOWNLOAD_FOLDER_ERROR: 12,
        TransferRejectReason.BANNED: 13,
        TransferStatus.GETTING_STATUS: 9998,
        TransferStatus.TRANSFERRING: 9999
    }
    PENDING_ITERATOR_REBUILD = 0
    PENDING_ITERATOR_ADD = 1
    PENDING_ITERATORS = {PENDING_ITERATOR_REBUILD, PENDING_ITERATOR_ADD}
    UNKNOWN_STATUS_PRIORITY = 1000

    path_separator = path_label = retry_label = abort_label = None
    transfer_page = user_counter = file_counter = expand_button = expand_icon = grouping_button = status_label = None

    def __init__(self, window, transfer_type):

        (
            self.clear_all_button,
            self.clear_all_label,
            self.container,
            self.tree_container
        ) = ui.load(scope=self, path=f"{transfer_type}s.ui")

        self.window = window
        self.type = transfer_type

        if GTK_API_VERSION >= 4:
            inner_button = next(iter(self.clear_all_button))
            self.clear_all_button.set_has_frame(False)
            self.clear_all_label.set_mnemonic_widget(inner_button)

        self.transfer_list = {}
        self.users = {}
        self.paths = {}
        self.pending_folder_rows = set()
        self.pending_user_rows = set()
        self.grouping_mode = None
        self.row_id = 0
        self.file_properties = None
        self.initialized = False

        # Use dict instead of list for faster membership checks
        self.selected_users = {}
        self.selected_transfers = {}

        self.tree_view = TreeView(
            window, parent=self.tree_container, name=transfer_type,
            multi_select=True, persistent_sort=True, activate_row_callback=self.on_row_activated,
            delete_accelerator_callback=self.on_remove_transfers_accelerator,
            columns={
                # Visible columns
                "user": {
                    "column_type": "text",
                    "title": _("User"),
                    "width": 200,
                    "sensitive_column": "is_sensitive_data"
                },
                "path": {
                    "column_type": "text",
                    "title": self.path_label,
                    "width": 200,
                    "expand_column": True,
                    "tooltip_callback": self.on_file_path_tooltip,
                    "sensitive_column": "is_sensitive_data"
                },
                "file_type": {
                    "column_type": "icon",
                    "title": _("File Type"),
                    "width": 40,
                    "hide_header": True,
                    "sensitive_column": "is_sensitive_data"
                },
                "filename": {
                    "column_type": "text",
                    "title": _("Filename"),
                    "width": 200,
                    "expand_column": True,
                    "tooltip_callback": self.on_file_path_tooltip,
                    "sensitive_column": "is_sensitive_data"
                },
                "status": {
                    "column_type": "text",
                    "title": _("Status"),
                    "width": 140,
                    "sensitive_column": "is_sensitive_data"
                },
                "queue_position": {
                    "column_type": "number",
                    "title": _("Queue"),
                    "width": 90,
                    "sort_column": "queue_position_data"
                },
                "percent": {
                    "column_type": "progress",
                    "title": _("Percent"),
                    "width": 90,
                    "sensitive_column": "is_sensitive_data"
                },
                "size": {
                    "column_type": "number",
                    "title": _("Size"),
                    "width": 180,
                    "sort_column": "size_data",
                    "sensitive_column": "is_sensitive_data"
                },
                "speed": {
                    "column_type": "number",
                    "title": _("Speed"),
                    "width": 100,
                    "sort_column": "speed_data",
                    "sensitive_column": "is_sensitive_data"
                },
                "time_elapsed": {
                    "column_type": "number",
                    "title": _("Time Elapsed"),
                    "width": 140,
                    "sort_column": "time_elapsed_data",
                    "sensitive_column": "is_sensitive_data"
                },
                "time_left": {
                    "column_type": "number",
                    "title": _("Time Left"),
                    "width": 140,
                    "sort_column": "time_left_data",
                    "sensitive_column": "is_sensitive_data"
                },

                # Hidden data columns
                "size_data": {"data_type": GObject.TYPE_UINT64},
                "current_bytes_data": {"data_type": GObject.TYPE_UINT64},
                "speed_data": {"data_type": GObject.TYPE_UINT64},
                "queue_position_data": {"data_type": GObject.TYPE_UINT},
                "time_elapsed_data": {"data_type": GObject.TYPE_INT},
                "time_left_data": {"data_type": GObject.TYPE_UINT64},
                "is_sensitive_data": {"data_type": GObject.TYPE_BOOLEAN},
                "transfer_data": {"data_type": GObject.TYPE_PYOBJECT},
                "id_data": {
                    "data_type": GObject.TYPE_INT,
                    "default_sort_type": "ascending",
                    "iterator_key": True
                }
            }
        )

        Accelerator("t", self.tree_view.widget, self.on_abort_transfers_accelerator)
        Accelerator("r", self.tree_view.widget, self.on_retry_transfers_accelerator)
        Accelerator("<Alt>Return", self.tree_view.widget, self.on_file_properties_accelerator)

        menu = create_grouping_menu(
            window, config.sections["transfers"][f"group{transfer_type}s"], self.on_toggle_tree)
        self.grouping_button.set_menu_model(menu)

        if GTK_API_VERSION >= 4:
            inner_button = next(iter(self.grouping_button))
            add_css_class(widget=inner_button, css_class="image-button")

            # Workaround for GTK bug where clicks stop working after clicking inside popover once
            if os.environ.get("GDK_BACKEND") == "broadway":
                popover = list(self.grouping_button)[-1]
                popover.set_has_arrow(False)

        self.expand_button.connect("toggled", self.on_expand_tree)
        self.expand_button.set_active(config.sections["transfers"][f"{transfer_type}sexpanded"])

        self.popup_menu_users = UserPopupMenu(window.application, tab_name="transfers")
        self.popup_menu_clear = PopupMenu(window.application)
        self.popup_menu_clear.set_menu_button(self.clear_all_button)

        self.popup_menu_copy_search = PopupMenu(window.application)
        self.popup_menu_copy_search.add_items(
            ("#" + _("Copy File Path"), self.on_copy_file_path),
            ("#" + _("Copy File URL"), self.on_copy_file_url),
            ("#" + _("Copy Folder URL"), self.on_copy_folder_url),
            ("", None),
            ("#" + _("Search for Folder Name"), self.on_search_folder_name),
            ("#" + _("Search for File Name"), self.on_search_filename)
        )

        self.popup_menu = FilePopupMenu(
            window.application, parent=self.tree_view.widget, callback=self.on_popup_menu
        )
        if not self.window.application.isolated_mode:
            self.popup_menu.add_items(
                ("#" + _("_Open File"), self.on_open_file),
                ("#" + _("Open in File _Manager"), self.on_open_file_manager)
            )
        self.popup_menu.add_items(
            ("#" + _("F_ile Properties"), self.on_file_properties),
            ("", None),
            ("#" + self.retry_label, self.on_retry_transfer),
            ("#" + self.abort_label, self.on_abort_transfer),
            ("#" + _("Remove"), self.on_remove_transfer),
            ("", None),
            ("#" + _("View User _Profile"), self.on_user_profile),
            ("#" + _("_Browse Folder"), self.on_browse_folder),
            ("", None),
            (">" + _("_Copy & Search"), self.popup_menu_copy_search),
            (">" + _("Clear All"), self.popup_menu_clear),
            (">" + _("User Actions"), self.popup_menu_users)
        )

    def destroy(self):

        self.clear_model()
        self.tree_view.destroy()
        self.popup_menu.destroy()
        self.popup_menu_users.destroy()
        self.popup_menu_clear.destroy()
        self.popup_menu_copy_search.destroy()

        self.__dict__.clear()

    def on_focus(self, *_args):

        self.update_model()
        self.window.notebook.remove_tab_changed(self.transfer_page)

        if self.container.get_parent().get_visible():
            self.tree_view.grab_focus()
            return True

        return False

    def init_transfers(self, transfer_list):

        self.transfer_list = transfer_list

        for transfer in transfer_list:
            # Tab highlights are only used when transfers are appended, but we
            # won't create a transfer row until the tab is active. To prevent
            # spurious highlights when a previously added transfer changes, but
            # the tab wasn't activated yet (iterator is None), mark the iterator
            # as pending.
            transfer.iterator = self.PENDING_ITERATOR_REBUILD

        self.container.get_parent().set_visible(bool(transfer_list))

    def select_transfers(self):

        self.selected_transfers.clear()
        self.selected_users.clear()

        for iterator in self.tree_view.get_selected_rows():
            transfer = self.tree_view.get_row_value(iterator, "transfer_data")
            self.select_transfer(transfer, select_user=True)

    def select_child_transfers(self, transfer):

        if transfer.virtual_path is not None:
            return

        # Dummy Transfer object for user/folder rows
        user = transfer.username
        folder_path = self.get_transfer_folder_path(transfer)

        if folder_path is not None:
            user_folder_path = user + folder_path
            row_data = self.paths[user_folder_path]
        else:
            row_data = self.users[user]

        _row_iter, child_transfers = row_data

        for i_transfer in child_transfers:
            self.select_transfer(i_transfer)

    def select_transfer(self, transfer, select_user=False):

        if transfer.virtual_path is not None and transfer not in self.selected_transfers:
            self.selected_transfers[transfer] = None

        if select_user and transfer.username not in self.selected_users:
            self.selected_users[transfer.username] = None

        self.select_child_transfers(transfer)

    def on_search_filename(self, *_args):

        transfer = next(iter(self.selected_transfers), None)

        if not transfer:
            return

        _folder_path, _separator, basename = transfer.virtual_path.rpartition("\\")
        basename_no_extension, _extension = os.path.splitext(basename)

        self.window.search_entry.set_text(basename_no_extension)
        self.window.change_main_page(self.window.search_page)

    def on_search_folder_name(self, *_args):

        transfer = next(iter(self.selected_transfers), None)

        if not transfer:
            return

        folder_path, _separator, _basename = transfer.virtual_path.rpartition("\\")
        folder_name = folder_path.rpartition("\\")[-1]

        self.window.search_entry.set_text(folder_name)
        self.window.change_main_page(self.window.search_page)

    def translate_status(self, status):

        translated_status = self.STATUSES.get(status)

        if translated_status:
            return translated_status

        return status

    def update_limits(self):
        """Underline status bar bandwidth labels when alternative speed limits
        are active."""

        if config.sections["transfers"][f"use_{self.type}_speed_limit"] == "alternative":
            add_css_class(self.status_label, "underline")
            return

        remove_css_class(self.status_label, "underline")

    def update_num_users_files(self):
        self.user_counter.set_text(humanize(len(self.users)))
        self.file_counter.set_text(humanize(len(self.transfer_list)))

    def update_model(self, transfer=None, update_parent=True):

        if self.window.current_page_id != self.transfer_page.id:
            if transfer is not None and transfer.iterator is None:
                self.window.notebook.request_tab_changed(self.transfer_page)
                transfer.iterator = self.PENDING_ITERATOR_ADD

            # No need to do unnecessary work if transfers are not visible
            return

        has_disabled_sorting = False
        has_selected_parent = False
        update_counters = False
        use_reverse_file_path = config.sections["ui"]["reverse_file_paths"]

        if transfer is not None:
            update_counters = self.update_specific(transfer, use_reverse_file_path=use_reverse_file_path)

        elif self.transfer_list:
            for transfer_i in self.transfer_list:
                select_parent = (not has_selected_parent and transfer_i.iterator == self.PENDING_ITERATOR_ADD)
                row_added = self.update_specific(transfer_i, select_parent, use_reverse_file_path)

                if select_parent:
                    has_selected_parent = True

                if not row_added:
                    continue

                update_counters = True

                if not has_disabled_sorting:
                    # Optimization: disable sorting while adding rows
                    self.tree_view.freeze()
                    has_disabled_sorting = True

        if update_parent:
            self.update_parent_rows(transfer)

        if update_counters:
            self.update_num_users_files()

        if has_disabled_sorting:
            self.tree_view.unfreeze()

        if not self.initialized:
            self.on_expand_tree()
            self.initialized = True

        self.tree_view.redraw()

    def _update_pending_parent_rows(self):

        for user_folder_path in self.pending_folder_rows:
            if user_folder_path not in self.paths:
                continue

            user_folder_path_iter, user_folder_path_child_transfers = self.paths[user_folder_path]
            self.update_parent_row(
                user_folder_path_iter, user_folder_path_child_transfers, user_folder_path=user_folder_path)

        for username in self.pending_user_rows:
            if username not in self.users:
                continue

            user_iter, user_child_transfers = self.users[username]
            self.update_parent_row(user_iter, user_child_transfers, username=username)

        self.pending_folder_rows.clear()
        self.pending_user_rows.clear()

    def update_parent_rows(self, transfer=None):

        if self.grouping_mode == "ungrouped":
            return

        if transfer is not None:
            username = transfer.username

            if self.paths:
                user_folder_path = username + self.get_transfer_folder_path(transfer)
                self.pending_folder_rows.add(user_folder_path)

            self.pending_user_rows.add(username)
            return

        if self.paths:
            for user_folder_path, (user_folder_path_iter, child_transfers) in self.paths.copy().items():
                self.update_parent_row(user_folder_path_iter, child_transfers, user_folder_path=user_folder_path)

        for username, (user_iter, child_transfers) in self.users.copy().items():
            self.update_parent_row(user_iter, child_transfers, username=username)

    @staticmethod
    def get_hqueue_position(queue_position):
        return str(queue_position) if queue_position > 0 else ""

    @staticmethod
    def get_hsize(current_byte_offset, size):

        if current_byte_offset >= size:
            return human_size(size)

        return f"{human_size(current_byte_offset)} / {human_size(size)}"

    @staticmethod
    def get_hspeed(speed):
        return human_speed(speed) if speed > 0 else ""

    @staticmethod
    def get_helapsed(elapsed):
        return human_length(elapsed) if elapsed > 0 else ""

    @staticmethod
    def get_hleft(left):
        return human_length(left) if left >= 1 else ""

    @staticmethod
    def get_percent(current_byte_offset, size):

        if current_byte_offset > size or size <= 0:
            return 100

        # Multiply first to avoid decimals
        return (100 * current_byte_offset) // size

    def update_parent_row(self, iterator, child_transfers, username=None, user_folder_path=None):

        speed = 0.0
        total_size = current_byte_offset = 0
        elapsed = 0
        parent_status = TransferStatus.FINISHED

        if not child_transfers:
            # Remove parent row if no children are present anymore
            if user_folder_path:
                transfer = self.tree_view.get_row_value(iterator, "transfer_data")
                _user_iter, user_child_transfers = self.users[transfer.username]
                user_child_transfers.remove(transfer)
                del self.paths[user_folder_path]
            else:
                del self.users[username]

            self.tree_view.remove_row(iterator)

            if not self.tree_view.iterators:
                # Show tab description
                self.container.get_parent().set_visible(False)

            self.update_num_users_files()
            return

        for transfer in child_transfers:
            status = transfer.status

            if status == TransferStatus.TRANSFERRING:
                # "Transferring" status always has the highest priority
                parent_status = status
                speed += transfer.speed

            elif parent_status in self.STATUS_PRIORITIES:
                parent_status_priority = self.STATUS_PRIORITIES[parent_status]
                status_priority = self.STATUS_PRIORITIES.get(status, self.UNKNOWN_STATUS_PRIORITY)

                if status_priority > parent_status_priority:
                    parent_status = status

            if status == TransferStatus.FILTERED and transfer.virtual_path:
                # We don't want to count filtered files when calculating the progress
                continue

            elapsed += transfer.time_elapsed
            total_size += transfer.size
            current_byte_offset += transfer.current_byte_offset or 0

        transfer = self.tree_view.get_row_value(iterator, "transfer_data")

        if total_size > UINT64_LIMIT:  # pylint: disable=consider-using-min-builtin
            total_size = UINT64_LIMIT

        if current_byte_offset > UINT64_LIMIT:  # pylint: disable=consider-using-min-builtin
            current_byte_offset = UINT64_LIMIT

        should_update_size = False
        column_ids = []
        column_values = []

        if transfer.status != parent_status:
            column_ids.append("status")
            column_values.append(self.translate_status(parent_status))

            if parent_status == TransferStatus.USER_LOGGED_OFF:
                column_ids.append("is_sensitive_data")
                column_values.append(False)

            elif transfer.status == TransferStatus.USER_LOGGED_OFF:
                column_ids.append("is_sensitive_data")
                column_values.append(True)

            transfer.status = parent_status

        if transfer.speed != speed:
            column_ids.extend(("speed", "speed_data"))
            column_values.extend((self.get_hspeed(speed), speed))

            transfer.speed = speed

        if transfer.time_elapsed != elapsed:
            left = (total_size - current_byte_offset) / speed if speed and total_size > current_byte_offset else 0
            column_ids.extend(("time_elapsed", "time_left", "time_elapsed_data", "time_left_data"))
            column_values.extend((self.get_helapsed(elapsed), self.get_hleft(left), elapsed, left))

            transfer.time_elapsed = elapsed

        if transfer.current_byte_offset != current_byte_offset:
            column_ids.append("current_bytes_data")
            column_values.append(current_byte_offset)

            transfer.current_byte_offset = current_byte_offset
            should_update_size = True

        if transfer.size != total_size:
            column_ids.append("size_data")
            column_values.append(total_size)

            transfer.size = total_size
            should_update_size = True

        if should_update_size:
            column_ids.extend(("percent", "size"))
            column_values.extend((
                self.get_percent(current_byte_offset, total_size),
                self.get_hsize(current_byte_offset, total_size)
            ))

        if column_ids:
            self.tree_view.set_row_values(iterator, column_ids, column_values)

    def update_specific(self, transfer, select_parent=False, use_reverse_file_path=True):

        current_byte_offset = transfer.current_byte_offset or 0
        queue_position = transfer.queue_position
        status = transfer.status or ""

        if transfer.modifier and status == TransferStatus.QUEUED:
            # Priority status
            status += f" ({transfer.modifier})"

        translated_status = self.translate_status(status)
        size = transfer.size
        speed = transfer.speed
        elapsed = transfer.time_elapsed
        left = transfer.time_left
        iterator = transfer.iterator

        # Modify old transfer
        if iterator and iterator not in self.PENDING_ITERATORS:
            should_update_size = False
            old_translated_status = self.tree_view.get_row_value(iterator, "status")
            column_ids = []
            column_values = []

            if old_translated_status != translated_status:
                column_ids.append("status")
                column_values.append(translated_status)

                if transfer.status == TransferStatus.USER_LOGGED_OFF:
                    column_ids.append("is_sensitive_data")
                    column_values.append(False)

                elif old_translated_status == _("User logged off"):
                    column_ids.append("is_sensitive_data")
                    column_values.append(True)

            if self.tree_view.get_row_value(iterator, "speed_data") != speed:
                column_ids.extend(("speed", "speed_data"))
                column_values.extend((self.get_hspeed(speed), speed))

            if self.tree_view.get_row_value(iterator, "time_elapsed_data") != elapsed:
                column_ids.extend(("time_elapsed", "time_left", "time_elapsed_data", "time_left_data"))
                column_values.extend((self.get_helapsed(elapsed), self.get_hleft(left), elapsed, left))

            if self.tree_view.get_row_value(iterator, "current_bytes_data") != current_byte_offset:
                column_ids.append("current_bytes_data")
                column_values.append(current_byte_offset)
                should_update_size = True

            if self.tree_view.get_row_value(iterator, "size_data") != size:
                column_ids.append("size_data")
                column_values.append(size)
                should_update_size = True

            if self.tree_view.get_row_value(iterator, "queue_position_data") != queue_position:
                column_ids.extend(("queue_position", "queue_position_data"))
                column_values.extend((self.get_hqueue_position(queue_position), queue_position))

            if should_update_size:
                column_ids.extend(("percent", "size"))
                column_values.extend((
                    self.get_percent(current_byte_offset, size),
                    self.get_hsize(current_byte_offset, size)
                ))

            if column_ids:
                self.tree_view.set_row_values(iterator, column_ids, column_values)

            return False

        expand_allowed = self.initialized
        expand_user = False
        expand_folder = False
        user_iterator = None
        user_folder_path_iterator = None
        parent_iterator = None
        select_iterator = None

        user = transfer.username
        folder_path, _separator, basename = transfer.virtual_path.rpartition("\\")
        original_folder_path = folder_path = self.get_transfer_folder_path(transfer)
        is_sensitive = (status != TransferStatus.USER_LOGGED_OFF)

        if use_reverse_file_path:
            parts = folder_path.split(self.path_separator)
            parts.reverse()
            folder_path = self.path_separator.join(parts)

        if not self.tree_view.iterators:
            # Hide tab description
            self.container.get_parent().set_visible(True)

        if self.grouping_mode != "ungrouped":
            # Group by folder or user

            empty_int = 0
            empty_str = ""

            if user not in self.users:
                # Create parent if it doesn't exist
                iterator = self.tree_view.add_row(
                    [
                        user,
                        empty_str,
                        empty_str,
                        empty_str,
                        translated_status,
                        empty_str,
                        empty_int,
                        empty_str,
                        empty_str,
                        empty_str,
                        empty_str,
                        empty_int,
                        empty_int,
                        empty_int,
                        empty_int,
                        empty_int,
                        empty_int,
                        is_sensitive,
                        Transfer(user, status=status),  # Dummy Transfer object
                        self.row_id
                    ], select_row=False
                )

                if expand_allowed:
                    expand_user = self.grouping_mode == "folder_grouping" or self.expand_button.get_active()

                self.row_id += 1
                self.users[user] = (iterator, [])

            user_iterator, user_child_transfers = self.users[user]
            parent_iterator = user_iterator

            if select_parent:
                select_iterator = parent_iterator

            if self.grouping_mode == "folder_grouping":
                # Group by folder

                # Make sure we don't add files to the wrong user in the TreeView
                user_folder_path = user + original_folder_path

                if user_folder_path not in self.paths:
                    path_transfer = Transfer(  # Dummy Transfer object
                        user, folder_path=original_folder_path, status=status
                    )
                    iterator = self.tree_view.add_row(
                        [
                            user,
                            folder_path,
                            empty_str,
                            empty_str,
                            translated_status,
                            empty_str,
                            empty_int,
                            empty_str,
                            empty_str,
                            empty_str,
                            empty_str,
                            empty_int,
                            empty_int,
                            empty_int,
                            empty_int,
                            empty_int,
                            empty_int,
                            is_sensitive,
                            path_transfer,
                            self.row_id
                        ], select_row=False, parent_iterator=user_iterator
                    )
                    user_child_transfers.append(path_transfer)
                    expand_folder = expand_allowed and self.expand_button.get_active()
                    self.row_id += 1
                    self.paths[user_folder_path] = (iterator, [])

                user_folder_path_iterator, user_folder_path_child_transfers = self.paths[user_folder_path]
                parent_iterator = user_folder_path_iterator
                user_folder_path_child_transfers.append(transfer)

                if select_parent and (expand_user or self.tree_view.is_row_expanded(user_iterator)):
                    select_iterator = parent_iterator

                # Group by folder, path not visible in file rows
                folder_path = ""
            else:
                user_child_transfers.append(transfer)
        else:
            # No grouping
            if user not in self.users:
                self.users[user] = (None, [])

            user_iterator, user_child_transfers = self.users[user]
            user_child_transfers.append(transfer)

        # Add a new transfer
        transfer.iterator = self.tree_view.add_row([
            user,
            folder_path,
            get_file_type_icon_name(basename),
            basename,
            translated_status,
            self.get_hqueue_position(queue_position),
            self.get_percent(current_byte_offset, size),
            self.get_hsize(current_byte_offset, size),
            self.get_hspeed(speed),
            self.get_helapsed(elapsed),
            self.get_hleft(left),
            size,
            current_byte_offset,
            speed,
            queue_position,
            elapsed,
            left,
            is_sensitive,
            transfer,
            self.row_id
        ], select_row=False, parent_iterator=parent_iterator)
        self.row_id += 1

        if expand_user and user_iterator is not None:
            self.tree_view.expand_row(user_iterator)

        if expand_folder and user_folder_path_iterator is not None:
            self.tree_view.expand_row(user_folder_path_iterator)

        if select_iterator and (not self.tree_view.is_row_selected(select_iterator)
                                or self.tree_view.get_num_selected_rows() != 1):
            # Select parent row of newly added transfer, and scroll to it.
            # Unselect any other rows to prevent accidental actions on previously
            # selected transfers.
            self.tree_view.unselect_all_rows()
            self.tree_view.select_row(select_iterator, expand_rows=False)

        return True

    def clear_model(self):

        self.initialized = False
        self.users.clear()
        self.paths.clear()
        self.pending_folder_rows.clear()
        self.pending_user_rows.clear()
        self.selected_transfers.clear()
        self.selected_users.clear()
        self.tree_view.clear()
        self.row_id = 0

        for transfer in self.transfer_list:
            transfer.iterator = self.PENDING_ITERATOR_REBUILD

    def get_transfer_folder_path(self, _transfer):
        # Implemented in subclasses
        raise NotImplementedError

    def retry_selected_transfers(self):
        # Implemented in subclasses
        raise NotImplementedError

    def abort_selected_transfers(self):
        # Implemented in subclasses
        raise NotImplementedError

    def remove_selected_transfers(self):
        # Implemented in subclasses
        raise NotImplementedError

    def abort_transfer(self, transfer, status_message=None, update_parent=True):
        if status_message is not None and status_message != TransferStatus.QUEUED:
            self.update_model(transfer, update_parent=update_parent)

    def abort_transfers(self, _transfers, _status_message=None):
        self.update_parent_rows()

    def clear_transfer(self, transfer, update_parent=True):

        iterator = transfer.iterator
        transfer.iterator = None

        if not iterator or iterator in self.PENDING_ITERATORS:
            return

        user = transfer.username

        if self.grouping_mode == "folder_grouping":
            user_folder_path = user + self.get_transfer_folder_path(transfer)
            _user_folder_path_iter, user_folder_path_child_transfers = self.paths[user_folder_path]
            user_folder_path_child_transfers.remove(transfer)
        else:
            _user_iter, user_child_transfers = self.users[user]
            user_child_transfers.remove(transfer)

            if self.grouping_mode == "ungrouped" and not user_child_transfers:
                del self.users[user]

        self.tree_view.remove_row(iterator)

        if update_parent:
            self.update_parent_rows(transfer)
            self.update_num_users_files()

        if not self.tree_view.iterators:
            # Show tab description
            self.container.get_parent().set_visible(False)

    def clear_transfers(self, *_args):
        self.update_parent_rows()

    def add_popup_menu_user(self, popup, user):

        popup.add_items(
            ("", None),
            ("#" + _("Select User's Transfers"), self.on_select_user_transfers, user)
        )
        popup.update_model()
        popup.toggle_user_items()

    def populate_popup_menu_users(self):

        self.popup_menu_users.clear()

        if not self.selected_users:
            return

        # Multiple users, create submenus for some of them
        if len(self.selected_users) > 1:
            for user in islice(self.selected_users, 20):
                popup = UserPopupMenu(self.window.application, username=user, tab_name="transfers")
                self.add_popup_menu_user(popup, user)
                self.popup_menu_users.add_items((">" + user, popup))
                self.popup_menu_users.update_model()
            return

        # Single user, add items directly to "User Actions" submenu
        user = next(iter(self.selected_users), None)
        self.popup_menu_users.setup_user_menu(user)
        self.add_popup_menu_user(self.popup_menu_users, user)

    def on_expand_tree(self, *_args):

        if not self.expand_button.get_visible():
            return

        expanded = self.expand_button.get_active()

        if expanded:
            icon_name = "view-restore-symbolic"
            tooltip_text = _("Collapse All")
            self.tree_view.expand_all_rows()
        else:
            icon_name = "view-fullscreen-symbolic"
            tooltip_text = _("Expand All")
            self.tree_view.collapse_all_rows()

            if self.grouping_mode == "folder_grouping":
                self.tree_view.expand_root_rows()

        icon_args = (Gtk.IconSize.BUTTON,) if GTK_API_VERSION == 3 else ()  # pylint: disable=no-member
        self.expand_icon.set_from_icon_name(icon_name, *icon_args)
        self.expand_button.set_tooltip_text(tooltip_text)

        config.sections["transfers"][f"{self.type}sexpanded"] = expanded
        config.write_configuration()

    def on_toggle_tree(self, action, state):

        mode = state.get_string()
        active = mode != "ungrouped"
        popover = self.grouping_button.get_popover()

        if popover is not None:
            popover.set_visible(False)

        if GTK_API_VERSION >= 4:
            # Ensure buttons are flat in libadwaita
            css_class_function = add_css_class if active else remove_css_class
            css_class_function(widget=self.grouping_button.get_parent(), css_class="linked")

        config.sections["transfers"][f"group{self.type}s"] = mode
        self.tree_view.set_show_expanders(active)
        self.expand_button.set_visible(active)

        self.grouping_mode = mode

        self.clear_model()
        self.tree_view.has_tree = active
        self.tree_view.create_model()

        if self.transfer_list:
            self.update_model()

        action.set_state(state)

    def on_popup_menu(self, menu, _widget):

        self.select_transfers()
        menu.set_num_selected_files(len(self.selected_transfers))

        self.populate_popup_menu_users()

    def on_file_path_tooltip(self, treeview, iterator):
        transfer = treeview.get_row_value(iterator, "transfer_data")
        return transfer.virtual_path or self.get_transfer_folder_path(transfer)

    def on_row_activated(self, _treeview, iterator, _column_id):

        if self.tree_view.collapse_row(iterator):
            return

        if self.tree_view.expand_row(iterator):
            return

        self.select_transfers()
        action = config.sections["transfers"][f"{self.type}_doubleclick"]

        if self.window.application.isolated_mode and action in {1, 2}:
            # External applications not available in isolated_mode mode
            return

        if action == 1:    # Open File
            self.on_open_file()

        elif action == 2:  # Open in File Manager
            self.on_open_file_manager()

        elif action == 3:  # Search
            self.on_search_filename()

        elif action == 4:  # Pause / Abort
            self.abort_selected_transfers()

        elif action == 5:  # Remove
            self.remove_selected_transfers()

        elif action == 6:  # Resume / Retry
            self.retry_selected_transfers()

        elif action == 7:  # Browse Folder
            self.on_browse_folder()

    def on_select_user_transfers(self, _action, _parameter, selected_user):

        if not self.selected_users:
            return

        _user_iterator, user_child_transfers = self.users[selected_user]

        self.tree_view.unselect_all_rows()

        for transfer in user_child_transfers:
            iterator = transfer.iterator

            if iterator:
                self.tree_view.select_row(iterator, should_scroll=False)
                continue

            # Dummy Transfer object for folder rows
            user_folder_path = transfer.username + self.get_transfer_folder_path(transfer)
            user_folder_path_data = self.paths.get(user_folder_path)

            if not user_folder_path_data:
                continue

            _user_folder_path_iter, user_folder_path_child_transfers = user_folder_path_data

            for i_transfer in user_folder_path_child_transfers:
                self.tree_view.select_row(i_transfer.iterator, should_scroll=False)

    def on_abort_transfers_accelerator(self, *_args):
        """T - abort transfer."""

        self.select_transfers()
        self.abort_selected_transfers()
        return True

    def on_retry_transfers_accelerator(self, *_args):
        """R - retry transfers."""

        self.select_transfers()
        self.retry_selected_transfers()
        return True

    def on_remove_transfers_accelerator(self, *_args):
        """Delete - remove transfers."""

        self.select_transfers()
        self.remove_selected_transfers()
        return True

    def on_file_properties_accelerator(self, *_args):
        """Alt+Return - show file properties dialog."""

        self.select_transfers()
        self.on_file_properties()
        return True

    def on_user_profile(self, *_args):

        username = next(iter(self.selected_users), None)

        if username:
            core.userinfo.show_user(username)

    def on_file_properties(self, *_args):

        data = []
        selected_size = 0
        selected_length = 0

        for transfer in self.selected_transfers:
            username = transfer.username
            watched_user = core.users.watched.get(username)
            speed = 0
            file_path = transfer.virtual_path
            file_size = transfer.size
            file_attributes = transfer.file_attributes
            _bitrate, length, *_unused = FileListMessage.parse_file_attributes(file_attributes)
            selected_size += file_size

            if length:
                selected_length += length

            folder_path, _separator, basename = file_path.rpartition("\\")

            if watched_user is not None:
                speed = watched_user.upload_speed or 0

            data.append({
                "user": transfer.username,
                "file_path": file_path,
                "basename": basename,
                "virtual_folder_path": folder_path,
                "real_folder_path": transfer.folder_path,
                "queue_position": transfer.queue_position,
                "speed": speed,
                "size": file_size,
                "file_attributes": file_attributes,
                "country_code": core.users.countries.get(username)
            })

        if data:
            if self.file_properties is None:
                self.file_properties = FileProperties(self.window.application)

            self.file_properties.update_properties(data, selected_size, selected_length)
            self.file_properties.present()

    def on_copy_file_url(self, *_args):
        # Implemented in subclasses
        raise NotImplementedError

    def on_copy_folder_url(self, *_args):
        # Implemented in subclasses
        raise NotImplementedError

    def on_copy_file_path(self, *_args):

        transfer = next(iter(self.selected_transfers), None)

        if transfer:
            clipboard.copy_text(transfer.virtual_path)

    def on_open_file(self, *_args):
        # Implemented in subclasses
        raise NotImplementedError

    def on_open_file_manager(self, *_args):
        # Implemented in subclasses
        raise NotImplementedError

    def on_browse_folder(self, *_args):
        # Implemented in subclasses
        raise NotImplementedError

    def on_retry_transfer(self, *_args):
        self.select_transfers()
        self.retry_selected_transfers()

    def on_abort_transfer(self, *_args):
        self.select_transfers()
        self.abort_selected_transfers()

    def on_remove_transfer(self, *_args):
        self.select_transfers()
        self.remove_selected_transfers()


===== uploads.py =====
# SPDX-FileCopyrightText: 2020-2025 Nicotine+ Contributors
# SPDX-FileCopyrightText: 2016-2018 Mutnick <mutnick@techie.com>
# SPDX-FileCopyrightText: 2016-2017 Michael Labouebe <gfarmerfr@free.fr>
# SPDX-FileCopyrightText: 2009-2011 quinox <quinox@users.sf.net>
# SPDX-FileCopyrightText: 2009 hedonist <ak@sensi.org>
# SPDX-FileCopyrightText: 2006-2008 daelstorm <daelstorm@gmail.com>
# SPDX-FileCopyrightText: 2003-2004 Hyriand <hyriand@thegraveyard.org>
# SPDX-License-Identifier: GPL-3.0-or-later

import os

from gi.repository import Gtk

from pynicotine.config import config
from pynicotine.core import core
from pynicotine.events import events
from pynicotine.gtkgui.application import GTK_API_VERSION
from pynicotine.gtkgui.popovers.uploadspeeds import UploadSpeeds
from pynicotine.gtkgui.transfers import Transfers
from pynicotine.gtkgui.widgets import clipboard
from pynicotine.gtkgui.widgets.dialogs import OptionDialog
from pynicotine.transfers import TransferStatus
from pynicotine.utils import human_speed
from pynicotine.utils import open_file_path
from pynicotine.utils import open_folder_path


class Uploads(Transfers):

    def __init__(self, window):

        self.path_separator = "\\"
        self.path_label = _("Folder")
        self.retry_label = _("_Retry")
        self.abort_label = _("_Abort")

        self.transfer_page = self.page = window.uploads_page
        self.page.id = "uploads"
        self.toolbar = window.uploads_toolbar
        self.toolbar_start_content = window.uploads_title
        self.toolbar_end_content = window.uploads_end
        self.toolbar_default_widget = window.upload_users_button

        self.user_counter = window.upload_users_label
        self.file_counter = window.upload_files_label
        self.expand_button = window.uploads_expand_button
        self.expand_icon = window.uploads_expand_icon
        self.grouping_button = window.uploads_grouping_button
        self.status_label = window.upload_status_label

        super().__init__(window, transfer_type="upload")

        if GTK_API_VERSION >= 4:
            window.uploads_content.append(self.container)
        else:
            window.uploads_content.add(self.container)

        self.popup_menu_clear.add_items(
            ("#" + _("Finished / Cancelled / Failed"), self.on_clear_finished_failed),
            ("#" + _("Finished / Cancelled"), self.on_clear_finished_cancelled),
            ("", None),
            ("#" + _("Finished"), self.on_clear_finished),
            ("#" + _("Cancelled"), self.on_clear_cancelled),
            ("#" + _("Failed"), self.on_clear_failed),
            ("#" + _("User Logged Off"), self.on_clear_logged_off),
            ("#" + _("Queued…"), self.on_try_clear_queued),
            ("", None),
            ("#" + _("Everything…"), self.on_try_clear_all),
        )
        self.popup_menu_clear.update_model()

        for event_name, callback in (
            ("abort-upload", self.abort_transfer),
            ("abort-uploads", self.abort_transfers),
            ("clear-upload", self.clear_transfer),
            ("clear-uploads", self.clear_transfers),
            ("set-connection-stats", self.set_connection_stats),
            ("start", self.start),
            ("update-upload", self.update_model),
            ("update-upload-limits", self.update_limits),
            ("uploads-shutdown-request", self.shutdown_request),
            ("uploads-shutdown-cancel", self.shutdown_cancel)
        ):
            events.connect(event_name, callback)

        self.upload_speeds = UploadSpeeds(window)

    def start(self):
        self.init_transfers(core.uploads.transfers.values())

    def destroy(self):
        self.upload_speeds.destroy()
        super().destroy()

    def get_transfer_folder_path(self, transfer):

        virtual_path = transfer.virtual_path

        if virtual_path:
            folder_path, _separator, _basename = virtual_path.rpartition("\\")
            return folder_path

        return transfer.folder_path

    def retry_selected_transfers(self):
        core.uploads.retry_uploads(self.selected_transfers)

    def abort_selected_transfers(self):
        core.uploads.abort_uploads(self.selected_transfers, denied_message="Cancelled")

    def remove_selected_transfers(self):
        core.uploads.clear_uploads(uploads=self.selected_transfers)

    def set_connection_stats(self, upload_bandwidth=0, **_kwargs):

        # Sync parent row updates with connection stats
        self._update_pending_parent_rows()

        upload_bandwidth = human_speed(upload_bandwidth)
        upload_bandwidth_text = f"{upload_bandwidth} ( {len(core.uploads.active_users)} )"

        if self.window.upload_status_label.get_text() == upload_bandwidth_text:
            return

        self.window.upload_status_label.set_text(upload_bandwidth_text)
        self.window.application.tray_icon.set_upload_status(
            _("Uploads: %(speed)s") % {"speed": upload_bandwidth})

    def shutdown_request(self):

        icon_name = "system-shutdown-symbolic"
        icon_args = (Gtk.IconSize.BUTTON,) if GTK_API_VERSION == 3 else ()  # pylint: disable=no-member
        toggle_status_action = self.window.lookup_action("toggle-status")

        toggle_status_action.set_enabled(False)
        self.window.user_status_button.set_active(True)
        toggle_status_action.set_enabled(True)

        self.window.user_status_icon.set_from_icon_name(icon_name, *icon_args)
        self.window.user_status_label.set_text(_("Quitting…"))

    def shutdown_cancel(self):
        self.window.update_user_status()

    def on_try_clear_queued(self, *_args):

        OptionDialog(
            parent=self.window,
            title=_("Clear Queued Uploads"),
            message=_("Do you really want to clear all queued uploads?"),
            destructive_response_id="ok",
            callback=self.on_clear_queued
        ).present()

    def on_clear_all_response(self, *_args):
        core.uploads.clear_uploads()

    def on_try_clear_all(self, *_args):

        OptionDialog(
            parent=self.window,
            title=_("Clear All Uploads"),
            message=_("Do you really want to clear all uploads?"),
            destructive_response_id="ok",
            callback=self.on_clear_all_response
        ).present()

    def on_copy_file_url(self, *_args):

        transfer = next(iter(self.selected_transfers), None)

        if transfer:
            user = config.sections["server"]["login"]
            url = core.userbrowse.get_soulseek_url(user, transfer.virtual_path)
            clipboard.copy_text(url)

    def on_copy_folder_url(self, *_args):

        transfer = next(iter(self.selected_transfers), None)

        if transfer:
            user = config.sections["server"]["login"]
            folder_path, separator, _basename = transfer.virtual_path.rpartition("\\")
            url = core.userbrowse.get_soulseek_url(user, folder_path + separator)

            clipboard.copy_text(url)

    def on_open_file_manager(self, *_args):

        transfer = next(iter(self.selected_transfers), None)

        if transfer:
            open_folder_path(transfer.folder_path)

    def on_open_file(self, *_args):

        for transfer in self.selected_transfers:
            basename = transfer.virtual_path.rpartition("\\")[-1]

            open_file_path(os.path.join(transfer.folder_path, basename))

    def on_browse_folder(self, *_args):

        transfer = next(iter(self.selected_transfers), None)

        if not transfer:
            return

        user = config.sections["server"]["login"]
        path = transfer.virtual_path

        core.userbrowse.browse_user(user, path=path)

    def on_abort_users(self, *_args):

        self.select_transfers()

        for transfer in self.transfer_list:
            if transfer.username in self.selected_users and transfer not in self.selected_transfers:
                self.selected_transfers[transfer] = None

        self.abort_selected_transfers()

    def on_clear_queued(self, *_args):
        core.uploads.clear_uploads(statuses={TransferStatus.QUEUED})

    def on_clear_finished(self, *_args):
        core.uploads.clear_uploads(statuses={TransferStatus.FINISHED})

    def on_clear_cancelled(self, *_args):
        core.uploads.clear_uploads(statuses={TransferStatus.CANCELLED})

    def on_clear_failed(self, *_args):
        core.uploads.clear_uploads(statuses={TransferStatus.CONNECTION_TIMEOUT, TransferStatus.LOCAL_FILE_ERROR})

    def on_clear_logged_off(self, *_args):
        core.uploads.clear_uploads(statuses={TransferStatus.USER_LOGGED_OFF})

    def on_clear_finished_cancelled(self, *_args):
        core.uploads.clear_uploads(statuses={TransferStatus.CANCELLED, TransferStatus.FINISHED})

    def on_clear_finished_failed(self, *_args):
        core.uploads.clear_uploads(
            statuses={TransferStatus.CANCELLED, TransferStatus.FINISHED, TransferStatus.CONNECTION_TIMEOUT,
                      TransferStatus.LOCAL_FILE_ERROR})


===== userbrowse.py =====
# SPDX-FileCopyrightText: 2020-2025 Nicotine+ Contributors
# SPDX-FileCopyrightText: 2016-2017 Michael Labouebe <gfarmerfr@free.fr>
# SPDX-FileCopyrightText: 2013 SeeSchloss <see@seos.fr>
# SPDX-FileCopyrightText: 2009-2010 quinox <quinox@users.sf.net>
# SPDX-FileCopyrightText: 2006-2009 daelstorm <daelstorm@gmail.com>
# SPDX-FileCopyrightText: 2003-2004 Hyriand <hyriand@thegraveyard.org>
# SPDX-License-Identifier: GPL-3.0-or-later

import os

from gi.repository import GLib
from gi.repository import GObject
from gi.repository import Gtk
from gi.repository import Pango

from pynicotine.config import config
from pynicotine.core import core
from pynicotine.events import events
from pynicotine.gtkgui.application import GTK_API_VERSION
from pynicotine.gtkgui.dialogs.download import Download
from pynicotine.gtkgui.dialogs.fileproperties import FileProperties
from pynicotine.gtkgui.widgets import clipboard
from pynicotine.gtkgui.widgets import ui
from pynicotine.gtkgui.widgets.accelerator import Accelerator
from pynicotine.gtkgui.widgets.combobox import ComboBox
from pynicotine.gtkgui.widgets.dialogs import EntryDialog
from pynicotine.gtkgui.widgets.filechooser import FolderChooser
from pynicotine.gtkgui.widgets.iconnotebook import IconNotebook
from pynicotine.gtkgui.widgets.infobar import InfoBar
from pynicotine.gtkgui.widgets.popupmenu import PopupMenu
from pynicotine.gtkgui.widgets.popupmenu import FilePopupMenu
from pynicotine.gtkgui.widgets.popupmenu import UserPopupMenu
from pynicotine.gtkgui.widgets.theme import add_css_class
from pynicotine.gtkgui.widgets.theme import get_file_type_icon_name
from pynicotine.gtkgui.widgets.theme import remove_css_class
from pynicotine.gtkgui.widgets.treeview import TreeView
from pynicotine.slskmessages import ConnectionType
from pynicotine.slskmessages import FileListMessage
from pynicotine.slskmessages import UserStatus
from pynicotine.utils import human_size
from pynicotine.utils import humanize
from pynicotine.utils import open_file_path
from pynicotine.utils import open_folder_path


class UserBrowses(IconNotebook):

    def __init__(self, window):

        super().__init__(
            window,
            parent=window.userbrowse_content,
            parent_page=window.userbrowse_page
        )

        self.page = window.userbrowse_page
        self.page.id = "userbrowse"
        self.toolbar = window.userbrowse_toolbar
        self.toolbar_start_content = window.userbrowse_title
        self.toolbar_end_content = window.userbrowse_end
        self.toolbar_default_widget = window.userbrowse_entry

        self.download_dialog = None
        self.file_properties = None

        self.userbrowse_combobox = ComboBox(
            container=self.window.userbrowse_title, has_entry=True,
            entry=self.window.userbrowse_entry, item_selected_callback=self.on_get_shares
        )

        # Events
        for event_name, callback in (
            ("peer-connection-closed", self.peer_connection_error),
            ("peer-connection-error", self.peer_connection_error),
            ("quit", self.quit),
            ("server-disconnect", self.server_disconnect),
            ("shared-file-list-progress", self.shared_file_list_progress),
            ("shared-file-list-response", self.shared_file_list),
            ("user-browse-remove-user", self.remove_user),
            ("user-browse-show-user", self.show_user),
            ("user-status", self.user_status)
        ):
            events.connect(event_name, callback)

    def quit(self):
        self.freeze()

    def destroy(self):

        self.userbrowse_combobox.destroy()

        if self.download_dialog is not None:
            self.download_dialog.destroy()

        if self.file_properties is not None:
            self.file_properties.destroy()

        super().destroy()

    def on_focus(self, *_args):

        if self.window.current_page_id != self.window.userbrowse_page.id:
            return True

        if self.get_n_pages():
            return True

        if self.window.userbrowse_entry.is_sensitive():
            self.window.userbrowse_entry.grab_focus()
            return True

        return False

    def on_remove_all_pages(self, *_args):
        core.userbrowse.remove_all_users()

    def on_restore_removed_page(self, page_args):
        username, = page_args
        core.userbrowse.browse_user(username)

    def on_get_shares(self, *_args):

        entry_text = self.window.userbrowse_entry.get_text().strip()

        if not entry_text:
            return

        self.window.userbrowse_entry.set_text("")

        if entry_text.startswith("slsk://"):
            core.userbrowse.open_soulseek_url(entry_text)
        else:
            core.userbrowse.browse_user(entry_text)

    def show_user(self, user, path=None, new_request=False, switch_page=True):

        page = self.pages.get(user)

        if page is None:
            self.pages[user] = page = UserBrowse(self, user)

            self.append_page(page.container, user, focus_callback=page.on_focus,
                             close_callback=page.on_close, user=user)
            page.set_label(self.get_tab_label_inner(page.container))

        if switch_page:
            self.set_current_page(page.container)
            self.window.change_main_page(self.window.userbrowse_page)

        if new_request:
            page.clear_model()
            page.set_indeterminate_progress()

        page.queued_path = path
        page.browse_queued_path()

    def remove_user(self, user):

        page = self.pages.get(user)

        if page is None:
            return

        page.clear()
        self.remove_page(page.container, page_args=(user,))
        del self.pages[user]
        page.destroy()

    def peer_connection_error(self, username, conn_type, **_unused):

        page = self.pages.get(username)

        if page is None:
            return

        if conn_type == ConnectionType.PEER:
            page.peer_connection_error()

    def user_status(self, msg):

        page = self.pages.get(msg.user)

        if page is not None:
            self.set_user_status(page.container, msg.user, msg.status)

    def shared_file_list_progress(self, user, _sock, position, total):

        page = self.pages.get(user)

        if page is not None:
            page.shared_file_list_progress(position, total)

    def shared_file_list(self, msg):

        page = self.pages.get(msg.username)

        if page is not None:
            page.shared_file_list(msg)

    def server_disconnect(self, *_args):
        for user, page in self.pages.items():
            self.set_user_status(page.container, user, UserStatus.OFFLINE)


class UserBrowse:

    def __init__(self, userbrowses, user):

        (
            self.container,
            self.expand_button,
            self.expand_icon,
            self.file_list_container,
            self.folder_tree_container,
            self.info_bar_container,
            self.num_folders_label,
            self.path_bar,
            self.path_bar_container,
            self.progress_bar,
            self.refresh_button,
            self.retry_button,
            self.save_button,
            self.search_button,
            self.search_entry,
            self.search_entry_revealer,
            self.share_size_label
        ) = ui.load(scope=self, path="userbrowse.ui")

        self.userbrowses = userbrowses
        self.window = userbrowses.window
        self.user = user
        self.indeterminate_progress = False
        self.refreshing = False
        self.local_permission_level = None
        self.queued_path = None

        self.active_folder_path = None
        self.selected_files = {}

        self.search_folder_paths = []
        self.query = None
        self.search_position = 0

        self.info_bar = InfoBar(parent=self.info_bar_container, button=self.retry_button)
        self.path_bar_container.get_hadjustment().connect("changed", self.on_path_bar_scroll)

        # Setup folder_tree_view
        self.folder_tree_view = TreeView(
            self.window, parent=self.folder_tree_container, has_tree=True,
            multi_select=True, activate_row_callback=self.on_folder_row_activated,
            select_row_callback=self.on_select_folder,
            columns={
                # Visible columns
                "folder": {
                    "column_type": "text",
                    "title": _("Folder"),
                    "hide_header": True,
                    "tooltip_callback": self.on_folder_path_tooltip
                },

                # Hidden data columns
                "folder_path_data": {"iterator_key": True}
            }
        )

        # Popup Menu (folder_tree_view)
        self.user_popup_menu = UserPopupMenu(
            self.window.application, callback=self.on_tab_popup, username=user, tab_name="userbrowse"
        )
        self.user_popup_menu.add_items(
            ("", None),
            ("#" + _("_Save Shares List to Disk"), self.on_save),
            ("#" + _("Close All Tabs…"), self.on_close_all_tabs),
            ("#" + _("_Close Tab"), self.on_close)
        )

        self.folder_popup_menu = PopupMenu(self.window.application, self.folder_tree_view.widget,
                                           self.on_folder_popup_menu)

        if user == config.sections["server"]["login"]:
            self.folder_popup_menu.add_items(
                ("#" + _("Upload Folder & Subfolders…"), self.on_upload_folder_recursive_to),
                ("", None)
            )
            if not self.window.application.isolated_mode:
                self.folder_popup_menu.add_items(
                    ("#" + _("Open in File _Manager"), self.on_file_manager)
                )
            self.folder_popup_menu.add_items(
                ("#" + _("F_ile Properties"), self.on_file_properties, True),
                ("", None),
                ("#" + _("Copy _Folder Path"), self.on_copy_folder_path),
                ("#" + _("Copy Folder _URL"), self.on_copy_folder_url),
                ("", None),
                (">" + _("User Actions"), self.user_popup_menu)
            )
        else:
            self.folder_popup_menu.add_items(
                ("#" + _("_Download Folder & Subfolders"), self.on_download_folder_recursive),
                ("#" + _("Download Folder & Subfolders _To…"), self.on_download_folder_recursive_to),
                ("", None),
                ("#" + _("F_ile Properties"), self.on_file_properties, True),
                ("", None),
                ("#" + _("Copy _Folder Path"), self.on_copy_folder_path),
                ("#" + _("Copy Folder _URL"), self.on_copy_folder_url),
                ("", None),
                (">" + _("User Actions"), self.user_popup_menu)
            )

        # Setup file_list_view
        self.file_list_view = TreeView(
            self.window, parent=self.file_list_container, name="user_browse",
            multi_select=True, activate_row_callback=self.on_file_row_activated,
            columns={
                # Visible columns
                "file_type": {
                    "column_type": "icon",
                    "title": _("File Type"),
                    "width": 30,
                    "hide_header": True
                },
                "filename": {
                    "column_type": "text",
                    "title": _("File Name"),
                    "width": 150,
                    "expand_column": True,
                    "default_sort_type": "ascending",
                    "iterator_key": True
                },
                "size": {
                    "column_type": "number",
                    "title": _("Size"),
                    "width": 100,
                    "sort_column": "size_data"
                },
                "quality": {
                    "column_type": "number",
                    "title": _("Quality"),
                    "width": 150,
                    "sort_column": "bitrate_data"
                },
                "length": {
                    "column_type": "number",
                    "title": _("Duration"),
                    "width": 100,
                    "sort_column": "length_data"
                },

                # Hidden data columns
                "size_data": {"data_type": GObject.TYPE_UINT64},
                "bitrate_data": {"data_type": GObject.TYPE_UINT},
                "length_data": {"data_type": GObject.TYPE_UINT},
                "file_attributes_data": {"data_type": GObject.TYPE_PYOBJECT}
            }
        )

        # Popup Menu (file_list_view)
        self.file_popup_menu = FilePopupMenu(
            self.window.application, parent=self.file_list_view.widget, callback=self.on_file_popup_menu
        )
        if user == config.sections["server"]["login"]:
            self.file_popup_menu.add_items(
                ("#" + _("Up_load File(s)…"), self.on_upload_files_to),
                ("#" + _("Upload Folder…"), self.on_upload_folder_to),
                ("", None)
            )
            if not self.window.application.isolated_mode:
                self.file_popup_menu.add_items(
                    ("#" + _("_Open File"), self.on_open_file),
                    ("#" + _("Open in File _Manager"), self.on_file_manager)
                )
            self.file_popup_menu.add_items(
                ("#" + _("F_ile Properties"), self.on_file_properties),
                ("", None),
                ("#" + _("Copy _File Path"), self.on_copy_file_path),
                ("#" + _("Copy File _URL"), self.on_copy_file_url),
                ("", None),
                (">" + _("User Actions"), self.user_popup_menu)
            )
        else:
            self.file_popup_menu.add_items(
                ("#" + _("_Download File(s)"), self.on_download_files),
                ("#" + _("Download File(s) _To…"), self.on_download_files_to),
                ("", None),
                ("#" + _("F_ile Properties"), self.on_file_properties),
                ("", None),
                ("#" + _("Copy _File Path"), self.on_copy_file_path),
                ("#" + _("Copy File _URL"), self.on_copy_file_url),
                ("", None),
                (">" + _("User Actions"), self.user_popup_menu)
            )

        # Key Bindings (folder_tree_view)
        Accelerator("Right", self.folder_tree_view.widget, self.on_folder_expand_accelerator)

        Accelerator("<Shift>Return", self.folder_tree_view.widget, self.on_folder_focus_filetree_accelerator)
        Accelerator("<Primary>Return", self.folder_tree_view.widget, self.on_folder_transfer_to_accelerator)
        Accelerator("<Shift><Primary>Return", self.folder_tree_view.widget, self.on_folder_transfer_accelerator)
        Accelerator("<Primary><Alt>Return", self.folder_tree_view.widget, self.on_folder_open_manager_accelerator)
        Accelerator("<Alt>Return", self.folder_tree_view.widget, self.on_file_properties_accelerator, True)

        # Key Bindings (file_list_view)
        for accelerator in ("BackSpace", "backslash"):  # Navigate up, "\"
            Accelerator(accelerator, self.file_list_view.widget, self.on_focus_folder_accelerator)

        Accelerator("Left", self.file_list_view.widget, self.on_focus_folder_left_accelerator)

        Accelerator("<Shift>Return", self.file_list_view.widget, self.on_file_transfer_multi_accelerator)
        Accelerator("<Primary>Return", self.file_list_view.widget, self.on_file_transfer_to_accelerator)
        Accelerator("<Shift><Primary>Return", self.file_list_view.widget, self.on_file_transfer_accelerator)
        Accelerator("<Primary><Alt>Return", self.file_list_view.widget, self.on_file_open_manager_accelerator)
        Accelerator("<Alt>Return", self.file_list_view.widget, self.on_file_properties_accelerator)

        # Key Bindings (General)
        for widget in (self.container, self.folder_tree_view.widget, self.file_list_view.widget):
            Accelerator("<Primary>f", widget, self.on_search_accelerator)  # Find focus

        Accelerator("Escape", self.search_entry, self.on_search_escape_accelerator)
        Accelerator("F3", self.container, self.on_search_next_accelerator)
        Accelerator("<Shift>F3", self.container, self.on_search_previous_accelerator)
        Accelerator("<Primary>g", self.container, self.on_search_next_accelerator)  # Next search match
        Accelerator("<Shift><Primary>g", self.container, self.on_search_previous_accelerator)
        Accelerator("Up", self.search_entry, self.on_search_previous_accelerator)
        Accelerator("Down", self.search_entry, self.on_search_next_accelerator)

        Accelerator("<Primary>backslash", self.container, self.on_expand_accelerator)  # expand / collapse all (button)
        Accelerator("F5", self.container, self.on_refresh_accelerator)
        Accelerator("<Primary>r", self.container, self.on_refresh_accelerator)  # Refresh
        Accelerator("<Primary>s", self.container, self.on_save_accelerator)  # Save Shares List

        self.popup_menus = (
            self.folder_popup_menu, self.file_popup_menu, self.user_popup_menu
        )

        self.expand_button.set_active(config.sections["userbrowse"]["expand_folders"])

    def clear(self):
        self.clear_model()

    def destroy(self):

        for menu in self.popup_menus:
            menu.destroy()

        self.info_bar.destroy()
        self.folder_tree_view.destroy()
        self.file_list_view.destroy()
        self.__dict__.clear()

        self.indeterminate_progress = False  # Stop progress bar timer

    def set_label(self, label):
        self.user_popup_menu.set_parent(label)

    # Folder/File Views #

    def clear_model(self):

        self.search_position = 0
        self.search_folder_paths.clear()

        self.active_folder_path = None
        self.populate_path_bar()
        self.selected_files.clear()

        self.folder_tree_view.clear()
        self.file_list_view.clear()

    def rebuild_model(self):

        self.clear_model()
        browsed_user = core.userbrowse.users[self.user]

        if browsed_user.num_folders is None or browsed_user.shared_size is None:
            return

        # Generate the folder tree and select first folder
        self.create_folder_tree(browsed_user.public_folders)

        if browsed_user.private_folders:
            self.create_folder_tree(browsed_user.private_folders, private=True)

        self.num_folders_label.set_text(humanize(browsed_user.num_folders))
        self.share_size_label.set_text(human_size(browsed_user.shared_size))

        if self.expand_button.get_active():
            self.folder_tree_view.expand_all_rows()
        else:
            self.folder_tree_view.expand_root_rows()

        self.select_search_match_folder()

    def create_folder_tree(self, folders, private=False):

        if not folders:
            return

        iterators = self.folder_tree_view.iterators
        add_row = self.folder_tree_view.add_row
        query = self.query
        private_template = _("[PRIVATE]  %s")

        for folder_path, files in reversed(list(folders.items())):
            current_path = parent = None
            root_processed = False
            skip_folder = (query and query not in folder_path.lower())

            if skip_folder:
                for file_info in files:
                    if query in file_info[1].lower():
                        skip_folder = False

            if skip_folder:
                continue

            for subfolder in folder_path.split("\\"):
                if not root_processed:
                    current_path = subfolder
                    root_processed = True
                else:
                    current_path += f"\\{subfolder}"

                if current_path in iterators:
                    # Folder was already added to tree
                    parent = iterators[current_path]
                    continue

                if not subfolder:
                    # Most likely a root folder
                    subfolder = "\\"

                if private:
                    subfolder = private_template % subfolder

                parent = add_row(
                    [subfolder, current_path], select_row=False, parent_iterator=parent
                )

            if query:
                self.search_folder_paths.append(folder_path)

        self.search_folder_paths.reverse()

    def browse_queued_path(self):

        if not self.queued_path:
            return

        # Reset search to show all folders
        self.search_entry.set_text("")
        self.search_button.set_active(False)

        folder_path, _separator, basename = self.queued_path.rpartition("\\")
        iterator = self.folder_tree_view.iterators.get(folder_path)

        if not iterator:
            return

        self.queued_path = None

        # Scroll to the requested folder
        self.folder_tree_view.select_row(iterator)

        iterator = self.file_list_view.iterators.get(basename)

        if not iterator:
            self.folder_tree_view.grab_focus()
            return

        # Scroll to the requested file
        self.file_list_view.select_row(iterator)
        self.file_list_view.grab_focus()

    def shared_file_list(self, msg):

        # Always accept file list loaded from disk, but not unsolicited file list messages from
        # online users
        if not self.refreshing and msg.sock is not None:
            return

        is_empty = (not msg.list and not msg.privatelist)
        self.local_permission_level = msg.permission_level

        self.rebuild_model()
        self.info_bar.set_visible(False)

        if is_empty:
            self.info_bar.show_info_message(
                _("User's list of shared files is empty. Either the user is not sharing anything, "
                  "or they are sharing files privately.")
            )
            self.retry_button.set_visible(False)
        else:
            self.browse_queued_path()

        self.set_finished()

    def peer_connection_error(self):

        if not self.refreshing:
            return

        if core.users.statuses.get(self.user, UserStatus.OFFLINE) == UserStatus.OFFLINE:
            error_message = _("Cannot request information from the user, since they are offline.")
        else:
            error_message = _("Cannot request information from the user, possibly due to "
                              "a closed listening port or temporary connectivity issue.")

        self.info_bar.show_error_message(error_message)
        self.retry_button.set_visible(True)
        self.set_finished()

    def pulse_progress(self, repeat=True):

        if not self.indeterminate_progress:
            return False

        self.progress_bar.pulse()
        return repeat

    def shared_file_list_progress(self, position, total):

        if not self.refreshing:
            return

        self.indeterminate_progress = False

        if total <= 0 or position <= 0:
            fraction = 0.0

        elif position < total:
            fraction = float(position) / total

        else:
            fraction = 1.0
            GLib.timeout_add(1000, self.set_finishing)

        self.progress_bar.set_fraction(fraction)

    def set_indeterminate_progress(self):

        if self.indeterminate_progress:
            return

        self.indeterminate_progress = self.refreshing = True
        self.info_bar.set_visible(False)

        if core.users.login_status == UserStatus.OFFLINE and self.user != config.sections["server"]["login"]:
            self.peer_connection_error()
            return

        self.progress_bar.get_parent().set_reveal_child(True)
        self.progress_bar.pulse()
        GLib.timeout_add(320, self.pulse_progress, False)
        GLib.timeout_add(1000, self.pulse_progress)

        self.refresh_button.set_sensitive(False)
        self.save_button.set_sensitive(False)

    def set_finishing(self):

        if hasattr(self, "refresh_button") and not self.refresh_button.get_sensitive():
            self.set_indeterminate_progress()

        return False

    def set_finished(self):

        self.indeterminate_progress = self.refreshing = False

        self.userbrowses.request_tab_changed(self.container)
        self.progress_bar.set_fraction(1.0)
        self.progress_bar.get_parent().set_reveal_child(False)

        self.refresh_button.set_sensitive(True)
        self.save_button.set_sensitive(not self.folder_tree_view.is_empty())

    def populate_path_bar(self, folder_path=""):

        for widget in list(self.path_bar):
            self.path_bar.remove(widget)

        if not folder_path:
            return

        folder_path_split = folder_path.split("\\")

        for index, folder in enumerate(folder_path_split):
            i_folder_path = "\\".join(folder_path_split[:index + 1])

            if index:
                label = Gtk.Label(label="\\", visible=True)

                add_css_class(label, "dim-label")
                add_css_class(label, "heading")

                if GTK_API_VERSION >= 4:
                    self.path_bar.append(label)  # pylint: disable=no-member
                else:
                    self.path_bar.add(label)     # pylint: disable=no-member

            if len(folder) > 10:
                width_chars = 10
                ellipsize = Pango.EllipsizeMode.END
            else:
                width_chars = -1
                ellipsize = Pango.EllipsizeMode.NONE

            button_label = Gtk.Label(label=folder, ellipsize=ellipsize, width_chars=width_chars, visible=True)

            if index == len(folder_path_split) - 1:
                button = Gtk.MenuButton(visible=True)
                self.folder_popup_menu.set_menu_button(button)
                add_css_class(button_label, "heading")

                if GTK_API_VERSION >= 4:
                    button.set_child(button_label)                              # pylint: disable=no-member
                    button.set_always_show_arrow(True)                          # pylint: disable=no-member
                    button.set_has_frame(False)                                 # pylint: disable=no-member
                    button.set_create_popup_func(self.on_folder_popup_menu)     # pylint: disable=no-member

                    inner_button = next(iter(button))
                    button_label.set_mnemonic_widget(inner_button)
                else:
                    box = Gtk.Box(spacing=6, visible=True)
                    arrow_icon = Gtk.Image(icon_name="pan-down-symbolic", visible=True)
                    box.add(button_label)                                       # pylint: disable=no-member
                    box.add(arrow_icon)                                         # pylint: disable=no-member

                    button.add(box)                                             # pylint: disable=no-member
                    button.connect("clicked", self.on_folder_popup_menu)

                    button_label.set_mnemonic_widget(button)
            else:
                button = Gtk.Button(child=button_label, visible=True)
                button.connect("clicked", self.on_path_bar_clicked, i_folder_path)
                add_css_class(button_label, "normal")

                button_label.set_mnemonic_widget(button)

            add_css_class(button, "flat")
            remove_css_class(button, "text-button")

            if GTK_API_VERSION >= 4:
                self.path_bar.append(button)  # pylint: disable=no-member
            else:
                self.path_bar.add(button)     # pylint: disable=no-member

    def set_active_folder(self, folder_path):

        if self.active_folder_path == folder_path:
            return

        browsed_user = core.userbrowse.users.get(self.user)

        if browsed_user is None:
            # Redundant row selection event when closing tab, prevent crash
            return

        self.populate_path_bar(folder_path)
        self.file_list_view.clear()

        self.active_folder_path = folder_path

        if not folder_path:
            return

        files = browsed_user.public_folders.get(folder_path)

        if not files:
            files = browsed_user.private_folders.get(folder_path)

            if not files:
                return

        # Temporarily disable sorting for increased performance
        self.file_list_view.freeze()

        for _code, basename, size, _ext, file_attributes, *_unused in files:
            h_size = human_size(size, config.sections["ui"]["file_size_unit"])
            h_quality, bitrate, h_length, length = FileListMessage.parse_audio_quality_length(size, file_attributes)

            self.file_list_view.add_row([
                get_file_type_icon_name(basename),
                basename,
                h_size,
                h_quality,
                h_length,
                size,
                bitrate,
                length,
                file_attributes
            ], select_row=False)

        self.file_list_view.unfreeze()
        self.select_search_match_files()

    def select_files(self):

        self.selected_files.clear()

        for iterator in self.file_list_view.get_selected_rows():
            basename = self.file_list_view.get_row_value(iterator, "filename")
            filesize = self.file_list_view.get_row_value(iterator, "size_data")

            self.selected_files[basename] = filesize

    def get_selected_folder_path(self):

        for iterator in self.folder_tree_view.get_selected_rows():
            folder_path = self.folder_tree_view.get_row_value(iterator, "folder_path_data")
            return f'{folder_path or ""}\\'

        return None

    def get_selected_file_path(self):
        selected_folder = self.get_selected_folder_path()
        selected_file = next(iter(self.selected_files), "")
        return f"{selected_folder}{selected_file}"

    # Search #

    def select_search_match_folder(self):

        iterator = None

        if self.search_folder_paths:
            folder_path = self.search_folder_paths[self.search_position]
            iterator = self.folder_tree_view.iterators[folder_path]

        self.folder_tree_view.select_row(iterator)

    def select_search_match_files(self):

        if not self.query:
            return

        result_files = []
        found_first_match = False

        for filepath, iterator in self.file_list_view.iterators.items():
            if self.query in filepath.lower():
                result_files.append(iterator)

        self.file_list_view.unselect_all_rows()

        for iterator in result_files:
            # Select each matching file in folder
            self.file_list_view.select_row(iterator, should_scroll=(not found_first_match))
            found_first_match = True

    def find_search_matches(self, reverse=False):

        query = self.search_entry.get_text().lower() or None

        if self.query != query:
            # New search query, rebuild result list
            active_folder_path = self.active_folder_path

            self.query = query
            self.rebuild_model()

            if not self.search_folder_paths:
                iterator = self.folder_tree_view.iterators.get(active_folder_path)

                if iterator:
                    self.folder_tree_view.select_row(iterator)

                return False

        elif query:
            # Increment/decrement search position
            self.search_position += -1 if reverse else 1

        else:
            return False

        if self.search_position < 0:
            self.search_position = len(self.search_folder_paths) - 1

        elif self.search_position >= len(self.search_folder_paths):
            self.search_position = 0

        # Set active folder
        self.select_search_match_folder()

        # Get matching files in the current folder
        self.select_search_match_files()
        return True

    # Callbacks (folder_tree_view) #

    def on_select_folder(self, tree_view, iterator):

        if iterator is None:
            return

        selected_iterators = tree_view.get_selected_rows()
        folder_path = None

        # Skip first folder
        next(selected_iterators)

        if next(selected_iterators, None):
            # Multiple folders selected. Avoid any confusion by clearing the path bar and file list view.
            folder_path = None
        else:
            folder_path = tree_view.get_row_value(iterator, "folder_path_data")

        self.set_active_folder(folder_path)

    def on_folder_path_tooltip(self, treeview, iterator):
        return treeview.get_row_value(iterator, "folder_path_data")

    def on_folder_popup_menu(self, *_args):
        self.folder_popup_menu.update_model()
        self.user_popup_menu.toggle_user_items()

    def on_download_folder_recursive(self, *_args, download_folder_path=None):

        prev_folder_path = None

        for iterator in self.folder_tree_view.get_selected_rows():
            folder_path = self.folder_tree_view.get_row_value(iterator, "folder_path_data")

            if prev_folder_path and prev_folder_path in folder_path:
                # Already recursing, avoid redundant request for subfolder
                continue

            core.userbrowse.download_folder(
                self.user, folder_path, download_folder_path=download_folder_path, recurse=True)

            prev_folder_path = folder_path

    def on_download_folder_recursive_to(self, *_args):

        data = []
        prev_folder_path = None
        selected = True

        for iterator in self.folder_tree_view.get_selected_rows():
            selected_folder_path = self.folder_tree_view.get_row_value(iterator, "folder_path_data")

            if prev_folder_path and prev_folder_path in selected_folder_path:
                continue

            for folder_path, files in core.userbrowse.iter_matching_folders(
                selected_folder_path, browsed_user=core.userbrowse.users[self.user], recurse=True
            ):
                for _code, basename, file_size, _ext, file_attributes, *_unused in files:
                    file_path = "\\".join([folder_path, basename])

                    data.append((self.user, file_path, file_size, file_attributes, selected, selected_folder_path))

            prev_folder_path = selected_folder_path

        if self.userbrowses.download_dialog is None:
            self.userbrowses.download_dialog = Download(self.window.application)

        self.userbrowses.download_dialog.update_files(data, partial_files=False)
        self.userbrowses.download_dialog.present()

    def on_upload_folder_to_response(self, dialog, _response_id, recurse):

        user = dialog.get_entry_value()

        if not user:
            return

        prev_folder_path = None
        sent_upload_notification = False

        for iterator in self.folder_tree_view.get_selected_rows():
            folder_path = self.folder_tree_view.get_row_value(iterator, "folder_path_data")

            if recurse and prev_folder_path and prev_folder_path in folder_path:
                # Already recursing, avoid redundant request for subfolder
                continue

            if not sent_upload_notification:
                core.userbrowse.send_upload_attempt_notification(user)
                sent_upload_notification = True

            core.userbrowse.upload_folder(
                user, folder_path, local_browsed_user=core.userbrowse.users[self.user], recurse=recurse)

            prev_folder_path = folder_path

    def on_upload_folder_to(self, *_args, recurse=False):

        if recurse:
            str_title = _("Upload Folder (with Subfolders) To User")
        else:
            str_title = _("Upload Folder To User")

        EntryDialog(
            parent=self.window,
            title=str_title,
            message=_("Enter the name of the user you want to upload to:"),
            action_button_label=_("_Upload"),
            callback=self.on_upload_folder_to_response,
            callback_data=recurse,
            droplist=sorted(core.buddies.users)
        ).present()

    def on_upload_folder_recursive_to(self, *_args):
        self.on_upload_folder_to(recurse=True)

    def on_copy_folder_path(self, *_args):
        folder_path = self.get_selected_folder_path()
        clipboard.copy_text(folder_path)

    def on_copy_folder_url(self, *_args):
        folder_path = self.get_selected_folder_path()
        folder_url = core.userbrowse.get_soulseek_url(self.user, folder_path)
        clipboard.copy_text(folder_url)

    # Key Bindings (folder_tree_view) #

    def on_folder_row_activated(self, tree_view, iterator, _column_id):

        if iterator is None:
            return

        # Keyboard accessibility support for <Return> key behaviour
        if tree_view.is_row_expanded(iterator):
            expandable = tree_view.collapse_row(iterator)
        else:
            expandable = tree_view.expand_row(iterator)

        if not expandable and not self.file_list_view.is_empty():
            # This is the deepest level, so move focus over to Files if there are any
            self.file_list_view.grab_focus()

        # Note: Other Folder actions are handled by Accelerator functions [Shift/Ctrl/Alt+Return]
        # TODO: Mouse double-click actions will need keycode state & mods [Shift/Ctrl+DblClick]

    def on_folder_expand_accelerator(self, *_args):
        """Right, Shift+Right (Gtk), "+" (Gtk) - expand row."""

        iterator = self.folder_tree_view.get_focused_row()

        if iterator is None:
            return False

        if not self.file_list_view.is_empty():
            self.file_list_view.grab_focus()

        return True

    def on_folder_focus_filetree_accelerator(self, *_args):
        """Shift+Enter - focus selection over FileTree."""

        if not self.file_list_view.is_empty():
            self.file_list_view.grab_focus()
            return True

        iterator = self.folder_tree_view.get_focused_row()

        if iterator is None:
            return False

        self.folder_tree_view.expand_row(iterator)
        return True

    def on_folder_transfer_to_accelerator(self, *_args):
        """Ctrl+Enter - Upload Folder To, Download Folder Into."""

        if self.user == config.sections["server"]["login"]:
            self.on_upload_folder_recursive_to()
        else:
            self.on_download_folder_recursive_to()

        return True

    def on_folder_transfer_accelerator(self, *_args):
        """Shift+Ctrl+Enter - Upload Folder Recursive To, Download Folder (without prompt)."""

        if self.user == config.sections["server"]["login"]:
            self.on_upload_folder_recursive_to()
        else:
            self.on_download_folder_recursive()  # without prompt

        return True

    def on_folder_open_manager_accelerator(self, *_args):
        """Ctrl+Alt+Enter - Open folder in File Manager."""

        if self.user != config.sections["server"]["login"]:
            return False

        self.on_file_manager()
        return True

    # Callbacks (file_list_view) #

    def on_file_popup_menu(self, menu, _widget):

        self.select_files()
        menu.set_num_selected_files(len(self.selected_files))

        self.user_popup_menu.toggle_user_items()

    def _on_download_files(self, *_args):

        folder_path = self.active_folder_path
        browsed_user = core.userbrowse.users[self.user]

        data = []
        files = browsed_user.public_folders.get(folder_path)

        if not files:
            files = browsed_user.private_folders.get(folder_path)

            if not files:
                return

        for file_data in files:
            _code, basename, size, _ext, file_attributes, *_unused = file_data
            file_path = "\\".join([folder_path, basename])
            selected = basename in self.selected_files

            data.append((self.user, file_path, size, file_attributes, selected))

        if self.userbrowses.download_dialog is None:
            self.userbrowses.download_dialog = Download(self.window.application)

        self.userbrowses.download_dialog.update_files(data, partial_files=False)
        self.userbrowses.download_dialog.present()

    def on_download_files(self, *_args, download_folder_path=None):

        folder_path = self.active_folder_path
        browsed_user = core.userbrowse.users[self.user]

        files = browsed_user.public_folders.get(folder_path)

        if not files:
            files = browsed_user.private_folders.get(folder_path)

            if not files:
                return

        for file_data in files:
            _code, basename, *_unused = file_data

            # Find the wanted file
            if self.selected_files and basename not in self.selected_files:
                continue

            core.userbrowse.download_file(
                self.user, folder_path, file_data, download_folder_path=download_folder_path)

    def on_download_files_to_selected(self, selected_download_folder_paths, _data):
        self.on_download_files(download_folder_path=next(iter(selected_download_folder_paths), None))

    def on_download_files_to(self, *_args):

        FolderChooser(
            parent=self.window,
            title=_("Select Destination Folder for Files"),
            callback=self.on_download_files_to_selected,
            initial_folder=core.downloads.get_default_download_folder()
        ).present()

    def on_upload_files_to_response(self, dialog, _response_id, _data):

        user = dialog.get_entry_value()
        folder_path = self.active_folder_path

        if not user or folder_path is None:
            return

        core.userbrowse.send_upload_attempt_notification(user)

        for basename, size in self.selected_files.items():
            core.userbrowse.upload_file(user, folder_path, (None, basename, size))

    def on_upload_files_to(self, *_args):

        EntryDialog(
            parent=self.window,
            title=_("Upload File(s) To User"),
            message=_("Enter the name of the user you want to upload to:"),
            action_button_label=_("_Upload"),
            callback=self.on_upload_files_to_response,
            droplist=sorted(core.buddies.users)
        ).present()

    def on_open_file(self, *_args):

        folder_path = core.shares.virtual2real(self.active_folder_path)

        for basename in self.selected_files:
            open_file_path(os.path.join(folder_path, basename))

    def on_file_manager(self, *_args):

        for iterator in self.folder_tree_view.get_selected_rows():
            folder_path = self.folder_tree_view.get_row_value(iterator, "folder_path_data")
            open_folder_path(core.shares.virtual2real(folder_path))
            return

    def on_file_properties(self, _action, _state, all_files=False):

        data = []
        selected_size = 0
        selected_length = 0
        watched_user = core.users.watched.get(self.user)
        speed = 0

        if watched_user is not None:
            speed = watched_user.upload_speed or 0

        if all_files:
            prev_folder_path = None

            for iterator in self.folder_tree_view.get_selected_rows():
                selected_folder_path = self.folder_tree_view.get_row_value(iterator, "folder_path_data")

                if prev_folder_path and prev_folder_path in selected_folder_path:
                    # Already recursing, avoid duplicates
                    continue

                for folder_path, files in core.userbrowse.iter_matching_folders(
                    selected_folder_path, browsed_user=core.userbrowse.users[self.user], recurse=True
                ):
                    for file_data in files:
                        _code, basename, file_size, _ext, file_attributes, *_unused = file_data
                        _bitrate, length, *_unused = FileListMessage.parse_file_attributes(file_attributes)
                        file_path = "\\".join([folder_path, basename])
                        selected_size += file_size

                        if length:
                            selected_length += length

                        data.append({
                            "user": self.user,
                            "file_path": file_path,
                            "basename": basename,
                            "virtual_folder_path": folder_path,
                            "speed": speed,
                            "size": file_size,
                            "file_attributes": file_attributes
                        })

                prev_folder_path = selected_folder_path

        else:
            selected_folder_path = self.active_folder_path

            for iterator in self.file_list_view.get_selected_rows():
                basename = self.file_list_view.get_row_value(iterator, "filename")
                file_path = "\\".join([selected_folder_path, basename])
                file_size = self.file_list_view.get_row_value(iterator, "size_data")
                selected_size += file_size
                selected_length += self.file_list_view.get_row_value(iterator, "length_data")

                data.append({
                    "user": self.user,
                    "file_path": file_path,
                    "basename": basename,
                    "virtual_folder_path": selected_folder_path,
                    "speed": speed,
                    "size": file_size,
                    "file_attributes": self.file_list_view.get_row_value(iterator, "file_attributes_data"),
                    "country_code": core.users.countries.get(self.user)
                })

        if data:
            if self.userbrowses.file_properties is None:
                self.userbrowses.file_properties = FileProperties(self.window.application)

            self.userbrowses.file_properties.update_properties(data, selected_size, selected_length)
            self.userbrowses.file_properties.present()

    def on_copy_file_path(self, *_args):
        file_path = self.get_selected_file_path()
        clipboard.copy_text(file_path)

    def on_copy_file_url(self, *_args):
        file_path = self.get_selected_file_path()
        file_url = core.userbrowse.get_soulseek_url(self.user, file_path)
        clipboard.copy_text(file_url)

    # Key Bindings (file_list_view) #

    def on_file_row_activated(self, _tree_view, _iterator, _column_id):

        self.select_files()

        if self.user == config.sections["server"]["login"]:
            self.on_open_file()
        else:
            self.on_download_files()

    def on_focus_folder_left_accelerator(self, *_args):
        """Left - focus back parent folder (left arrow)."""

        column_id = self.file_list_view.get_focused_column()

        if next(self.file_list_view.get_visible_columns(), None) != column_id:
            return False  # allow horizontal scrolling

        self.folder_tree_view.grab_focus()
        return True

    def on_focus_folder_accelerator(self, *_args):
        """BackSpace, \backslash - focus selection back parent folder"""

        self.folder_tree_view.grab_focus()
        return True

    def on_file_transfer_to_accelerator(self, *_args):
        """Ctrl+Enter - Upload File(s) To, Download File(s) Into."""

        if self.file_list_view.is_empty():  # avoid navigation trap
            self.folder_tree_view.grab_focus()
            return True

        self.select_files()

        if self.user == config.sections["server"]["login"]:
            if self.file_list_view.is_selection_empty():
                self.on_upload_folder_to()
            else:
                self.on_upload_files_to()

            return True

        self.on_download_files_to()
        return True

    def on_file_transfer_accelerator(self, *_args):
        """Shift+Ctrl+Enter - Upload File(s) To, Download File(s) (without prompt)."""

        if self.file_list_view.is_empty():
            self.folder_tree_view.grab_focus()  # avoid nav trap
            return True

        self.select_files()

        if self.user == config.sections["server"]["login"]:
            if self.file_list_view.is_selection_empty():
                self.on_upload_folder_to()
            else:
                self.on_upload_files_to()

            return True

        self.on_download_files()
        return True

    def on_file_transfer_multi_accelerator(self, *_args):
        """Shift+Enter - Open File, Download Files (multiple)."""

        if self.file_list_view.is_empty():
            self.folder_tree_view.grab_focus()  # avoid nav trap
            return True

        self.select_files()  # support multi-select with Up/Dn keys

        if self.user == config.sections["server"]["login"]:
            self.on_open_file()
        else:
            self.on_download_files()

        return True

    def on_file_open_manager_accelerator(self, *_args):
        """Ctrl+Alt+Enter - Open in File Manager."""

        if self.user == config.sections["server"]["login"]:
            self.on_file_manager()

        else:  # [user is not self]
            self.on_file_properties_accelerator()  # same as Alt+Enter

        return True

    def on_file_properties_accelerator(self, *_args):
        """Alt+Enter - show file properties dialog."""

        if self.file_list_view.is_empty():
            self.folder_tree_view.grab_focus()  # avoid nav trap

        self.on_file_properties(*_args)
        return True

    # Callbacks (General) #

    def on_show_progress_bar(self, progress_bar):
        """Enables indeterminate progress bar mode when tab is active."""

        if not self.indeterminate_progress and progress_bar.get_fraction() <= 0.0:
            self.set_indeterminate_progress()

    def on_hide_progress_bar(self, progress_bar):
        """Disables indeterminate progress bar mode when switching to another tab."""

        if self.indeterminate_progress:
            self.indeterminate_progress = False
            progress_bar.set_fraction(0.0)

    def on_path_bar_clicked(self, _button, folder_path):

        iterator = self.folder_tree_view.iterators.get(folder_path)

        if iterator:
            self.folder_tree_view.select_row(iterator)
            self.folder_tree_view.grab_focus()

    def on_path_bar_scroll(self, adjustment, *_args):

        adjustment_end = (adjustment.get_upper() - adjustment.get_page_size())

        if adjustment.get_value() < adjustment_end:
            self.path_bar_container.emit("scroll-child", Gtk.ScrollType.END, True)

    def on_user_statistics(self, *_args):
        core.userbrowse.show_user_statistics(self.user)

    def on_expand(self, *_args):

        active = self.expand_button.get_active()

        if active:
            icon_name = "view-restore-symbolic"
            tooltip_text = _("Collapse All")
            self.folder_tree_view.expand_all_rows()
        else:
            icon_name = "view-fullscreen-symbolic"
            tooltip_text = _("Expand All")
            self.folder_tree_view.collapse_all_rows()

        icon_args = (Gtk.IconSize.BUTTON,) if GTK_API_VERSION == 3 else ()  # pylint: disable=no-member
        self.expand_icon.set_from_icon_name(icon_name, *icon_args)
        self.expand_button.set_tooltip_text(tooltip_text)

        config.sections["userbrowse"]["expand_folders"] = active

    def on_tab_popup(self, *_args):
        self.user_popup_menu.toggle_user_items()

    def on_search_enabled(self, *_args):
        self.search_button.set_active(self.search_entry_revealer.get_reveal_child())

    def on_show_search(self, *_args):

        active = self.search_button.get_active()

        if active:
            self.search_entry.grab_focus()

        elif not self.file_list_view.is_selection_empty():
            self.file_list_view.grab_focus()

        else:
            self.folder_tree_view.grab_focus()

        self.search_entry_revealer.set_reveal_child(active)

    def on_search(self, *_args):
        self.find_search_matches()

    def on_search_entry_changed(self, *_args):
        if len(self.search_entry.get_text()) <= 0:
            self.find_search_matches()

    def on_save(self, *_args):
        core.userbrowse.save_shares_list_to_disk(self.user)

    def on_refresh(self, *_args):

        if self.refreshing:
            return

        # Remember selection after refresh
        self.select_files()
        file_path = self.get_selected_file_path()

        if self.user == config.sections["server"]["login"]:
            core.userbrowse.browse_local_shares(
                path=file_path, permission_level=self.local_permission_level, new_request=True)
        else:
            core.userbrowse.browse_user(self.user, path=file_path, new_request=True)

    def on_focus(self):

        if self.file_list_view.is_selection_empty():
            self.folder_tree_view.grab_focus()
        else:
            self.file_list_view.grab_focus()

        return True

    def on_close(self, *_args):
        core.userbrowse.remove_user(self.user)

    def on_close_all_tabs(self, *_args):
        self.userbrowses.remove_all_pages()

    # Key Bindings (General) #

    def on_expand_accelerator(self, *_args):
        """Ctrl+\backslash - Expand / Collapse All."""

        self.expand_button.set_active(not self.expand_button.get_active())
        return True

    def on_save_accelerator(self, *_args):
        """Ctrl+S - Save Shares List."""

        if not self.save_button.get_sensitive():
            return False

        self.on_save()
        return True

    def on_refresh_accelerator(self, *_args):
        """Ctrl+R or F5 - Refresh."""

        self.on_refresh()
        return True

    def on_search_accelerator(self, *_args):
        """Ctrl+F - Find."""

        if self.search_button.get_sensitive():
            self.search_button.set_active(True)
            self.search_entry.grab_focus()

        return True

    def on_search_next_accelerator(self, *_args):
        """Ctrl+G or F3 - Find Next."""

        if not self.find_search_matches():
            self.search_entry.grab_focus()

        return True

    def on_search_previous_accelerator(self, *_args):
        """Shift+Ctrl+G or Shift+F3 - Find Previous."""

        if not self.find_search_matches(reverse=True):
            self.search_entry.grab_focus()

        return True

    def on_search_escape_accelerator(self, *_args):
        """Escape - navigate out of search_entry."""

        self.search_button.set_active(False)
        return True


===== userinfo.py =====
# SPDX-FileCopyrightText: 2020-2025 Nicotine+ Contributors
# SPDX-FileCopyrightText: 2016-2017 Michael Labouebe <gfarmerfr@free.fr>
# SPDX-FileCopyrightText: 2008-2010 quinox <quinox@users.sf.net>
# SPDX-FileCopyrightText: 2006-2009 daelstorm <daelstorm@gmail.com>
# SPDX-FileCopyrightText: 2003-2004 Hyriand <hyriand@thegraveyard.org>
# SPDX-License-Identifier: GPL-3.0-or-later

import time

from gi.repository import Gdk
from gi.repository import Gio
from gi.repository import GLib
from gi.repository import Gtk

from pynicotine.config import config
from pynicotine.core import core
from pynicotine.events import events
from pynicotine.gtkgui.application import GTK_API_VERSION
from pynicotine.gtkgui.application import GTK_MINOR_VERSION
from pynicotine.gtkgui.widgets import clipboard
from pynicotine.gtkgui.widgets import ui
from pynicotine.gtkgui.widgets.combobox import ComboBox
from pynicotine.gtkgui.widgets.dialogs import EntryDialog
from pynicotine.gtkgui.widgets.filechooser import FileChooserSave
from pynicotine.gtkgui.widgets.iconnotebook import IconNotebook
from pynicotine.gtkgui.widgets.infobar import InfoBar
from pynicotine.gtkgui.widgets.popupmenu import PopupMenu
from pynicotine.gtkgui.widgets.popupmenu import UserPopupMenu
from pynicotine.gtkgui.widgets.textview import TextView
from pynicotine.gtkgui.widgets.theme import add_css_class
from pynicotine.gtkgui.widgets.theme import get_flag_icon_name
from pynicotine.gtkgui.widgets.theme import remove_css_class
from pynicotine.gtkgui.widgets.treeview import TreeView
from pynicotine.logfacility import log
from pynicotine.slskmessages import ConnectionType
from pynicotine.slskmessages import UserStatus
from pynicotine.utils import humanize
from pynicotine.utils import human_speed


class UserInfos(IconNotebook):

    def __init__(self, window):

        super().__init__(
            window,
            parent=window.userinfo_content,
            parent_page=window.userinfo_page
        )

        self.page = window.userinfo_page
        self.page.id = "userinfo"
        self.toolbar = window.userinfo_toolbar
        self.toolbar_start_content = window.userinfo_title
        self.toolbar_end_content = window.userinfo_end
        self.toolbar_default_widget = window.userinfo_entry

        self.userinfo_combobox = ComboBox(
            container=self.window.userinfo_title, has_entry=True,
            entry=self.window.userinfo_entry, item_selected_callback=self.on_show_user_profile
        )

        # Events
        for event_name, callback in (
            ("add-buddy", self.add_remove_buddy),
            ("ban-user", self.ban_unban_user),
            ("check-privileges", self.check_privileges),
            ("ignore-user", self.ignore_unignore_user),
            ("peer-connection-closed", self.peer_connection_error),
            ("peer-connection-error", self.peer_connection_error),
            ("quit", self.quit),
            ("remove-buddy", self.add_remove_buddy),
            ("server-disconnect", self.server_disconnect),
            ("unban-user", self.ban_unban_user),
            ("unignore-user", self.ignore_unignore_user),
            ("user-country", self.user_country),
            ("user-info-progress", self.user_info_progress),
            ("user-info-remove-user", self.remove_user),
            ("user-info-response", self.user_info_response),
            ("user-info-show-user", self.show_user),
            ("user-interests", self.user_interests),
            ("user-stats", self.user_stats),
            ("user-status", self.user_status)
        ):
            events.connect(event_name, callback)

    def quit(self):
        self.freeze()

    def destroy(self):
        self.userinfo_combobox.destroy()
        super().destroy()

    def on_focus(self, *_args):

        if self.window.current_page_id != self.window.userinfo_page.id:
            return True

        if self.get_n_pages():
            return True

        if self.window.userinfo_entry.is_sensitive():
            self.window.userinfo_entry.grab_focus()
            return True

        return False

    def on_remove_all_pages(self, *_args):
        core.userinfo.remove_all_users()

    def on_restore_removed_page(self, page_args):
        username, = page_args
        core.userinfo.show_user(username)

    def on_show_user_profile(self, *_args):

        username = self.window.userinfo_entry.get_text().strip()

        if not username:
            return

        self.window.userinfo_entry.set_text("")
        core.userinfo.show_user(username)

    def show_user(self, user, refresh=False, switch_page=True):

        page = self.pages.get(user)

        if page is None:
            self.pages[user] = page = UserInfo(self, user)

            self.append_page(page.container, user, focus_callback=page.on_focus,
                             close_callback=page.on_close, user=user)
            page.set_label(self.get_tab_label_inner(page.container))

        if switch_page:
            self.set_current_page(page.container)
            self.window.change_main_page(self.window.userinfo_page)

        if refresh:
            page.set_indeterminate_progress()

    def remove_user(self, user):

        page = self.pages.get(user)

        if page is None:
            return

        page.clear()
        self.remove_page(page.container, page_args=(user,))
        del self.pages[user]
        page.destroy()

    def check_privileges(self, _msg):
        for page in self.pages.values():
            page.update_privileges_button_state()

    def ban_unban_user(self, user):

        page = self.pages.get(user)

        if page is not None:
            page.update_ban_button_state()

    def ignore_unignore_user(self, user):

        page = self.pages.get(user)

        if page is not None:
            page.update_ignore_button_state()

    def add_remove_buddy(self, user, *_args):

        page = self.pages.get(user)

        if page is not None:
            page.update_buddy_button_state()

    def peer_connection_error(self, username, conn_type, **_unused):

        page = self.pages.get(username)

        if page is None:
            return

        if conn_type == ConnectionType.PEER:
            page.peer_connection_error()

    def user_stats(self, msg):

        page = self.pages.get(msg.user)

        if page is not None:
            page.user_stats(msg)

    def user_status(self, msg):

        page = self.pages.get(msg.user)

        if page is not None:
            page.user_status(msg)
            self.set_user_status(page.container, msg.user, msg.status)

    def user_country(self, user, country_code):

        page = self.pages.get(user)

        if page is not None:
            page.user_country(country_code)

    def user_interests(self, msg):

        page = self.pages.get(msg.user)

        if page is not None:
            page.user_interests(msg)

    def user_info_progress(self, user, _sock, position, total):

        page = self.pages.get(user)

        if page is not None:
            page.user_info_progress(position, total)

    def user_info_response(self, msg):

        page = self.pages.get(msg.username)

        if page is not None:
            page.user_info_response(msg)

    def server_disconnect(self, *_args):
        for user, page in self.pages.items():
            self.set_user_status(page.container, user, UserStatus.OFFLINE)


class UserInfo:

    def __init__(self, userinfos, user):

        (
            self.add_remove_buddy_label,
            self.ban_unban_user_button,
            self.ban_unban_user_label,
            self.container,
            self.country_button,
            self.country_icon,
            self.country_label,
            self.description_view_container,
            self.dislikes_list_container,
            self.edit_interests_button,
            self.edit_profile_button,
            self.free_upload_slots_label,
            self.gift_privileges_button,
            self.ignore_unignore_user_button,
            self.ignore_unignore_user_label,
            self.info_bar_container,
            self.interests_container,
            self.likes_list_container,
            self.picture_view,
            self.privileged_user_button,
            self.progress_bar,
            self.queued_uploads_label,
            self.refresh_button,
            self.retry_button,
            self.shared_files_label,
            self.shared_folders_label,
            self.upload_slots_label,
            self.upload_speed_label,
            self.user_info_container,
            self.user_label
        ) = ui.load(scope=self, path="userinfo.ui")

        self.userinfos = userinfos
        self.window = userinfos.window

        self.info_bar = InfoBar(parent=self.info_bar_container, button=self.retry_button)
        self.description_view = TextView(self.description_view_container, editable=False, vertical_margin=5)
        self.user_label.set_text(user)

        if GTK_API_VERSION >= 4:
            self.country_icon.set_pixel_size(21)
            self.picture = Gtk.Picture(can_shrink=True, focusable=True, hexpand=True, vexpand=True)
            self.picture_view.append(self.picture)  # pylint: disable=no-member

            if (GTK_API_VERSION, GTK_MINOR_VERSION) >= (4, 8):
                self.picture.set_content_fit(Gtk.ContentFit.CONTAIN)
            else:
                self.picture.set_keep_aspect_ratio(True)

        else:
            # Setting a pixel size of 21 results in a misaligned country flag
            self.country_icon.set_pixel_size(0)

            self.picture = Gtk.EventBox(           # pylint: disable=c-extension-no-member
                can_focus=True, hexpand=True, vexpand=True, visible=True
            )
            self.picture.connect("draw", self.on_draw_picture)

            self.picture_view.add(self.picture)    # pylint: disable=no-member

        self.user = user
        self.picture_data = None
        self.picture_surface = None
        self.indeterminate_progress = False
        self.refreshing = False

        # Set up likes list
        self.likes_list_view = TreeView(
            self.window, parent=self.likes_list_container,
            activate_row_callback=self.on_likes_row_activated,
            columns={
                "likes": {
                    "column_type": "text",
                    "title": _("Likes"),
                    "default_sort_type": "ascending"
                }
            }
        )

        # Set up dislikes list
        self.dislikes_list_view = TreeView(
            self.window, parent=self.dislikes_list_container,
            activate_row_callback=self.on_dislikes_row_activated,
            columns={
                "dislikes": {
                    "column_type": "text",
                    "title": _("Dislikes"),
                    "default_sort_type": "ascending"
                }
            }
        )

        # Popup menus
        self.user_popup_menu = UserPopupMenu(
            self.window.application, callback=self.on_tab_popup, username=user, tab_name="userinfo"
        )
        self.user_popup_menu.add_items(
            ("", None),
            ("#" + _("Close All Tabs…"), self.on_close_all_tabs),
            ("#" + _("_Close Tab"), self.on_close)
        )

        def get_interest_items(list_view, column_id):
            return (
                ("$" + _("I _Like This"), self.window.interests.on_like_recommendation, list_view, column_id),
                ("$" + _("I _Dislike This"), self.window.interests.on_dislike_recommendation, list_view, column_id),
                ("", None),
                ("#" + _("_Recommendations for Item"), self.window.interests.on_recommend_item, list_view, column_id),
                ("#" + _("_Search for Item"), self.window.interests.on_recommend_search, list_view, column_id)
            )

        self.likes_popup_menu = PopupMenu(self.window.application, self.likes_list_view.widget,
                                          self.on_popup_likes_menu)
        self.likes_popup_menu.add_items(*get_interest_items(self.likes_list_view, "likes"))

        self.dislikes_popup_menu = PopupMenu(self.window.application, self.dislikes_list_view.widget,
                                             self.on_popup_dislikes_menu)
        self.dislikes_popup_menu.add_items(*get_interest_items(self.dislikes_list_view, "dislikes"))

        self.picture_popup_menu = PopupMenu(self.window.application, self.picture)
        self.picture_popup_menu.add_items(
            ("#" + _("_Copy Picture"), self.on_copy_picture),
            ("#" + _("_Save Picture"), self.on_save_picture),
            ("", None),
            ("#" + _("_Hide"), self.on_hide_picture)
        )

        self.popup_menus = (
            self.user_popup_menu, self.likes_popup_menu, self.dislikes_popup_menu,
            self.picture_popup_menu
        )

        self.remove_picture()
        self.populate_stats()
        self.update_button_states()

    def clear(self):

        self.description_view.clear()
        self.likes_list_view.clear()
        self.dislikes_list_view.clear()
        self.remove_picture()

    def destroy(self):

        for menu in self.popup_menus:
            menu.destroy()

        self.info_bar.destroy()
        self.description_view.destroy()
        self.likes_list_view.destroy()
        self.dislikes_list_view.destroy()
        self.__dict__.clear()

        self.indeterminate_progress = False  # Stop progress bar timer

    def set_label(self, label):
        self.user_popup_menu.set_parent(label)

    # General #

    def populate_stats(self):

        country_code = core.users.countries.get(self.user)
        stats = core.users.watched.get(self.user)

        if stats is not None:
            speed = stats.upload_speed or 0
            files = stats.files
            folders = stats.folders
        else:
            speed = 0
            files = folders = None

        if speed > 0:
            self.upload_speed_label.set_text(human_speed(speed))

        if files is not None:
            self.shared_files_label.set_text(humanize(files))

        if folders is not None:
            self.shared_folders_label.set_text(humanize(folders))

        if country_code:
            self.user_country(country_code)

    def remove_picture(self):

        if GTK_API_VERSION >= 4:
            # Empty paintable to prevent container width from shrinking
            self.picture.set_paintable(Gdk.Paintable.new_empty(intrinsic_width=1, intrinsic_height=1))

        self.picture_data = None
        self.picture_surface = None

        self.hide_picture()

    def load_picture(self, data):

        if not data:
            self.remove_picture()
            return

        try:
            if GTK_API_VERSION >= 4:
                self.picture_data = Gdk.Texture.new_from_bytes(GLib.Bytes(data))
                self.picture.set_paintable(self.picture_data)
            else:
                from gi.repository import GdkPixbuf

                data_stream = Gio.MemoryInputStream.new_from_bytes(GLib.Bytes(data))
                self.picture_data = GdkPixbuf.Pixbuf.new_from_stream(data_stream, cancellable=None)
                self.picture_surface = Gdk.cairo_surface_create_from_pixbuf(  # pylint: disable=c-extension-no-member
                    self.picture_data, scale=1, for_window=None)

        except Exception as error:
            log.add(_("Failed to load picture for user %(user)s: %(error)s"), {
                "user": self.user,
                "error": error
            })
            self.remove_picture()
            return

        self.show_picture()

    def show_picture(self):

        if GTK_API_VERSION == 3:
            self.user_info_container.set_hexpand(False)
            self.interests_container.set_hexpand(False)

        self.picture_view.set_visible(True)
        self.picture_view.set_hexpand(True)

        add_css_class(self.interests_container, "border-end")

    def hide_picture(self):

        if GTK_API_VERSION == 3:
            self.user_info_container.set_hexpand(True)
            self.interests_container.set_hexpand(True)

        self.picture_view.set_visible(False)
        self.picture_view.set_hexpand(False)

        remove_css_class(self.interests_container, "border-end")

    def peer_connection_error(self):

        if not self.refreshing:
            return

        if core.users.statuses.get(self.user, UserStatus.OFFLINE) == UserStatus.OFFLINE:
            error_message = _("Cannot request information from the user, since they are offline.")
        else:
            error_message = _("Cannot request information from the user, possibly due to "
                              "a closed listening port or temporary connectivity issue.")

        self.info_bar.show_error_message(error_message)
        self.set_finished()

    def pulse_progress(self, repeat=True):

        if not self.indeterminate_progress:
            return False

        self.progress_bar.pulse()
        return repeat

    def user_info_progress(self, position, total):

        if not self.refreshing:
            return

        self.indeterminate_progress = False

        if total <= 0 or position <= 0:
            fraction = 0.0

        elif position < total:
            fraction = float(position) / total

        else:
            fraction = 1.0

        self.progress_bar.set_fraction(fraction)

    def set_indeterminate_progress(self):

        if self.indeterminate_progress:
            return

        self.indeterminate_progress = self.refreshing = True
        self.info_bar.set_visible(False)

        if core.users.login_status == UserStatus.OFFLINE and self.user != config.sections["server"]["login"]:
            self.peer_connection_error()
            return

        self.progress_bar.get_parent().set_reveal_child(True)
        self.progress_bar.pulse()
        GLib.timeout_add(320, self.pulse_progress, False)
        GLib.timeout_add(1000, self.pulse_progress)

        self.refresh_button.set_sensitive(False)

    def set_finished(self):

        self.indeterminate_progress = self.refreshing = False

        self.userinfos.request_tab_changed(self.container)
        self.progress_bar.set_fraction(1.0)
        self.progress_bar.get_parent().set_reveal_child(False)

        self.refresh_button.set_sensitive(True)

    # Button States #

    def update_local_buttons_state(self):

        local_username = core.users.login_username or config.sections["server"]["login"]

        for widget in (self.edit_interests_button, self.edit_profile_button):
            widget.set_visible(self.user == local_username)

        for widget in (self.ban_unban_user_button, self.ignore_unignore_user_button):
            widget.set_visible(self.user != local_username)

    def update_buddy_button_state(self):
        label = _("Remove _Buddy") if self.user in core.buddies.users else _("Add _Buddy")
        self.add_remove_buddy_label.set_text_with_mnemonic(label)

    def update_ban_button_state(self):
        label = _("Unban User") if core.network_filter.is_user_banned(self.user) else _("Ban User")
        self.ban_unban_user_label.set_text(label)

    def update_ignore_button_state(self):
        label = _("Unignore User") if core.network_filter.is_user_ignored(self.user) else _("Ignore User")
        self.ignore_unignore_user_label.set_text(label)

    def update_privileges_button_state(self):
        self.gift_privileges_button.set_sensitive(bool(core.users.privileges_left))

    def update_button_states(self):

        self.update_local_buttons_state()
        self.update_buddy_button_state()
        self.update_ban_button_state()
        self.update_ignore_button_state()
        self.update_privileges_button_state()

    # Network Messages #

    def user_info_response(self, msg):

        if not self.refreshing:
            return

        if msg is None:
            return

        if msg.descr is not None:
            self.description_view.clear()
            self.description_view.add_line(msg.descr)

        self.free_upload_slots_label.set_text(_("Yes") if msg.slotsavail else _("No"))
        self.upload_slots_label.set_text(humanize(msg.totalupl))
        self.queued_uploads_label.set_text(humanize(msg.queuesize))

        self.queued_uploads_label.get_parent().set_visible(bool(msg.queuesize))

        self.picture_data = None
        self.load_picture(msg.pic)

        self.info_bar.set_visible(False)
        self.set_finished()

    def user_status(self, msg):
        self.privileged_user_button.set_visible(msg.privileged)

    def user_stats(self, msg):

        speed = msg.avgspeed or 0
        num_files = msg.files or 0
        num_folders = msg.dirs or 0

        h_speed = human_speed(speed) if speed > 0 else _("Unknown")
        h_num_files = humanize(num_files)
        h_num_folders = humanize(num_folders)

        if self.upload_speed_label.get_text() != h_speed:
            self.upload_speed_label.set_text(h_speed)

        if self.shared_files_label.get_text() != h_num_files:
            self.shared_files_label.set_text(h_num_files)

        if self.shared_folders_label.get_text() != h_num_folders:
            self.shared_folders_label.set_text(h_num_folders)

    def user_country(self, country_code):

        if not country_code:
            return

        country_name = core.network_filter.COUNTRIES.get(country_code, _("Unknown"))

        self.country_label.set_text(country_name)
        self.country_button.set_tooltip_text(f"{country_name} ({country_code})")

        icon_name = get_flag_icon_name(country_code)
        icon_args = (Gtk.IconSize.BUTTON,) if GTK_API_VERSION == 3 else ()  # pylint: disable=no-member

        self.country_icon.set_from_icon_name(icon_name, *icon_args)
        self.country_button.set_visible(bool(icon_name))

    def user_interests(self, msg):

        self.likes_list_view.clear()
        self.likes_list_view.freeze()
        self.dislikes_list_view.clear()
        self.dislikes_list_view.freeze()

        for like in msg.likes:
            self.likes_list_view.add_row([like], select_row=False)

        for hate in msg.hates:
            self.dislikes_list_view.add_row([hate], select_row=False)

        self.likes_list_view.unfreeze()
        self.dislikes_list_view.unfreeze()

    # Callbacks #

    def on_show_progress_bar(self, progress_bar):
        """Enables indeterminate progress bar mode when tab is active."""

        if not self.indeterminate_progress and progress_bar.get_fraction() <= 0.0:
            self.set_indeterminate_progress()

    def on_hide_progress_bar(self, progress_bar):
        """Disables indeterminate progress bar mode when switching to another tab."""

        if self.indeterminate_progress:
            self.indeterminate_progress = False
            progress_bar.set_fraction(0.0)

    def on_draw_picture(self, area, context):
        """Draws a centered picture that fills the drawing area."""

        area_width = area.get_allocated_width()
        area_height = area.get_allocated_height()
        picture_width = self.picture_surface.get_width()
        picture_height = self.picture_surface.get_height()

        scale_factor = min(area_width / picture_width, area_height / picture_height)
        translate_x = (area_width - (picture_width * scale_factor)) / 2
        translate_y = (area_height - (picture_height * scale_factor)) / 2

        context.translate(translate_x, translate_y)
        context.scale(scale_factor, scale_factor)
        context.set_source_surface(self.picture_surface, 0, 0)
        context.paint()

    def on_tab_popup(self, *_args):
        self.user_popup_menu.toggle_user_items()

    def on_popup_likes_menu(self, menu, *_args):
        self.window.interests.toggle_menu_items(menu, self.likes_list_view, column_id="likes")

    def on_popup_dislikes_menu(self, menu, *_args):
        self.window.interests.toggle_menu_items(menu, self.dislikes_list_view, column_id="dislikes")

    def on_edit_profile(self, *_args):
        self.window.application.on_preferences(page_id="user-profile")

    def on_edit_interests(self, *_args):
        self.window.change_main_page(self.window.interests_page)

    def on_likes_row_activated(self, *_args):
        self.window.interests.show_item_recommendations(self.likes_list_view, column_id="likes")

    def on_dislikes_row_activated(self, *_args):
        self.window.interests.show_item_recommendations(self.dislikes_list_view, column_id="dislikes")

    def on_send_message(self, *_args):
        core.privatechat.show_user(self.user)

    def on_show_ip_address(self, *_args):
        core.users.request_ip_address(self.user, notify=True)

    def on_browse_user(self, *_args):
        core.userbrowse.browse_user(self.user)

    def on_add_remove_buddy(self, *_args):

        if self.user in core.buddies.users:
            core.buddies.remove_buddy(self.user)
            return

        core.buddies.add_buddy(self.user)

    def on_ban_unban_user(self, *_args):

        if core.network_filter.is_user_banned(self.user):
            core.network_filter.unban_user(self.user)
            return

        core.network_filter.ban_user(self.user)

    def on_ignore_unignore_user(self, *_args):

        if core.network_filter.is_user_ignored(self.user):
            core.network_filter.unignore_user(self.user)
            return

        core.network_filter.ignore_user(self.user)

    def on_privileged_user(self, *_args):
        log.add(_("User %(user)s has Soulseek privileges. Their downloads are queued ahead "
                  "of those of non-privileged users."), {
            "user": self.user
        }, title=_("Privileged User"))

    def on_give_privileges_response(self, dialog, _response_id, _data):

        days = dialog.get_entry_value()

        if not days:
            return

        try:
            days = int(days)

        except ValueError:
            self.on_give_privileges(error=_("Please enter number of days."))
            return

        core.users.request_give_privileges(self.user, days)

    def on_give_privileges(self, *_args, error=None):

        core.users.request_check_privileges()

        if core.users.privileges_left is None:
            days = _("Unknown")
        else:
            days = core.users.privileges_left // 60 // 60 // 24

        message = (_("Gift days of your Soulseek privileges to user %(user)s (%(days_left)s):") %
                   {"user": self.user, "days_left": _("%(days)s days left") % {"days": days}})

        if error:
            message += "\n\n" + error

        EntryDialog(
            parent=self.window,
            title=_("Gift Privileges"),
            message=message,
            action_button_label=_("_Give Privileges"),
            callback=self.on_give_privileges_response
        ).present()

    def on_copy_picture(self, *_args):

        if self.picture_data is None:
            return

        clipboard.copy_image(self.picture_data)

    def on_save_picture_response(self, selected, *_args):

        file_path = next(iter(selected), None)

        if not file_path:
            return

        if GTK_API_VERSION >= 4:
            picture_bytes = self.picture_data.save_to_png_bytes().get_data()
        else:
            _success, picture_bytes = self.picture_data.save_to_bufferv(
                type="png", option_keys=[], option_values=[])

        core.userinfo.save_user_picture(file_path, picture_bytes)

    def on_save_picture(self, *_args):

        if self.picture_data is None:
            return

        current_date_time = time.strftime("%Y-%m-%d_%H-%M-%S")

        FileChooserSave(
            parent=self.window,
            callback=self.on_save_picture_response,
            initial_folder=core.downloads.get_default_download_folder(),
            initial_file=f"{self.user}_{current_date_time}.png"
        ).present()

    def on_hide_picture(self, *_args):
        self.hide_picture()

    def on_refresh(self, *_args):
        core.userinfo.show_user(self.user, refresh=True)

    def on_focus(self, *_args):
        self.userinfos.grab_focus()
        return True

    def on_close(self, *_args):
        core.userinfo.remove_user(self.user)

    def on_close_all_tabs(self, *_args):
        self.userinfos.remove_all_pages()


===== __init__.py =====
# SPDX-FileCopyrightText: 2021-2025 Nicotine+ Contributors
# SPDX-License-Identifier: GPL-3.0-or-later

import os
import sys

from pynicotine.logfacility import log


def get_default_gtk_version():

    if sys.platform in {"darwin", "win32"}:
        return "4"

    try:
        from gi.repository import GLib
        from gi.repository import Gio

        try:
            dbus_proxy = Gio.DBusProxy.new_for_bus_sync(
                bus_type=Gio.BusType.SESSION,
                flags=0,
                info=None,
                name="org.a11y.Bus",
                object_path="/org/a11y/bus",
                interface_name="org.freedesktop.DBus.Properties"
            )

            # If screen reader is enabled, use GTK 3 until treeviews have been ported to
            # Gtk.ColumnView. Gtk.TreeView doesn't support screen readers in GTK 4.
            if dbus_proxy.Get("(ss)", "org.a11y.Status", "IsEnabled"):
                log.add_debug("Screen reader enabled, using GTK 3 for improved accessibility")
                return "3"

        except GLib.Error:
            # Service not available
            pass

    except ModuleNotFoundError:
        pass

    return "4"


def check_gtk_version(gtk_api_version, is_fallback=False):

    is_gtk3_supported = sys.platform not in {"darwin", "win32"}

    if gtk_api_version == "3" and not is_gtk3_supported:
        log.add("WARNING: Using GTK 3, which might not work properly on Windows and macOS. "
                "GTK 4 will be required in the future.")

    # Require minor version of GTK
    if gtk_api_version == "4":
        pygobject_version = (3, 42, 1)
        gtk_api_version_fallback = None

        if is_gtk3_supported:
            gtk_api_version_fallback = "3"
    else:
        pygobject_version = (3, 38, 0)
        gtk_api_version = "3"
        gtk_api_version_fallback = "4"

    try:
        import gi
        gi.check_version(pygobject_version)

    except (ImportError, ValueError):
        if not is_fallback and gtk_api_version_fallback:
            return check_gtk_version(gtk_api_version=gtk_api_version_fallback, is_fallback=True)

        return _("Cannot find %s, please install it.") % ("PyGObject >=" + ".".join(str(x) for x in pygobject_version))

    try:
        gi.require_version("Gtk", f"{gtk_api_version}.0")

    except ValueError:
        if not is_fallback and gtk_api_version_fallback:
            return check_gtk_version(gtk_api_version=gtk_api_version_fallback, is_fallback=True)

        return _("Cannot find %s, please install it.") % f"GTK >={gtk_api_version}"

    from gi.repository import Gtk  # pylint:disable=unused-import

    if sys.platform == "win32":
        # Ensure all Windows-specific APIs are available
        gi.require_version("GdkWin32", f"{gtk_api_version}.0")
        from gi.repository import GdkWin32  # noqa: F401  # pylint:disable=no-name-in-module,unused-import

    if hasattr(gi, "_ossighelper"):
        # PyGObject sets up a signal helper that wakes up the GLib mainloop when the application
        # receives OS signals. Disable it, since its use of socketpairs currently causes crashes
        # on Windows while a proxy is enabled. We always keep the loop active anyway
        # (on_process_thread_events in application.py).
        gi._ossighelper._wakeup_fd_is_active = True  # pylint:disable=protected-access

    return None


def run(hidden, ci_mode, isolated_mode, multi_instance):
    """Run Nicotine+ GTK GUI."""

    if getattr(sys, "frozen", False):
        # Set up paths for frozen binaries (Windows and macOS)
        executable_folder = os.path.dirname(sys.executable)

        os.environ["GTK_EXE_PREFIX"] = executable_folder
        os.environ["GTK_DATA_PREFIX"] = executable_folder
        os.environ["GTK_PATH"] = executable_folder
        os.environ["XDG_DATA_DIRS"] = os.path.join(executable_folder, "share")
        os.environ["FONTCONFIG_FILE"] = os.path.join(executable_folder, "share", "fonts", "fonts.conf")
        os.environ["FONTCONFIG_PATH"] = os.path.join(executable_folder, "share", "fonts")
        os.environ["GDK_PIXBUF_MODULE_FILE"] = os.path.join(executable_folder, "lib", "pixbuf-loaders.cache")
        os.environ["GI_TYPELIB_PATH"] = os.path.join(executable_folder, "lib", "typelibs")
        os.environ["GSETTINGS_SCHEMA_DIR"] = os.path.join(executable_folder, "lib", "schemas")

    if sys.platform == "win32":
        # 'win32' PangoCairo backend on Windows is too slow, use 'fontconfig' instead
        os.environ["PANGOCAIRO_BACKEND"] = "fontconfig"

        # Disable client-side decorations when header bar is disabled
        os.environ["GTK_CSD"] = "0"

        # Use Cairo software rendering due to flickering issues in the GPU renderer (#2859).
        # Reevaluate when the new GPU renderers are stable:
        # https://blog.gtk.org/2024/01/28/new-renderers-for-gtk/
        os.environ["GDK_DISABLE"] = "gl,vulkan"
        os.environ["GSK_RENDERER"] = "cairo"

    error = check_gtk_version(gtk_api_version=os.environ.get("NICOTINE_GTK_VERSION", get_default_gtk_version()))

    if error:
        log.add(error)
        return 1

    from gi.repository import Gdk

    if not ci_mode and Gdk.Display.get_default() is None:
        log.add(_("No graphical environment available, using headless (no GUI) mode"))
        return None

    from pynicotine.gtkgui.application import Application
    return Application(hidden, ci_mode, isolated_mode, multi_instance).run()


